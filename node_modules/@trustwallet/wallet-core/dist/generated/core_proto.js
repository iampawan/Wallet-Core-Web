/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.TW = (function() {
    
        /**
         * Namespace TW.
         * @exports TW
         * @namespace
         */
        var TW = {};
    
        TW.Aeternity = (function() {
    
            /**
             * Namespace Aeternity.
             * @memberof TW
             * @namespace
             */
            var Aeternity = {};
    
            Aeternity.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Aeternity
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Aeternity.Proto
                     * @interface ISigningInput
                     * @property {string|null} [fromAddress] SigningInput fromAddress
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [fee] SigningInput fee
                     * @property {string|null} [payload] SigningInput payload
                     * @property {Long|null} [ttl] SigningInput ttl
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Aeternity.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Aeternity.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fromAddress = "";
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput fee.
                     * @member {Uint8Array} fee
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.newBuffer([]);
    
                    /**
                     * SigningInput payload.
                     * @member {string} payload
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payload = "";
    
                    /**
                     * SigningInput ttl.
                     * @member {Long} ttl
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Aeternity.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Aeternity.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.amount);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fee);
                        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.payload);
                        if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.ttl);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.nonce);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aeternity.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aeternity.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.amount = reader.bytes();
                                break;
                            case 4:
                                message.fee = reader.bytes();
                                break;
                            case 5:
                                message.payload = reader.string();
                                break;
                            case 6:
                                message.ttl = reader.uint64();
                                break;
                            case 7:
                                message.nonce = reader.uint64();
                                break;
                            case 8:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!(message.fee && typeof message.fee.length === "number" || $util.isString(message.fee)))
                                return "fee: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!$util.isString(message.payload))
                                return "payload: string expected";
                        if (message.ttl != null && message.hasOwnProperty("ttl"))
                            if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                                return "ttl: integer|Long expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aeternity.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aeternity.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Aeternity.Proto.SigningInput();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.fee != null)
                            if (typeof object.fee === "string")
                                $util.base64.decode(object.fee, message.fee = $util.newBuffer($util.base64.length(object.fee)), 0);
                            else if (object.fee.length)
                                message.fee = object.fee;
                        if (object.payload != null)
                            message.payload = String(object.payload);
                        if (object.ttl != null)
                            if ($util.Long)
                                (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = true;
                            else if (typeof object.ttl === "string")
                                message.ttl = parseInt(object.ttl, 10);
                            else if (typeof object.ttl === "number")
                                message.ttl = object.ttl;
                            else if (typeof object.ttl === "object")
                                message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber(true);
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {TW.Aeternity.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.fee = "";
                            else {
                                object.fee = [];
                                if (options.bytes !== Array)
                                    object.fee = $util.newBuffer(object.fee);
                            }
                            object.payload = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.ttl = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = options.bytes === String ? $util.base64.encode(message.fee, 0, message.fee.length) : options.bytes === Array ? Array.prototype.slice.call(message.fee) : message.fee;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = message.payload;
                        if (message.ttl != null && message.hasOwnProperty("ttl"))
                            if (typeof message.ttl === "number")
                                object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                            else
                                object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber(true) : message.ttl;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Aeternity.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [encoded] SigningOutput encoded
                     * @property {string|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Aeternity.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Aeternity.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {string} encoded
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = "";
    
                    /**
                     * SigningOutput signature.
                     * @member {string} signature
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Aeternity.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Aeternity.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.encoded);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aeternity.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aeternity.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.string();
                                break;
                            case 2:
                                message.signature = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!$util.isString(message.encoded))
                                return "encoded: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!$util.isString(message.signature))
                                return "signature: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aeternity.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aeternity.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Aeternity.Proto.SigningOutput();
                        if (object.encoded != null)
                            message.encoded = String(object.encoded);
                        if (object.signature != null)
                            message.signature = String(object.signature);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {TW.Aeternity.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.encoded = "";
                            object.signature = "";
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Aeternity;
        })();
    
        TW.Aion = (function() {
    
            /**
             * Namespace Aion.
             * @memberof TW
             * @namespace
             */
            var Aion = {};
    
            Aion.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Aion
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Aion.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [payload] SigningInput payload
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {Long|null} [timestamp] SigningInput timestamp
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Aion.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Aion.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {TW.Aion.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Aion.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Aion.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {TW.Aion.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.gasLimit);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.amount);
                        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.privateKey);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.timestamp);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aion.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aion.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nonce = reader.bytes();
                                break;
                            case 2:
                                message.gasPrice = reader.bytes();
                                break;
                            case 3:
                                message.gasLimit = reader.bytes();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.amount = reader.bytes();
                                break;
                            case 6:
                                message.payload = reader.bytes();
                                break;
                            case 7:
                                message.privateKey = reader.bytes();
                                break;
                            case 8:
                                message.timestamp = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aion.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aion.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Aion.Proto.SigningInput();
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {TW.Aion.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                        }
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Aion.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Aion.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Aion.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {TW.Aion.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Aion.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Aion.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {TW.Aion.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aion.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aion.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aion.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aion.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Aion.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {TW.Aion.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Aion;
        })();
    
        TW.Algorand = (function() {
    
            /**
             * Namespace Algorand.
             * @memberof TW
             * @namespace
             */
            var Algorand = {};
    
            Algorand.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Algorand
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transfer = (function() {
    
                    /**
                     * Properties of a Transfer.
                     * @memberof TW.Algorand.Proto
                     * @interface ITransfer
                     * @property {string|null} [toAddress] Transfer toAddress
                     * @property {Long|null} [amount] Transfer amount
                     */
    
                    /**
                     * Constructs a new Transfer.
                     * @memberof TW.Algorand.Proto
                     * @classdesc Represents a Transfer.
                     * @implements ITransfer
                     * @constructor
                     * @param {TW.Algorand.Proto.ITransfer=} [properties] Properties to set
                     */
                    function Transfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transfer toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Algorand.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.toAddress = "";
    
                    /**
                     * Transfer amount.
                     * @member {Long} amount
                     * @memberof TW.Algorand.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Algorand.Proto.Transfer
                     * @static
                     * @param {TW.Algorand.Proto.ITransfer=} [properties] Properties to set
                     * @returns {TW.Algorand.Proto.Transfer} Transfer instance
                     */
                    Transfer.create = function create(properties) {
                        return new Transfer(properties);
                    };
    
                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.Algorand.Proto.Transfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Algorand.Proto.Transfer
                     * @static
                     * @param {TW.Algorand.Proto.ITransfer} message Transfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Algorand.Proto.Transfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Algorand.Proto.Transfer} Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Algorand.Proto.Transfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.toAddress = reader.string();
                                break;
                            case 2:
                                message.amount = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transfer message.
                     * @function verify
                     * @memberof TW.Algorand.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Algorand.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Algorand.Proto.Transfer} Transfer
                     */
                    Transfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Algorand.Proto.Transfer)
                            return object;
                        var message = new $root.TW.Algorand.Proto.Transfer();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Algorand.Proto.Transfer
                     * @static
                     * @param {TW.Algorand.Proto.Transfer} message Transfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this Transfer to JSON.
                     * @function toJSON
                     * @memberof TW.Algorand.Proto.Transfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transfer;
                })();
    
                Proto.AssetTransfer = (function() {
    
                    /**
                     * Properties of an AssetTransfer.
                     * @memberof TW.Algorand.Proto
                     * @interface IAssetTransfer
                     * @property {string|null} [toAddress] AssetTransfer toAddress
                     * @property {Long|null} [amount] AssetTransfer amount
                     * @property {Long|null} [assetId] AssetTransfer assetId
                     */
    
                    /**
                     * Constructs a new AssetTransfer.
                     * @memberof TW.Algorand.Proto
                     * @classdesc Represents an AssetTransfer.
                     * @implements IAssetTransfer
                     * @constructor
                     * @param {TW.Algorand.Proto.IAssetTransfer=} [properties] Properties to set
                     */
                    function AssetTransfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AssetTransfer toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @instance
                     */
                    AssetTransfer.prototype.toAddress = "";
    
                    /**
                     * AssetTransfer amount.
                     * @member {Long} amount
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @instance
                     */
                    AssetTransfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * AssetTransfer assetId.
                     * @member {Long} assetId
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @instance
                     */
                    AssetTransfer.prototype.assetId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new AssetTransfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @static
                     * @param {TW.Algorand.Proto.IAssetTransfer=} [properties] Properties to set
                     * @returns {TW.Algorand.Proto.AssetTransfer} AssetTransfer instance
                     */
                    AssetTransfer.create = function create(properties) {
                        return new AssetTransfer(properties);
                    };
    
                    /**
                     * Encodes the specified AssetTransfer message. Does not implicitly {@link TW.Algorand.Proto.AssetTransfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @static
                     * @param {TW.Algorand.Proto.IAssetTransfer} message AssetTransfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AssetTransfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
                        if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.assetId);
                        return writer;
                    };
    
                    /**
                     * Decodes an AssetTransfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Algorand.Proto.AssetTransfer} AssetTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AssetTransfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Algorand.Proto.AssetTransfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.toAddress = reader.string();
                                break;
                            case 2:
                                message.amount = reader.uint64();
                                break;
                            case 3:
                                message.assetId = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an AssetTransfer message.
                     * @function verify
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AssetTransfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            if (!$util.isInteger(message.assetId) && !(message.assetId && $util.isInteger(message.assetId.low) && $util.isInteger(message.assetId.high)))
                                return "assetId: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an AssetTransfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Algorand.Proto.AssetTransfer} AssetTransfer
                     */
                    AssetTransfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Algorand.Proto.AssetTransfer)
                            return object;
                        var message = new $root.TW.Algorand.Proto.AssetTransfer();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.assetId != null)
                            if ($util.Long)
                                (message.assetId = $util.Long.fromValue(object.assetId)).unsigned = true;
                            else if (typeof object.assetId === "string")
                                message.assetId = parseInt(object.assetId, 10);
                            else if (typeof object.assetId === "number")
                                message.assetId = object.assetId;
                            else if (typeof object.assetId === "object")
                                message.assetId = new $util.LongBits(object.assetId.low >>> 0, object.assetId.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an AssetTransfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @static
                     * @param {TW.Algorand.Proto.AssetTransfer} message AssetTransfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AssetTransfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.assetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.assetId = options.longs === String ? "0" : 0;
                        }
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            if (typeof message.assetId === "number")
                                object.assetId = options.longs === String ? String(message.assetId) : message.assetId;
                            else
                                object.assetId = options.longs === String ? $util.Long.prototype.toString.call(message.assetId) : options.longs === Number ? new $util.LongBits(message.assetId.low >>> 0, message.assetId.high >>> 0).toNumber(true) : message.assetId;
                        return object;
                    };
    
                    /**
                     * Converts this AssetTransfer to JSON.
                     * @function toJSON
                     * @memberof TW.Algorand.Proto.AssetTransfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AssetTransfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return AssetTransfer;
                })();
    
                Proto.AssetOptIn = (function() {
    
                    /**
                     * Properties of an AssetOptIn.
                     * @memberof TW.Algorand.Proto
                     * @interface IAssetOptIn
                     * @property {Long|null} [assetId] AssetOptIn assetId
                     */
    
                    /**
                     * Constructs a new AssetOptIn.
                     * @memberof TW.Algorand.Proto
                     * @classdesc Represents an AssetOptIn.
                     * @implements IAssetOptIn
                     * @constructor
                     * @param {TW.Algorand.Proto.IAssetOptIn=} [properties] Properties to set
                     */
                    function AssetOptIn(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AssetOptIn assetId.
                     * @member {Long} assetId
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @instance
                     */
                    AssetOptIn.prototype.assetId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new AssetOptIn instance using the specified properties.
                     * @function create
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @static
                     * @param {TW.Algorand.Proto.IAssetOptIn=} [properties] Properties to set
                     * @returns {TW.Algorand.Proto.AssetOptIn} AssetOptIn instance
                     */
                    AssetOptIn.create = function create(properties) {
                        return new AssetOptIn(properties);
                    };
    
                    /**
                     * Encodes the specified AssetOptIn message. Does not implicitly {@link TW.Algorand.Proto.AssetOptIn.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @static
                     * @param {TW.Algorand.Proto.IAssetOptIn} message AssetOptIn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AssetOptIn.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.assetId);
                        return writer;
                    };
    
                    /**
                     * Decodes an AssetOptIn message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Algorand.Proto.AssetOptIn} AssetOptIn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AssetOptIn.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Algorand.Proto.AssetOptIn();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.assetId = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an AssetOptIn message.
                     * @function verify
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AssetOptIn.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            if (!$util.isInteger(message.assetId) && !(message.assetId && $util.isInteger(message.assetId.low) && $util.isInteger(message.assetId.high)))
                                return "assetId: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an AssetOptIn message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Algorand.Proto.AssetOptIn} AssetOptIn
                     */
                    AssetOptIn.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Algorand.Proto.AssetOptIn)
                            return object;
                        var message = new $root.TW.Algorand.Proto.AssetOptIn();
                        if (object.assetId != null)
                            if ($util.Long)
                                (message.assetId = $util.Long.fromValue(object.assetId)).unsigned = true;
                            else if (typeof object.assetId === "string")
                                message.assetId = parseInt(object.assetId, 10);
                            else if (typeof object.assetId === "number")
                                message.assetId = object.assetId;
                            else if (typeof object.assetId === "object")
                                message.assetId = new $util.LongBits(object.assetId.low >>> 0, object.assetId.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an AssetOptIn message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @static
                     * @param {TW.Algorand.Proto.AssetOptIn} message AssetOptIn
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AssetOptIn.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.assetId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.assetId = options.longs === String ? "0" : 0;
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            if (typeof message.assetId === "number")
                                object.assetId = options.longs === String ? String(message.assetId) : message.assetId;
                            else
                                object.assetId = options.longs === String ? $util.Long.prototype.toString.call(message.assetId) : options.longs === Number ? new $util.LongBits(message.assetId.low >>> 0, message.assetId.high >>> 0).toNumber(true) : message.assetId;
                        return object;
                    };
    
                    /**
                     * Converts this AssetOptIn to JSON.
                     * @function toJSON
                     * @memberof TW.Algorand.Proto.AssetOptIn
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AssetOptIn.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return AssetOptIn;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Algorand.Proto
                     * @interface ISigningInput
                     * @property {string|null} [genesisId] SigningInput genesisId
                     * @property {Uint8Array|null} [genesisHash] SigningInput genesisHash
                     * @property {Uint8Array|null} [note] SigningInput note
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {Long|null} [firstRound] SigningInput firstRound
                     * @property {Long|null} [lastRound] SigningInput lastRound
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {TW.Algorand.Proto.ITransfer|null} [transfer] SigningInput transfer
                     * @property {TW.Algorand.Proto.IAssetTransfer|null} [assetTransfer] SigningInput assetTransfer
                     * @property {TW.Algorand.Proto.IAssetOptIn|null} [assetOptIn] SigningInput assetOptIn
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Algorand.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Algorand.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput genesisId.
                     * @member {string} genesisId
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.genesisId = "";
    
                    /**
                     * SigningInput genesisHash.
                     * @member {Uint8Array} genesisHash
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.genesisHash = $util.newBuffer([]);
    
                    /**
                     * SigningInput note.
                     * @member {Uint8Array} note
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.note = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput firstRound.
                     * @member {Long} firstRound
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.firstRound = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput lastRound.
                     * @member {Long} lastRound
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.lastRound = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput transfer.
                     * @member {TW.Algorand.Proto.ITransfer|null|undefined} transfer
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transfer = null;
    
                    /**
                     * SigningInput assetTransfer.
                     * @member {TW.Algorand.Proto.IAssetTransfer|null|undefined} assetTransfer
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.assetTransfer = null;
    
                    /**
                     * SigningInput assetOptIn.
                     * @member {TW.Algorand.Proto.IAssetOptIn|null|undefined} assetOptIn
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.assetOptIn = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput messageOneof.
                     * @member {"transfer"|"assetTransfer"|"assetOptIn"|undefined} messageOneof
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "assetTransfer", "assetOptIn"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @static
                     * @param {TW.Algorand.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Algorand.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Algorand.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @static
                     * @param {TW.Algorand.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.genesisId != null && Object.hasOwnProperty.call(message, "genesisId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.genesisId);
                        if (message.genesisHash != null && Object.hasOwnProperty.call(message, "genesisHash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.genesisHash);
                        if (message.note != null && Object.hasOwnProperty.call(message, "note"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.note);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.privateKey);
                        if (message.firstRound != null && Object.hasOwnProperty.call(message, "firstRound"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.firstRound);
                        if (message.lastRound != null && Object.hasOwnProperty.call(message, "lastRound"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.lastRound);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.fee);
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.Algorand.Proto.Transfer.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.assetTransfer != null && Object.hasOwnProperty.call(message, "assetTransfer"))
                            $root.TW.Algorand.Proto.AssetTransfer.encode(message.assetTransfer, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.assetOptIn != null && Object.hasOwnProperty.call(message, "assetOptIn"))
                            $root.TW.Algorand.Proto.AssetOptIn.encode(message.assetOptIn, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Algorand.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Algorand.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.genesisId = reader.string();
                                break;
                            case 2:
                                message.genesisHash = reader.bytes();
                                break;
                            case 3:
                                message.note = reader.bytes();
                                break;
                            case 4:
                                message.privateKey = reader.bytes();
                                break;
                            case 5:
                                message.firstRound = reader.uint64();
                                break;
                            case 6:
                                message.lastRound = reader.uint64();
                                break;
                            case 7:
                                message.fee = reader.uint64();
                                break;
                            case 10:
                                message.transfer = $root.TW.Algorand.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.assetTransfer = $root.TW.Algorand.Proto.AssetTransfer.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.assetOptIn = $root.TW.Algorand.Proto.AssetOptIn.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.genesisId != null && message.hasOwnProperty("genesisId"))
                            if (!$util.isString(message.genesisId))
                                return "genesisId: string expected";
                        if (message.genesisHash != null && message.hasOwnProperty("genesisHash"))
                            if (!(message.genesisHash && typeof message.genesisHash.length === "number" || $util.isString(message.genesisHash)))
                                return "genesisHash: buffer expected";
                        if (message.note != null && message.hasOwnProperty("note"))
                            if (!(message.note && typeof message.note.length === "number" || $util.isString(message.note)))
                                return "note: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.firstRound != null && message.hasOwnProperty("firstRound"))
                            if (!$util.isInteger(message.firstRound) && !(message.firstRound && $util.isInteger(message.firstRound.low) && $util.isInteger(message.firstRound.high)))
                                return "firstRound: integer|Long expected";
                        if (message.lastRound != null && message.hasOwnProperty("lastRound"))
                            if (!$util.isInteger(message.lastRound) && !(message.lastRound && $util.isInteger(message.lastRound.low) && $util.isInteger(message.lastRound.high)))
                                return "lastRound: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Algorand.Proto.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.assetTransfer != null && message.hasOwnProperty("assetTransfer")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Algorand.Proto.AssetTransfer.verify(message.assetTransfer);
                                if (error)
                                    return "assetTransfer." + error;
                            }
                        }
                        if (message.assetOptIn != null && message.hasOwnProperty("assetOptIn")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Algorand.Proto.AssetOptIn.verify(message.assetOptIn);
                                if (error)
                                    return "assetOptIn." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Algorand.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Algorand.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Algorand.Proto.SigningInput();
                        if (object.genesisId != null)
                            message.genesisId = String(object.genesisId);
                        if (object.genesisHash != null)
                            if (typeof object.genesisHash === "string")
                                $util.base64.decode(object.genesisHash, message.genesisHash = $util.newBuffer($util.base64.length(object.genesisHash)), 0);
                            else if (object.genesisHash.length)
                                message.genesisHash = object.genesisHash;
                        if (object.note != null)
                            if (typeof object.note === "string")
                                $util.base64.decode(object.note, message.note = $util.newBuffer($util.base64.length(object.note)), 0);
                            else if (object.note.length)
                                message.note = object.note;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.firstRound != null)
                            if ($util.Long)
                                (message.firstRound = $util.Long.fromValue(object.firstRound)).unsigned = true;
                            else if (typeof object.firstRound === "string")
                                message.firstRound = parseInt(object.firstRound, 10);
                            else if (typeof object.firstRound === "number")
                                message.firstRound = object.firstRound;
                            else if (typeof object.firstRound === "object")
                                message.firstRound = new $util.LongBits(object.firstRound.low >>> 0, object.firstRound.high >>> 0).toNumber(true);
                        if (object.lastRound != null)
                            if ($util.Long)
                                (message.lastRound = $util.Long.fromValue(object.lastRound)).unsigned = true;
                            else if (typeof object.lastRound === "string")
                                message.lastRound = parseInt(object.lastRound, 10);
                            else if (typeof object.lastRound === "number")
                                message.lastRound = object.lastRound;
                            else if (typeof object.lastRound === "object")
                                message.lastRound = new $util.LongBits(object.lastRound.low >>> 0, object.lastRound.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.Algorand.Proto.SigningInput.transfer: object expected");
                            message.transfer = $root.TW.Algorand.Proto.Transfer.fromObject(object.transfer);
                        }
                        if (object.assetTransfer != null) {
                            if (typeof object.assetTransfer !== "object")
                                throw TypeError(".TW.Algorand.Proto.SigningInput.assetTransfer: object expected");
                            message.assetTransfer = $root.TW.Algorand.Proto.AssetTransfer.fromObject(object.assetTransfer);
                        }
                        if (object.assetOptIn != null) {
                            if (typeof object.assetOptIn !== "object")
                                throw TypeError(".TW.Algorand.Proto.SigningInput.assetOptIn: object expected");
                            message.assetOptIn = $root.TW.Algorand.Proto.AssetOptIn.fromObject(object.assetOptIn);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @static
                     * @param {TW.Algorand.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.genesisId = "";
                            if (options.bytes === String)
                                object.genesisHash = "";
                            else {
                                object.genesisHash = [];
                                if (options.bytes !== Array)
                                    object.genesisHash = $util.newBuffer(object.genesisHash);
                            }
                            if (options.bytes === String)
                                object.note = "";
                            else {
                                object.note = [];
                                if (options.bytes !== Array)
                                    object.note = $util.newBuffer(object.note);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.firstRound = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.firstRound = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.lastRound = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.lastRound = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                        }
                        if (message.genesisId != null && message.hasOwnProperty("genesisId"))
                            object.genesisId = message.genesisId;
                        if (message.genesisHash != null && message.hasOwnProperty("genesisHash"))
                            object.genesisHash = options.bytes === String ? $util.base64.encode(message.genesisHash, 0, message.genesisHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.genesisHash) : message.genesisHash;
                        if (message.note != null && message.hasOwnProperty("note"))
                            object.note = options.bytes === String ? $util.base64.encode(message.note, 0, message.note.length) : options.bytes === Array ? Array.prototype.slice.call(message.note) : message.note;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.firstRound != null && message.hasOwnProperty("firstRound"))
                            if (typeof message.firstRound === "number")
                                object.firstRound = options.longs === String ? String(message.firstRound) : message.firstRound;
                            else
                                object.firstRound = options.longs === String ? $util.Long.prototype.toString.call(message.firstRound) : options.longs === Number ? new $util.LongBits(message.firstRound.low >>> 0, message.firstRound.high >>> 0).toNumber(true) : message.firstRound;
                        if (message.lastRound != null && message.hasOwnProperty("lastRound"))
                            if (typeof message.lastRound === "number")
                                object.lastRound = options.longs === String ? String(message.lastRound) : message.lastRound;
                            else
                                object.lastRound = options.longs === String ? $util.Long.prototype.toString.call(message.lastRound) : options.longs === Number ? new $util.LongBits(message.lastRound.low >>> 0, message.lastRound.high >>> 0).toNumber(true) : message.lastRound;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.Algorand.Proto.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.messageOneof = "transfer";
                        }
                        if (message.assetTransfer != null && message.hasOwnProperty("assetTransfer")) {
                            object.assetTransfer = $root.TW.Algorand.Proto.AssetTransfer.toObject(message.assetTransfer, options);
                            if (options.oneofs)
                                object.messageOneof = "assetTransfer";
                        }
                        if (message.assetOptIn != null && message.hasOwnProperty("assetOptIn")) {
                            object.assetOptIn = $root.TW.Algorand.Proto.AssetOptIn.toObject(message.assetOptIn, options);
                            if (options.oneofs)
                                object.messageOneof = "assetOptIn";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Algorand.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Algorand.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Algorand.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Algorand.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @static
                     * @param {TW.Algorand.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Algorand.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Algorand.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @static
                     * @param {TW.Algorand.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Algorand.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Algorand.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Algorand.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Algorand.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Algorand.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @static
                     * @param {TW.Algorand.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Algorand.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Algorand;
        })();
    
        TW.Binance = (function() {
    
            /**
             * Namespace Binance.
             * @memberof TW
             * @namespace
             */
            var Binance = {};
    
            Binance.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Binance
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Binance.Proto
                     * @interface ITransaction
                     * @property {Array.<Uint8Array>|null} [msgs] Transaction msgs
                     * @property {Array.<Uint8Array>|null} [signatures] Transaction signatures
                     * @property {string|null} [memo] Transaction memo
                     * @property {Long|null} [source] Transaction source
                     * @property {Uint8Array|null} [data] Transaction data
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Binance.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.msgs = [];
                        this.signatures = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction msgs.
                     * @member {Array.<Uint8Array>} msgs
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.msgs = $util.emptyArray;
    
                    /**
                     * Transaction signatures.
                     * @member {Array.<Uint8Array>} signatures
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.signatures = $util.emptyArray;
    
                    /**
                     * Transaction memo.
                     * @member {string} memo
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.memo = "";
    
                    /**
                     * Transaction source.
                     * @member {Long} source
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.source = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction data.
                     * @member {Uint8Array} data
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {TW.Binance.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Binance.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {TW.Binance.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.msgs != null && message.msgs.length)
                            for (var i = 0; i < message.msgs.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msgs[i]);
                        if (message.signatures != null && message.signatures.length)
                            for (var i = 0; i < message.signatures.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signatures[i]);
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.memo);
                        if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.source);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.msgs && message.msgs.length))
                                    message.msgs = [];
                                message.msgs.push(reader.bytes());
                                break;
                            case 2:
                                if (!(message.signatures && message.signatures.length))
                                    message.signatures = [];
                                message.signatures.push(reader.bytes());
                                break;
                            case 3:
                                message.memo = reader.string();
                                break;
                            case 4:
                                message.source = reader.int64();
                                break;
                            case 5:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.msgs != null && message.hasOwnProperty("msgs")) {
                            if (!Array.isArray(message.msgs))
                                return "msgs: array expected";
                            for (var i = 0; i < message.msgs.length; ++i)
                                if (!(message.msgs[i] && typeof message.msgs[i].length === "number" || $util.isString(message.msgs[i])))
                                    return "msgs: buffer[] expected";
                        }
                        if (message.signatures != null && message.hasOwnProperty("signatures")) {
                            if (!Array.isArray(message.signatures))
                                return "signatures: array expected";
                            for (var i = 0; i < message.signatures.length; ++i)
                                if (!(message.signatures[i] && typeof message.signatures[i].length === "number" || $util.isString(message.signatures[i])))
                                    return "signatures: buffer[] expected";
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (!$util.isInteger(message.source) && !(message.source && $util.isInteger(message.source.low) && $util.isInteger(message.source.high)))
                                return "source: integer|Long expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Binance.Proto.Transaction();
                        if (object.msgs) {
                            if (!Array.isArray(object.msgs))
                                throw TypeError(".TW.Binance.Proto.Transaction.msgs: array expected");
                            message.msgs = [];
                            for (var i = 0; i < object.msgs.length; ++i)
                                if (typeof object.msgs[i] === "string")
                                    $util.base64.decode(object.msgs[i], message.msgs[i] = $util.newBuffer($util.base64.length(object.msgs[i])), 0);
                                else if (object.msgs[i].length)
                                    message.msgs[i] = object.msgs[i];
                        }
                        if (object.signatures) {
                            if (!Array.isArray(object.signatures))
                                throw TypeError(".TW.Binance.Proto.Transaction.signatures: array expected");
                            message.signatures = [];
                            for (var i = 0; i < object.signatures.length; ++i)
                                if (typeof object.signatures[i] === "string")
                                    $util.base64.decode(object.signatures[i], message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i])), 0);
                                else if (object.signatures[i].length)
                                    message.signatures[i] = object.signatures[i];
                        }
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.source != null)
                            if ($util.Long)
                                (message.source = $util.Long.fromValue(object.source)).unsigned = false;
                            else if (typeof object.source === "string")
                                message.source = parseInt(object.source, 10);
                            else if (typeof object.source === "number")
                                message.source = object.source;
                            else if (typeof object.source === "object")
                                message.source = new $util.LongBits(object.source.low >>> 0, object.source.high >>> 0).toNumber();
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {TW.Binance.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.msgs = [];
                            object.signatures = [];
                        }
                        if (options.defaults) {
                            object.memo = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.source = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.source = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.msgs && message.msgs.length) {
                            object.msgs = [];
                            for (var j = 0; j < message.msgs.length; ++j)
                                object.msgs[j] = options.bytes === String ? $util.base64.encode(message.msgs[j], 0, message.msgs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.msgs[j]) : message.msgs[j];
                        }
                        if (message.signatures && message.signatures.length) {
                            object.signatures = [];
                            for (var j = 0; j < message.signatures.length; ++j)
                                object.signatures[j] = options.bytes === String ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.signatures[j]) : message.signatures[j];
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (typeof message.source === "number")
                                object.source = options.longs === String ? String(message.source) : message.source;
                            else
                                object.source = options.longs === String ? $util.Long.prototype.toString.call(message.source) : options.longs === Number ? new $util.LongBits(message.source.low >>> 0, message.source.high >>> 0).toNumber() : message.source;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.Signature = (function() {
    
                    /**
                     * Properties of a Signature.
                     * @memberof TW.Binance.Proto
                     * @interface ISignature
                     * @property {Uint8Array|null} [pubKey] Signature pubKey
                     * @property {Uint8Array|null} [signature] Signature signature
                     * @property {Long|null} [accountNumber] Signature accountNumber
                     * @property {Long|null} [sequence] Signature sequence
                     */
    
                    /**
                     * Constructs a new Signature.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a Signature.
                     * @implements ISignature
                     * @constructor
                     * @param {TW.Binance.Proto.ISignature=} [properties] Properties to set
                     */
                    function Signature(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signature pubKey.
                     * @member {Uint8Array} pubKey
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.pubKey = $util.newBuffer([]);
    
                    /**
                     * Signature signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Signature accountNumber.
                     * @member {Long} accountNumber
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Signature sequence.
                     * @member {Long} sequence
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new Signature instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {TW.Binance.Proto.ISignature=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.Signature} Signature instance
                     */
                    Signature.create = function create(properties) {
                        return new Signature(properties);
                    };
    
                    /**
                     * Encodes the specified Signature message. Does not implicitly {@link TW.Binance.Proto.Signature.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {TW.Binance.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pubKey);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        if (message.accountNumber != null && Object.hasOwnProperty.call(message, "accountNumber"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.accountNumber);
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.sequence);
                        return writer;
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.Signature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.pubKey = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            case 3:
                                message.accountNumber = reader.int64();
                                break;
                            case 4:
                                message.sequence = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Signature message.
                     * @function verify
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Signature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                            if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                                return "pubKey: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                                return "accountNumber: integer|Long expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.Signature} Signature
                     */
                    Signature.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.Signature)
                            return object;
                        var message = new $root.TW.Binance.Proto.Signature();
                        if (object.pubKey != null)
                            if (typeof object.pubKey === "string")
                                $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                            else if (object.pubKey.length)
                                message.pubKey = object.pubKey;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.accountNumber != null)
                            if ($util.Long)
                                (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = false;
                            else if (typeof object.accountNumber === "string")
                                message.accountNumber = parseInt(object.accountNumber, 10);
                            else if (typeof object.accountNumber === "number")
                                message.accountNumber = object.accountNumber;
                            else if (typeof object.accountNumber === "object")
                                message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber();
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Signature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {TW.Binance.Proto.Signature} message Signature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Signature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.pubKey = "";
                            else {
                                object.pubKey = [];
                                if (options.bytes !== Array)
                                    object.pubKey = $util.newBuffer(object.pubKey);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.accountNumber = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                        }
                        if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                            object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (typeof message.accountNumber === "number")
                                object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                            else
                                object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber() : message.accountNumber;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                        return object;
                    };
    
                    /**
                     * Converts this Signature to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Signature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Signature.PubKey = (function() {
    
                        /**
                         * Properties of a PubKey.
                         * @memberof TW.Binance.Proto.Signature
                         * @interface IPubKey
                         */
    
                        /**
                         * Constructs a new PubKey.
                         * @memberof TW.Binance.Proto.Signature
                         * @classdesc Represents a PubKey.
                         * @implements IPubKey
                         * @constructor
                         * @param {TW.Binance.Proto.Signature.IPubKey=} [properties] Properties to set
                         */
                        function PubKey(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Creates a new PubKey instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {TW.Binance.Proto.Signature.IPubKey=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.Signature.PubKey} PubKey instance
                         */
                        PubKey.create = function create(properties) {
                            return new PubKey(properties);
                        };
    
                        /**
                         * Encodes the specified PubKey message. Does not implicitly {@link TW.Binance.Proto.Signature.PubKey.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {TW.Binance.Proto.Signature.IPubKey} message PubKey message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PubKey.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };
    
                        /**
                         * Decodes a PubKey message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.Signature.PubKey} PubKey
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PubKey.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.Signature.PubKey();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a PubKey message.
                         * @function verify
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PubKey.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };
    
                        /**
                         * Creates a PubKey message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.Signature.PubKey} PubKey
                         */
                        PubKey.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.Signature.PubKey)
                                return object;
                            return new $root.TW.Binance.Proto.Signature.PubKey();
                        };
    
                        /**
                         * Creates a plain object from a PubKey message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {TW.Binance.Proto.Signature.PubKey} message PubKey
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PubKey.toObject = function toObject() {
                            return {};
                        };
    
                        /**
                         * Converts this PubKey to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PubKey.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return PubKey;
                    })();
    
                    return Signature;
                })();
    
                Proto.TradeOrder = (function() {
    
                    /**
                     * Properties of a TradeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITradeOrder
                     * @property {Uint8Array|null} [sender] TradeOrder sender
                     * @property {string|null} [id] TradeOrder id
                     * @property {string|null} [symbol] TradeOrder symbol
                     * @property {Long|null} [ordertype] TradeOrder ordertype
                     * @property {Long|null} [side] TradeOrder side
                     * @property {Long|null} [price] TradeOrder price
                     * @property {Long|null} [quantity] TradeOrder quantity
                     * @property {Long|null} [timeinforce] TradeOrder timeinforce
                     */
    
                    /**
                     * Constructs a new TradeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TradeOrder.
                     * @implements ITradeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITradeOrder=} [properties] Properties to set
                     */
                    function TradeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TradeOrder sender.
                     * @member {Uint8Array} sender
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.sender = $util.newBuffer([]);
    
                    /**
                     * TradeOrder id.
                     * @member {string} id
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.id = "";
    
                    /**
                     * TradeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.symbol = "";
    
                    /**
                     * TradeOrder ordertype.
                     * @member {Long} ordertype
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.ordertype = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder side.
                     * @member {Long} side
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.side = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder price.
                     * @member {Long} price
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.price = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder quantity.
                     * @member {Long} quantity
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.quantity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder timeinforce.
                     * @member {Long} timeinforce
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.timeinforce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TradeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITradeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TradeOrder} TradeOrder instance
                     */
                    TradeOrder.create = function create(properties) {
                        return new TradeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TradeOrder message. Does not implicitly {@link TW.Binance.Proto.TradeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITradeOrder} message TradeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TradeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sender);
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.symbol);
                        if (message.ordertype != null && Object.hasOwnProperty.call(message, "ordertype"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.ordertype);
                        if (message.side != null && Object.hasOwnProperty.call(message, "side"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.side);
                        if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.price);
                        if (message.quantity != null && Object.hasOwnProperty.call(message, "quantity"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.quantity);
                        if (message.timeinforce != null && Object.hasOwnProperty.call(message, "timeinforce"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.timeinforce);
                        return writer;
                    };
    
                    /**
                     * Decodes a TradeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TradeOrder} TradeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TradeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TradeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.sender = reader.bytes();
                                break;
                            case 2:
                                message.id = reader.string();
                                break;
                            case 3:
                                message.symbol = reader.string();
                                break;
                            case 4:
                                message.ordertype = reader.int64();
                                break;
                            case 5:
                                message.side = reader.int64();
                                break;
                            case 6:
                                message.price = reader.int64();
                                break;
                            case 7:
                                message.quantity = reader.int64();
                                break;
                            case 8:
                                message.timeinforce = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TradeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TradeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                                return "sender: buffer expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.ordertype != null && message.hasOwnProperty("ordertype"))
                            if (!$util.isInteger(message.ordertype) && !(message.ordertype && $util.isInteger(message.ordertype.low) && $util.isInteger(message.ordertype.high)))
                                return "ordertype: integer|Long expected";
                        if (message.side != null && message.hasOwnProperty("side"))
                            if (!$util.isInteger(message.side) && !(message.side && $util.isInteger(message.side.low) && $util.isInteger(message.side.high)))
                                return "side: integer|Long expected";
                        if (message.price != null && message.hasOwnProperty("price"))
                            if (!$util.isInteger(message.price) && !(message.price && $util.isInteger(message.price.low) && $util.isInteger(message.price.high)))
                                return "price: integer|Long expected";
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            if (!$util.isInteger(message.quantity) && !(message.quantity && $util.isInteger(message.quantity.low) && $util.isInteger(message.quantity.high)))
                                return "quantity: integer|Long expected";
                        if (message.timeinforce != null && message.hasOwnProperty("timeinforce"))
                            if (!$util.isInteger(message.timeinforce) && !(message.timeinforce && $util.isInteger(message.timeinforce.low) && $util.isInteger(message.timeinforce.high)))
                                return "timeinforce: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TradeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TradeOrder} TradeOrder
                     */
                    TradeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TradeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TradeOrder();
                        if (object.sender != null)
                            if (typeof object.sender === "string")
                                $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                            else if (object.sender.length)
                                message.sender = object.sender;
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.ordertype != null)
                            if ($util.Long)
                                (message.ordertype = $util.Long.fromValue(object.ordertype)).unsigned = false;
                            else if (typeof object.ordertype === "string")
                                message.ordertype = parseInt(object.ordertype, 10);
                            else if (typeof object.ordertype === "number")
                                message.ordertype = object.ordertype;
                            else if (typeof object.ordertype === "object")
                                message.ordertype = new $util.LongBits(object.ordertype.low >>> 0, object.ordertype.high >>> 0).toNumber();
                        if (object.side != null)
                            if ($util.Long)
                                (message.side = $util.Long.fromValue(object.side)).unsigned = false;
                            else if (typeof object.side === "string")
                                message.side = parseInt(object.side, 10);
                            else if (typeof object.side === "number")
                                message.side = object.side;
                            else if (typeof object.side === "object")
                                message.side = new $util.LongBits(object.side.low >>> 0, object.side.high >>> 0).toNumber();
                        if (object.price != null)
                            if ($util.Long)
                                (message.price = $util.Long.fromValue(object.price)).unsigned = false;
                            else if (typeof object.price === "string")
                                message.price = parseInt(object.price, 10);
                            else if (typeof object.price === "number")
                                message.price = object.price;
                            else if (typeof object.price === "object")
                                message.price = new $util.LongBits(object.price.low >>> 0, object.price.high >>> 0).toNumber();
                        if (object.quantity != null)
                            if ($util.Long)
                                (message.quantity = $util.Long.fromValue(object.quantity)).unsigned = false;
                            else if (typeof object.quantity === "string")
                                message.quantity = parseInt(object.quantity, 10);
                            else if (typeof object.quantity === "number")
                                message.quantity = object.quantity;
                            else if (typeof object.quantity === "object")
                                message.quantity = new $util.LongBits(object.quantity.low >>> 0, object.quantity.high >>> 0).toNumber();
                        if (object.timeinforce != null)
                            if ($util.Long)
                                (message.timeinforce = $util.Long.fromValue(object.timeinforce)).unsigned = false;
                            else if (typeof object.timeinforce === "string")
                                message.timeinforce = parseInt(object.timeinforce, 10);
                            else if (typeof object.timeinforce === "number")
                                message.timeinforce = object.timeinforce;
                            else if (typeof object.timeinforce === "object")
                                message.timeinforce = new $util.LongBits(object.timeinforce.low >>> 0, object.timeinforce.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TradeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {TW.Binance.Proto.TradeOrder} message TradeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TradeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.sender = "";
                            else {
                                object.sender = [];
                                if (options.bytes !== Array)
                                    object.sender = $util.newBuffer(object.sender);
                            }
                            object.id = "";
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.ordertype = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.ordertype = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.side = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.side = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.price = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.price = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.quantity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.quantity = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timeinforce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timeinforce = options.longs === String ? "0" : 0;
                        }
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.ordertype != null && message.hasOwnProperty("ordertype"))
                            if (typeof message.ordertype === "number")
                                object.ordertype = options.longs === String ? String(message.ordertype) : message.ordertype;
                            else
                                object.ordertype = options.longs === String ? $util.Long.prototype.toString.call(message.ordertype) : options.longs === Number ? new $util.LongBits(message.ordertype.low >>> 0, message.ordertype.high >>> 0).toNumber() : message.ordertype;
                        if (message.side != null && message.hasOwnProperty("side"))
                            if (typeof message.side === "number")
                                object.side = options.longs === String ? String(message.side) : message.side;
                            else
                                object.side = options.longs === String ? $util.Long.prototype.toString.call(message.side) : options.longs === Number ? new $util.LongBits(message.side.low >>> 0, message.side.high >>> 0).toNumber() : message.side;
                        if (message.price != null && message.hasOwnProperty("price"))
                            if (typeof message.price === "number")
                                object.price = options.longs === String ? String(message.price) : message.price;
                            else
                                object.price = options.longs === String ? $util.Long.prototype.toString.call(message.price) : options.longs === Number ? new $util.LongBits(message.price.low >>> 0, message.price.high >>> 0).toNumber() : message.price;
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            if (typeof message.quantity === "number")
                                object.quantity = options.longs === String ? String(message.quantity) : message.quantity;
                            else
                                object.quantity = options.longs === String ? $util.Long.prototype.toString.call(message.quantity) : options.longs === Number ? new $util.LongBits(message.quantity.low >>> 0, message.quantity.high >>> 0).toNumber() : message.quantity;
                        if (message.timeinforce != null && message.hasOwnProperty("timeinforce"))
                            if (typeof message.timeinforce === "number")
                                object.timeinforce = options.longs === String ? String(message.timeinforce) : message.timeinforce;
                            else
                                object.timeinforce = options.longs === String ? $util.Long.prototype.toString.call(message.timeinforce) : options.longs === Number ? new $util.LongBits(message.timeinforce.low >>> 0, message.timeinforce.high >>> 0).toNumber() : message.timeinforce;
                        return object;
                    };
    
                    /**
                     * Converts this TradeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TradeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TradeOrder;
                })();
    
                Proto.CancelTradeOrder = (function() {
    
                    /**
                     * Properties of a CancelTradeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ICancelTradeOrder
                     * @property {Uint8Array|null} [sender] CancelTradeOrder sender
                     * @property {string|null} [symbol] CancelTradeOrder symbol
                     * @property {string|null} [refid] CancelTradeOrder refid
                     */
    
                    /**
                     * Constructs a new CancelTradeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a CancelTradeOrder.
                     * @implements ICancelTradeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ICancelTradeOrder=} [properties] Properties to set
                     */
                    function CancelTradeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CancelTradeOrder sender.
                     * @member {Uint8Array} sender
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     */
                    CancelTradeOrder.prototype.sender = $util.newBuffer([]);
    
                    /**
                     * CancelTradeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     */
                    CancelTradeOrder.prototype.symbol = "";
    
                    /**
                     * CancelTradeOrder refid.
                     * @member {string} refid
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     */
                    CancelTradeOrder.prototype.refid = "";
    
                    /**
                     * Creates a new CancelTradeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ICancelTradeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.CancelTradeOrder} CancelTradeOrder instance
                     */
                    CancelTradeOrder.create = function create(properties) {
                        return new CancelTradeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified CancelTradeOrder message. Does not implicitly {@link TW.Binance.Proto.CancelTradeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ICancelTradeOrder} message CancelTradeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CancelTradeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sender);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.refid != null && Object.hasOwnProperty.call(message, "refid"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.refid);
                        return writer;
                    };
    
                    /**
                     * Decodes a CancelTradeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.CancelTradeOrder} CancelTradeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CancelTradeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.CancelTradeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.sender = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.refid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a CancelTradeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CancelTradeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                                return "sender: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.refid != null && message.hasOwnProperty("refid"))
                            if (!$util.isString(message.refid))
                                return "refid: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a CancelTradeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.CancelTradeOrder} CancelTradeOrder
                     */
                    CancelTradeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.CancelTradeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.CancelTradeOrder();
                        if (object.sender != null)
                            if (typeof object.sender === "string")
                                $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                            else if (object.sender.length)
                                message.sender = object.sender;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.refid != null)
                            message.refid = String(object.refid);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CancelTradeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {TW.Binance.Proto.CancelTradeOrder} message CancelTradeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CancelTradeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.sender = "";
                            else {
                                object.sender = [];
                                if (options.bytes !== Array)
                                    object.sender = $util.newBuffer(object.sender);
                            }
                            object.symbol = "";
                            object.refid = "";
                        }
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.refid != null && message.hasOwnProperty("refid"))
                            object.refid = message.refid;
                        return object;
                    };
    
                    /**
                     * Converts this CancelTradeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CancelTradeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CancelTradeOrder;
                })();
    
                Proto.SendOrder = (function() {
    
                    /**
                     * Properties of a SendOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ISendOrder
                     * @property {Array.<TW.Binance.Proto.SendOrder.IInput>|null} [inputs] SendOrder inputs
                     * @property {Array.<TW.Binance.Proto.SendOrder.IOutput>|null} [outputs] SendOrder outputs
                     */
    
                    /**
                     * Constructs a new SendOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SendOrder.
                     * @implements ISendOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ISendOrder=} [properties] Properties to set
                     */
                    function SendOrder(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SendOrder inputs.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IInput>} inputs
                     * @memberof TW.Binance.Proto.SendOrder
                     * @instance
                     */
                    SendOrder.prototype.inputs = $util.emptyArray;
    
                    /**
                     * SendOrder outputs.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IOutput>} outputs
                     * @memberof TW.Binance.Proto.SendOrder
                     * @instance
                     */
                    SendOrder.prototype.outputs = $util.emptyArray;
    
                    /**
                     * Creates a new SendOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {TW.Binance.Proto.ISendOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SendOrder} SendOrder instance
                     */
                    SendOrder.create = function create(properties) {
                        return new SendOrder(properties);
                    };
    
                    /**
                     * Encodes the specified SendOrder message. Does not implicitly {@link TW.Binance.Proto.SendOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {TW.Binance.Proto.ISendOrder} message SendOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SendOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Input.encode(message.inputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Output.encode(message.outputs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SendOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SendOrder} SendOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SendOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.Binance.Proto.SendOrder.Input.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.Binance.Proto.SendOrder.Output.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SendOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SendOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Input.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Output.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SendOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SendOrder} SendOrder
                     */
                    SendOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SendOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.SendOrder();
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.Binance.Proto.SendOrder.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.SendOrder.inputs: object expected");
                                message.inputs[i] = $root.TW.Binance.Proto.SendOrder.Input.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.Binance.Proto.SendOrder.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.SendOrder.outputs: object expected");
                                message.outputs[i] = $root.TW.Binance.Proto.SendOrder.Output.fromObject(object.outputs[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SendOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {TW.Binance.Proto.SendOrder} message SendOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SendOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.Binance.Proto.SendOrder.Input.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.Binance.Proto.SendOrder.Output.toObject(message.outputs[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SendOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SendOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SendOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    SendOrder.Token = (function() {
    
                        /**
                         * Properties of a Token.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @interface IToken
                         * @property {string|null} [denom] Token denom
                         * @property {Long|null} [amount] Token amount
                         */
    
                        /**
                         * Constructs a new Token.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @classdesc Represents a Token.
                         * @implements IToken
                         * @constructor
                         * @param {TW.Binance.Proto.SendOrder.IToken=} [properties] Properties to set
                         */
                        function Token(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Token denom.
                         * @member {string} denom
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @instance
                         */
                        Token.prototype.denom = "";
    
                        /**
                         * Token amount.
                         * @member {Long} amount
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @instance
                         */
                        Token.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                        /**
                         * Creates a new Token instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IToken=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.SendOrder.Token} Token instance
                         */
                        Token.create = function create(properties) {
                            return new Token(properties);
                        };
    
                        /**
                         * Encodes the specified Token message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Token.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IToken} message Token message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Token.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                            return writer;
                        };
    
                        /**
                         * Decodes a Token message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.SendOrder.Token} Token
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Token.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder.Token();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.denom = reader.string();
                                    break;
                                case 2:
                                    message.amount = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Token message.
                         * @function verify
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Token.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.denom != null && message.hasOwnProperty("denom"))
                                if (!$util.isString(message.denom))
                                    return "denom: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                    return "amount: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a Token message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.SendOrder.Token} Token
                         */
                        Token.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.SendOrder.Token)
                                return object;
                            var message = new $root.TW.Binance.Proto.SendOrder.Token();
                            if (object.denom != null)
                                message.denom = String(object.denom);
                            if (object.amount != null)
                                if ($util.Long)
                                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                                else if (typeof object.amount === "string")
                                    message.amount = parseInt(object.amount, 10);
                                else if (typeof object.amount === "number")
                                    message.amount = object.amount;
                                else if (typeof object.amount === "object")
                                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Token message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.Token} message Token
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Token.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.denom = "";
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, false);
                                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.amount = options.longs === String ? "0" : 0;
                            }
                            if (message.denom != null && message.hasOwnProperty("denom"))
                                object.denom = message.denom;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (typeof message.amount === "number")
                                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                                else
                                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                            return object;
                        };
    
                        /**
                         * Converts this Token to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Token.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Token;
                    })();
    
                    SendOrder.Input = (function() {
    
                        /**
                         * Properties of an Input.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @interface IInput
                         * @property {Uint8Array|null} [address] Input address
                         * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [coins] Input coins
                         */
    
                        /**
                         * Constructs a new Input.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @classdesc Represents an Input.
                         * @implements IInput
                         * @constructor
                         * @param {TW.Binance.Proto.SendOrder.IInput=} [properties] Properties to set
                         */
                        function Input(properties) {
                            this.coins = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Input address.
                         * @member {Uint8Array} address
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @instance
                         */
                        Input.prototype.address = $util.newBuffer([]);
    
                        /**
                         * Input coins.
                         * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} coins
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @instance
                         */
                        Input.prototype.coins = $util.emptyArray;
    
                        /**
                         * Creates a new Input instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IInput=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.SendOrder.Input} Input instance
                         */
                        Input.create = function create(properties) {
                            return new Input(properties);
                        };
    
                        /**
                         * Encodes the specified Input message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Input.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IInput} message Input message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Input.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
                            if (message.coins != null && message.coins.length)
                                for (var i = 0; i < message.coins.length; ++i)
                                    $root.TW.Binance.Proto.SendOrder.Token.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Decodes an Input message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.SendOrder.Input} Input
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Input.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder.Input();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.address = reader.bytes();
                                    break;
                                case 2:
                                    if (!(message.coins && message.coins.length))
                                        message.coins = [];
                                    message.coins.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies an Input message.
                         * @function verify
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Input.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.address != null && message.hasOwnProperty("address"))
                                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                                    return "address: buffer expected";
                            if (message.coins != null && message.hasOwnProperty("coins")) {
                                if (!Array.isArray(message.coins))
                                    return "coins: array expected";
                                for (var i = 0; i < message.coins.length; ++i) {
                                    var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.coins[i]);
                                    if (error)
                                        return "coins." + error;
                                }
                            }
                            return null;
                        };
    
                        /**
                         * Creates an Input message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.SendOrder.Input} Input
                         */
                        Input.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.SendOrder.Input)
                                return object;
                            var message = new $root.TW.Binance.Proto.SendOrder.Input();
                            if (object.address != null)
                                if (typeof object.address === "string")
                                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                                else if (object.address.length)
                                    message.address = object.address;
                            if (object.coins) {
                                if (!Array.isArray(object.coins))
                                    throw TypeError(".TW.Binance.Proto.SendOrder.Input.coins: array expected");
                                message.coins = [];
                                for (var i = 0; i < object.coins.length; ++i) {
                                    if (typeof object.coins[i] !== "object")
                                        throw TypeError(".TW.Binance.Proto.SendOrder.Input.coins: object expected");
                                    message.coins[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.coins[i]);
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an Input message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.Input} message Input
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Input.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.coins = [];
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.address = "";
                                else {
                                    object.address = [];
                                    if (options.bytes !== Array)
                                        object.address = $util.newBuffer(object.address);
                                }
                            if (message.address != null && message.hasOwnProperty("address"))
                                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                            if (message.coins && message.coins.length) {
                                object.coins = [];
                                for (var j = 0; j < message.coins.length; ++j)
                                    object.coins[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.coins[j], options);
                            }
                            return object;
                        };
    
                        /**
                         * Converts this Input to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Input.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Input;
                    })();
    
                    SendOrder.Output = (function() {
    
                        /**
                         * Properties of an Output.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @interface IOutput
                         * @property {Uint8Array|null} [address] Output address
                         * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [coins] Output coins
                         */
    
                        /**
                         * Constructs a new Output.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @classdesc Represents an Output.
                         * @implements IOutput
                         * @constructor
                         * @param {TW.Binance.Proto.SendOrder.IOutput=} [properties] Properties to set
                         */
                        function Output(properties) {
                            this.coins = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Output address.
                         * @member {Uint8Array} address
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @instance
                         */
                        Output.prototype.address = $util.newBuffer([]);
    
                        /**
                         * Output coins.
                         * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} coins
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @instance
                         */
                        Output.prototype.coins = $util.emptyArray;
    
                        /**
                         * Creates a new Output instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IOutput=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.SendOrder.Output} Output instance
                         */
                        Output.create = function create(properties) {
                            return new Output(properties);
                        };
    
                        /**
                         * Encodes the specified Output message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Output.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IOutput} message Output message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Output.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
                            if (message.coins != null && message.coins.length)
                                for (var i = 0; i < message.coins.length; ++i)
                                    $root.TW.Binance.Proto.SendOrder.Token.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Decodes an Output message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.SendOrder.Output} Output
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Output.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder.Output();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.address = reader.bytes();
                                    break;
                                case 2:
                                    if (!(message.coins && message.coins.length))
                                        message.coins = [];
                                    message.coins.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies an Output message.
                         * @function verify
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Output.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.address != null && message.hasOwnProperty("address"))
                                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                                    return "address: buffer expected";
                            if (message.coins != null && message.hasOwnProperty("coins")) {
                                if (!Array.isArray(message.coins))
                                    return "coins: array expected";
                                for (var i = 0; i < message.coins.length; ++i) {
                                    var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.coins[i]);
                                    if (error)
                                        return "coins." + error;
                                }
                            }
                            return null;
                        };
    
                        /**
                         * Creates an Output message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.SendOrder.Output} Output
                         */
                        Output.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.SendOrder.Output)
                                return object;
                            var message = new $root.TW.Binance.Proto.SendOrder.Output();
                            if (object.address != null)
                                if (typeof object.address === "string")
                                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                                else if (object.address.length)
                                    message.address = object.address;
                            if (object.coins) {
                                if (!Array.isArray(object.coins))
                                    throw TypeError(".TW.Binance.Proto.SendOrder.Output.coins: array expected");
                                message.coins = [];
                                for (var i = 0; i < object.coins.length; ++i) {
                                    if (typeof object.coins[i] !== "object")
                                        throw TypeError(".TW.Binance.Proto.SendOrder.Output.coins: object expected");
                                    message.coins[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.coins[i]);
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an Output message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.Output} message Output
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Output.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.coins = [];
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.address = "";
                                else {
                                    object.address = [];
                                    if (options.bytes !== Array)
                                        object.address = $util.newBuffer(object.address);
                                }
                            if (message.address != null && message.hasOwnProperty("address"))
                                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                            if (message.coins && message.coins.length) {
                                object.coins = [];
                                for (var j = 0; j < message.coins.length; ++j)
                                    object.coins[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.coins[j], options);
                            }
                            return object;
                        };
    
                        /**
                         * Converts this Output to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Output.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Output;
                    })();
    
                    return SendOrder;
                })();
    
                Proto.TokenIssueOrder = (function() {
    
                    /**
                     * Properties of a TokenIssueOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITokenIssueOrder
                     * @property {Uint8Array|null} [from] TokenIssueOrder from
                     * @property {string|null} [name] TokenIssueOrder name
                     * @property {string|null} [symbol] TokenIssueOrder symbol
                     * @property {Long|null} [totalSupply] TokenIssueOrder totalSupply
                     * @property {boolean|null} [mintable] TokenIssueOrder mintable
                     */
    
                    /**
                     * Constructs a new TokenIssueOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TokenIssueOrder.
                     * @implements ITokenIssueOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITokenIssueOrder=} [properties] Properties to set
                     */
                    function TokenIssueOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenIssueOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @instance
                     */
                    TokenIssueOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TokenIssueOrder name.
                     * @member {string} name
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @instance
                     */
                    TokenIssueOrder.prototype.name = "";
    
                    /**
                     * TokenIssueOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @instance
                     */
                    TokenIssueOrder.prototype.symbol = "";
    
                    /**
                     * TokenIssueOrder totalSupply.
                     * @member {Long} totalSupply
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @instance
                     */
                    TokenIssueOrder.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TokenIssueOrder mintable.
                     * @member {boolean} mintable
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @instance
                     */
                    TokenIssueOrder.prototype.mintable = false;
    
                    /**
                     * Creates a new TokenIssueOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenIssueOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TokenIssueOrder} TokenIssueOrder instance
                     */
                    TokenIssueOrder.create = function create(properties) {
                        return new TokenIssueOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TokenIssueOrder message. Does not implicitly {@link TW.Binance.Proto.TokenIssueOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenIssueOrder} message TokenIssueOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenIssueOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.symbol);
                        if (message.totalSupply != null && Object.hasOwnProperty.call(message, "totalSupply"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.totalSupply);
                        if (message.mintable != null && Object.hasOwnProperty.call(message, "mintable"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.mintable);
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenIssueOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TokenIssueOrder} TokenIssueOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenIssueOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TokenIssueOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.name = reader.string();
                                break;
                            case 3:
                                message.symbol = reader.string();
                                break;
                            case 4:
                                message.totalSupply = reader.int64();
                                break;
                            case 5:
                                message.mintable = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenIssueOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenIssueOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.totalSupply != null && message.hasOwnProperty("totalSupply"))
                            if (!$util.isInteger(message.totalSupply) && !(message.totalSupply && $util.isInteger(message.totalSupply.low) && $util.isInteger(message.totalSupply.high)))
                                return "totalSupply: integer|Long expected";
                        if (message.mintable != null && message.hasOwnProperty("mintable"))
                            if (typeof message.mintable !== "boolean")
                                return "mintable: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenIssueOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TokenIssueOrder} TokenIssueOrder
                     */
                    TokenIssueOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TokenIssueOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TokenIssueOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.totalSupply != null)
                            if ($util.Long)
                                (message.totalSupply = $util.Long.fromValue(object.totalSupply)).unsigned = false;
                            else if (typeof object.totalSupply === "string")
                                message.totalSupply = parseInt(object.totalSupply, 10);
                            else if (typeof object.totalSupply === "number")
                                message.totalSupply = object.totalSupply;
                            else if (typeof object.totalSupply === "object")
                                message.totalSupply = new $util.LongBits(object.totalSupply.low >>> 0, object.totalSupply.high >>> 0).toNumber();
                        if (object.mintable != null)
                            message.mintable = Boolean(object.mintable);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenIssueOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @static
                     * @param {TW.Binance.Proto.TokenIssueOrder} message TokenIssueOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenIssueOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            object.name = "";
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.totalSupply = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.totalSupply = options.longs === String ? "0" : 0;
                            object.mintable = false;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.totalSupply != null && message.hasOwnProperty("totalSupply"))
                            if (typeof message.totalSupply === "number")
                                object.totalSupply = options.longs === String ? String(message.totalSupply) : message.totalSupply;
                            else
                                object.totalSupply = options.longs === String ? $util.Long.prototype.toString.call(message.totalSupply) : options.longs === Number ? new $util.LongBits(message.totalSupply.low >>> 0, message.totalSupply.high >>> 0).toNumber() : message.totalSupply;
                        if (message.mintable != null && message.hasOwnProperty("mintable"))
                            object.mintable = message.mintable;
                        return object;
                    };
    
                    /**
                     * Converts this TokenIssueOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TokenIssueOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenIssueOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenIssueOrder;
                })();
    
                Proto.TokenMintOrder = (function() {
    
                    /**
                     * Properties of a TokenMintOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITokenMintOrder
                     * @property {Uint8Array|null} [from] TokenMintOrder from
                     * @property {string|null} [symbol] TokenMintOrder symbol
                     * @property {Long|null} [amount] TokenMintOrder amount
                     */
    
                    /**
                     * Constructs a new TokenMintOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TokenMintOrder.
                     * @implements ITokenMintOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITokenMintOrder=} [properties] Properties to set
                     */
                    function TokenMintOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenMintOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @instance
                     */
                    TokenMintOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TokenMintOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @instance
                     */
                    TokenMintOrder.prototype.symbol = "";
    
                    /**
                     * TokenMintOrder amount.
                     * @member {Long} amount
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @instance
                     */
                    TokenMintOrder.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TokenMintOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenMintOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TokenMintOrder} TokenMintOrder instance
                     */
                    TokenMintOrder.create = function create(properties) {
                        return new TokenMintOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TokenMintOrder message. Does not implicitly {@link TW.Binance.Proto.TokenMintOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenMintOrder} message TokenMintOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenMintOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenMintOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TokenMintOrder} TokenMintOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenMintOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TokenMintOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenMintOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenMintOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenMintOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TokenMintOrder} TokenMintOrder
                     */
                    TokenMintOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TokenMintOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TokenMintOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenMintOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @static
                     * @param {TW.Binance.Proto.TokenMintOrder} message TokenMintOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenMintOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TokenMintOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TokenMintOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenMintOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenMintOrder;
                })();
    
                Proto.TokenBurnOrder = (function() {
    
                    /**
                     * Properties of a TokenBurnOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITokenBurnOrder
                     * @property {Uint8Array|null} [from] TokenBurnOrder from
                     * @property {string|null} [symbol] TokenBurnOrder symbol
                     * @property {Long|null} [amount] TokenBurnOrder amount
                     */
    
                    /**
                     * Constructs a new TokenBurnOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TokenBurnOrder.
                     * @implements ITokenBurnOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITokenBurnOrder=} [properties] Properties to set
                     */
                    function TokenBurnOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenBurnOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @instance
                     */
                    TokenBurnOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TokenBurnOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @instance
                     */
                    TokenBurnOrder.prototype.symbol = "";
    
                    /**
                     * TokenBurnOrder amount.
                     * @member {Long} amount
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @instance
                     */
                    TokenBurnOrder.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TokenBurnOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenBurnOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TokenBurnOrder} TokenBurnOrder instance
                     */
                    TokenBurnOrder.create = function create(properties) {
                        return new TokenBurnOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TokenBurnOrder message. Does not implicitly {@link TW.Binance.Proto.TokenBurnOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenBurnOrder} message TokenBurnOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenBurnOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenBurnOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TokenBurnOrder} TokenBurnOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenBurnOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TokenBurnOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenBurnOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenBurnOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenBurnOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TokenBurnOrder} TokenBurnOrder
                     */
                    TokenBurnOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TokenBurnOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TokenBurnOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenBurnOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @static
                     * @param {TW.Binance.Proto.TokenBurnOrder} message TokenBurnOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenBurnOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TokenBurnOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TokenBurnOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenBurnOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenBurnOrder;
                })();
    
                Proto.TokenFreezeOrder = (function() {
    
                    /**
                     * Properties of a TokenFreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITokenFreezeOrder
                     * @property {Uint8Array|null} [from] TokenFreezeOrder from
                     * @property {string|null} [symbol] TokenFreezeOrder symbol
                     * @property {Long|null} [amount] TokenFreezeOrder amount
                     */
    
                    /**
                     * Constructs a new TokenFreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TokenFreezeOrder.
                     * @implements ITokenFreezeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITokenFreezeOrder=} [properties] Properties to set
                     */
                    function TokenFreezeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenFreezeOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     */
                    TokenFreezeOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TokenFreezeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     */
                    TokenFreezeOrder.prototype.symbol = "";
    
                    /**
                     * TokenFreezeOrder amount.
                     * @member {Long} amount
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     */
                    TokenFreezeOrder.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TokenFreezeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenFreezeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TokenFreezeOrder} TokenFreezeOrder instance
                     */
                    TokenFreezeOrder.create = function create(properties) {
                        return new TokenFreezeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TokenFreezeOrder message. Does not implicitly {@link TW.Binance.Proto.TokenFreezeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenFreezeOrder} message TokenFreezeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenFreezeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenFreezeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TokenFreezeOrder} TokenFreezeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenFreezeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TokenFreezeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenFreezeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenFreezeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenFreezeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TokenFreezeOrder} TokenFreezeOrder
                     */
                    TokenFreezeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TokenFreezeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TokenFreezeOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenFreezeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.TokenFreezeOrder} message TokenFreezeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenFreezeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TokenFreezeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenFreezeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenFreezeOrder;
                })();
    
                Proto.TokenUnfreezeOrder = (function() {
    
                    /**
                     * Properties of a TokenUnfreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITokenUnfreezeOrder
                     * @property {Uint8Array|null} [from] TokenUnfreezeOrder from
                     * @property {string|null} [symbol] TokenUnfreezeOrder symbol
                     * @property {Long|null} [amount] TokenUnfreezeOrder amount
                     */
    
                    /**
                     * Constructs a new TokenUnfreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TokenUnfreezeOrder.
                     * @implements ITokenUnfreezeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITokenUnfreezeOrder=} [properties] Properties to set
                     */
                    function TokenUnfreezeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenUnfreezeOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     */
                    TokenUnfreezeOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TokenUnfreezeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     */
                    TokenUnfreezeOrder.prototype.symbol = "";
    
                    /**
                     * TokenUnfreezeOrder amount.
                     * @member {Long} amount
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     */
                    TokenUnfreezeOrder.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TokenUnfreezeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenUnfreezeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TokenUnfreezeOrder} TokenUnfreezeOrder instance
                     */
                    TokenUnfreezeOrder.create = function create(properties) {
                        return new TokenUnfreezeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TokenUnfreezeOrder message. Does not implicitly {@link TW.Binance.Proto.TokenUnfreezeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenUnfreezeOrder} message TokenUnfreezeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenUnfreezeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenUnfreezeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TokenUnfreezeOrder} TokenUnfreezeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenUnfreezeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TokenUnfreezeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenUnfreezeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenUnfreezeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenUnfreezeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TokenUnfreezeOrder} TokenUnfreezeOrder
                     */
                    TokenUnfreezeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TokenUnfreezeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TokenUnfreezeOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenUnfreezeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.TokenUnfreezeOrder} message TokenUnfreezeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenUnfreezeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TokenUnfreezeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenUnfreezeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenUnfreezeOrder;
                })();
    
                Proto.HTLTOrder = (function() {
    
                    /**
                     * Properties of a HTLTOrder.
                     * @memberof TW.Binance.Proto
                     * @interface IHTLTOrder
                     * @property {Uint8Array|null} [from] HTLTOrder from
                     * @property {Uint8Array|null} [to] HTLTOrder to
                     * @property {string|null} [recipientOtherChain] HTLTOrder recipientOtherChain
                     * @property {string|null} [senderOtherChain] HTLTOrder senderOtherChain
                     * @property {Uint8Array|null} [randomNumberHash] HTLTOrder randomNumberHash
                     * @property {Long|null} [timestamp] HTLTOrder timestamp
                     * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [amount] HTLTOrder amount
                     * @property {string|null} [expectedIncome] HTLTOrder expectedIncome
                     * @property {Long|null} [heightSpan] HTLTOrder heightSpan
                     * @property {boolean|null} [crossChain] HTLTOrder crossChain
                     */
    
                    /**
                     * Constructs a new HTLTOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a HTLTOrder.
                     * @implements IHTLTOrder
                     * @constructor
                     * @param {TW.Binance.Proto.IHTLTOrder=} [properties] Properties to set
                     */
                    function HTLTOrder(properties) {
                        this.amount = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * HTLTOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * HTLTOrder to.
                     * @member {Uint8Array} to
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.to = $util.newBuffer([]);
    
                    /**
                     * HTLTOrder recipientOtherChain.
                     * @member {string} recipientOtherChain
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.recipientOtherChain = "";
    
                    /**
                     * HTLTOrder senderOtherChain.
                     * @member {string} senderOtherChain
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.senderOtherChain = "";
    
                    /**
                     * HTLTOrder randomNumberHash.
                     * @member {Uint8Array} randomNumberHash
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.randomNumberHash = $util.newBuffer([]);
    
                    /**
                     * HTLTOrder timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * HTLTOrder amount.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} amount
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.amount = $util.emptyArray;
    
                    /**
                     * HTLTOrder expectedIncome.
                     * @member {string} expectedIncome
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.expectedIncome = "";
    
                    /**
                     * HTLTOrder heightSpan.
                     * @member {Long} heightSpan
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.heightSpan = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * HTLTOrder crossChain.
                     * @member {boolean} crossChain
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     */
                    HTLTOrder.prototype.crossChain = false;
    
                    /**
                     * Creates a new HTLTOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.IHTLTOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.HTLTOrder} HTLTOrder instance
                     */
                    HTLTOrder.create = function create(properties) {
                        return new HTLTOrder(properties);
                    };
    
                    /**
                     * Encodes the specified HTLTOrder message. Does not implicitly {@link TW.Binance.Proto.HTLTOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.IHTLTOrder} message HTLTOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HTLTOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to);
                        if (message.recipientOtherChain != null && Object.hasOwnProperty.call(message, "recipientOtherChain"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipientOtherChain);
                        if (message.senderOtherChain != null && Object.hasOwnProperty.call(message, "senderOtherChain"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.senderOtherChain);
                        if (message.randomNumberHash != null && Object.hasOwnProperty.call(message, "randomNumberHash"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.randomNumberHash);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
                        if (message.amount != null && message.amount.length)
                            for (var i = 0; i < message.amount.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Token.encode(message.amount[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.expectedIncome != null && Object.hasOwnProperty.call(message, "expectedIncome"))
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.expectedIncome);
                        if (message.heightSpan != null && Object.hasOwnProperty.call(message, "heightSpan"))
                            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.heightSpan);
                        if (message.crossChain != null && Object.hasOwnProperty.call(message, "crossChain"))
                            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.crossChain);
                        return writer;
                    };
    
                    /**
                     * Decodes a HTLTOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.HTLTOrder} HTLTOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HTLTOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.HTLTOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.to = reader.bytes();
                                break;
                            case 3:
                                message.recipientOtherChain = reader.string();
                                break;
                            case 4:
                                message.senderOtherChain = reader.string();
                                break;
                            case 5:
                                message.randomNumberHash = reader.bytes();
                                break;
                            case 6:
                                message.timestamp = reader.int64();
                                break;
                            case 7:
                                if (!(message.amount && message.amount.length))
                                    message.amount = [];
                                message.amount.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                break;
                            case 8:
                                message.expectedIncome = reader.string();
                                break;
                            case 9:
                                message.heightSpan = reader.int64();
                                break;
                            case 10:
                                message.crossChain = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a HTLTOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    HTLTOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.recipientOtherChain != null && message.hasOwnProperty("recipientOtherChain"))
                            if (!$util.isString(message.recipientOtherChain))
                                return "recipientOtherChain: string expected";
                        if (message.senderOtherChain != null && message.hasOwnProperty("senderOtherChain"))
                            if (!$util.isString(message.senderOtherChain))
                                return "senderOtherChain: string expected";
                        if (message.randomNumberHash != null && message.hasOwnProperty("randomNumberHash"))
                            if (!(message.randomNumberHash && typeof message.randomNumberHash.length === "number" || $util.isString(message.randomNumberHash)))
                                return "randomNumberHash: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            if (!Array.isArray(message.amount))
                                return "amount: array expected";
                            for (var i = 0; i < message.amount.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.amount[i]);
                                if (error)
                                    return "amount." + error;
                            }
                        }
                        if (message.expectedIncome != null && message.hasOwnProperty("expectedIncome"))
                            if (!$util.isString(message.expectedIncome))
                                return "expectedIncome: string expected";
                        if (message.heightSpan != null && message.hasOwnProperty("heightSpan"))
                            if (!$util.isInteger(message.heightSpan) && !(message.heightSpan && $util.isInteger(message.heightSpan.low) && $util.isInteger(message.heightSpan.high)))
                                return "heightSpan: integer|Long expected";
                        if (message.crossChain != null && message.hasOwnProperty("crossChain"))
                            if (typeof message.crossChain !== "boolean")
                                return "crossChain: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a HTLTOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.HTLTOrder} HTLTOrder
                     */
                    HTLTOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.HTLTOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.HTLTOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.recipientOtherChain != null)
                            message.recipientOtherChain = String(object.recipientOtherChain);
                        if (object.senderOtherChain != null)
                            message.senderOtherChain = String(object.senderOtherChain);
                        if (object.randomNumberHash != null)
                            if (typeof object.randomNumberHash === "string")
                                $util.base64.decode(object.randomNumberHash, message.randomNumberHash = $util.newBuffer($util.base64.length(object.randomNumberHash)), 0);
                            else if (object.randomNumberHash.length)
                                message.randomNumberHash = object.randomNumberHash;
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.amount) {
                            if (!Array.isArray(object.amount))
                                throw TypeError(".TW.Binance.Proto.HTLTOrder.amount: array expected");
                            message.amount = [];
                            for (var i = 0; i < object.amount.length; ++i) {
                                if (typeof object.amount[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.HTLTOrder.amount: object expected");
                                message.amount[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.amount[i]);
                            }
                        }
                        if (object.expectedIncome != null)
                            message.expectedIncome = String(object.expectedIncome);
                        if (object.heightSpan != null)
                            if ($util.Long)
                                (message.heightSpan = $util.Long.fromValue(object.heightSpan)).unsigned = false;
                            else if (typeof object.heightSpan === "string")
                                message.heightSpan = parseInt(object.heightSpan, 10);
                            else if (typeof object.heightSpan === "number")
                                message.heightSpan = object.heightSpan;
                            else if (typeof object.heightSpan === "object")
                                message.heightSpan = new $util.LongBits(object.heightSpan.low >>> 0, object.heightSpan.high >>> 0).toNumber();
                        if (object.crossChain != null)
                            message.crossChain = Boolean(object.crossChain);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a HTLTOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.HTLTOrder} message HTLTOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HTLTOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amount = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            object.recipientOtherChain = "";
                            object.senderOtherChain = "";
                            if (options.bytes === String)
                                object.randomNumberHash = "";
                            else {
                                object.randomNumberHash = [];
                                if (options.bytes !== Array)
                                    object.randomNumberHash = $util.newBuffer(object.randomNumberHash);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            object.expectedIncome = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.heightSpan = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.heightSpan = options.longs === String ? "0" : 0;
                            object.crossChain = false;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.recipientOtherChain != null && message.hasOwnProperty("recipientOtherChain"))
                            object.recipientOtherChain = message.recipientOtherChain;
                        if (message.senderOtherChain != null && message.hasOwnProperty("senderOtherChain"))
                            object.senderOtherChain = message.senderOtherChain;
                        if (message.randomNumberHash != null && message.hasOwnProperty("randomNumberHash"))
                            object.randomNumberHash = options.bytes === String ? $util.base64.encode(message.randomNumberHash, 0, message.randomNumberHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.randomNumberHash) : message.randomNumberHash;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.amount && message.amount.length) {
                            object.amount = [];
                            for (var j = 0; j < message.amount.length; ++j)
                                object.amount[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.amount[j], options);
                        }
                        if (message.expectedIncome != null && message.hasOwnProperty("expectedIncome"))
                            object.expectedIncome = message.expectedIncome;
                        if (message.heightSpan != null && message.hasOwnProperty("heightSpan"))
                            if (typeof message.heightSpan === "number")
                                object.heightSpan = options.longs === String ? String(message.heightSpan) : message.heightSpan;
                            else
                                object.heightSpan = options.longs === String ? $util.Long.prototype.toString.call(message.heightSpan) : options.longs === Number ? new $util.LongBits(message.heightSpan.low >>> 0, message.heightSpan.high >>> 0).toNumber() : message.heightSpan;
                        if (message.crossChain != null && message.hasOwnProperty("crossChain"))
                            object.crossChain = message.crossChain;
                        return object;
                    };
    
                    /**
                     * Converts this HTLTOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.HTLTOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    HTLTOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return HTLTOrder;
                })();
    
                Proto.DepositHTLTOrder = (function() {
    
                    /**
                     * Properties of a DepositHTLTOrder.
                     * @memberof TW.Binance.Proto
                     * @interface IDepositHTLTOrder
                     * @property {Uint8Array|null} [from] DepositHTLTOrder from
                     * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [amount] DepositHTLTOrder amount
                     * @property {Uint8Array|null} [swapId] DepositHTLTOrder swapId
                     */
    
                    /**
                     * Constructs a new DepositHTLTOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a DepositHTLTOrder.
                     * @implements IDepositHTLTOrder
                     * @constructor
                     * @param {TW.Binance.Proto.IDepositHTLTOrder=} [properties] Properties to set
                     */
                    function DepositHTLTOrder(properties) {
                        this.amount = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DepositHTLTOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @instance
                     */
                    DepositHTLTOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * DepositHTLTOrder amount.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} amount
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @instance
                     */
                    DepositHTLTOrder.prototype.amount = $util.emptyArray;
    
                    /**
                     * DepositHTLTOrder swapId.
                     * @member {Uint8Array} swapId
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @instance
                     */
                    DepositHTLTOrder.prototype.swapId = $util.newBuffer([]);
    
                    /**
                     * Creates a new DepositHTLTOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.IDepositHTLTOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.DepositHTLTOrder} DepositHTLTOrder instance
                     */
                    DepositHTLTOrder.create = function create(properties) {
                        return new DepositHTLTOrder(properties);
                    };
    
                    /**
                     * Encodes the specified DepositHTLTOrder message. Does not implicitly {@link TW.Binance.Proto.DepositHTLTOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.IDepositHTLTOrder} message DepositHTLTOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DepositHTLTOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.amount != null && message.amount.length)
                            for (var i = 0; i < message.amount.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Token.encode(message.amount[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.swapId);
                        return writer;
                    };
    
                    /**
                     * Decodes a DepositHTLTOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.DepositHTLTOrder} DepositHTLTOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DepositHTLTOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.DepositHTLTOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                if (!(message.amount && message.amount.length))
                                    message.amount = [];
                                message.amount.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.swapId = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DepositHTLTOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DepositHTLTOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            if (!Array.isArray(message.amount))
                                return "amount: array expected";
                            for (var i = 0; i < message.amount.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.amount[i]);
                                if (error)
                                    return "amount." + error;
                            }
                        }
                        if (message.swapId != null && message.hasOwnProperty("swapId"))
                            if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                                return "swapId: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a DepositHTLTOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.DepositHTLTOrder} DepositHTLTOrder
                     */
                    DepositHTLTOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.DepositHTLTOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.DepositHTLTOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.amount) {
                            if (!Array.isArray(object.amount))
                                throw TypeError(".TW.Binance.Proto.DepositHTLTOrder.amount: array expected");
                            message.amount = [];
                            for (var i = 0; i < object.amount.length; ++i) {
                                if (typeof object.amount[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.DepositHTLTOrder.amount: object expected");
                                message.amount[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.amount[i]);
                            }
                        }
                        if (object.swapId != null)
                            if (typeof object.swapId === "string")
                                $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                            else if (object.swapId.length)
                                message.swapId = object.swapId;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DepositHTLTOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.DepositHTLTOrder} message DepositHTLTOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DepositHTLTOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amount = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.swapId = "";
                            else {
                                object.swapId = [];
                                if (options.bytes !== Array)
                                    object.swapId = $util.newBuffer(object.swapId);
                            }
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.amount && message.amount.length) {
                            object.amount = [];
                            for (var j = 0; j < message.amount.length; ++j)
                                object.amount[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.amount[j], options);
                        }
                        if (message.swapId != null && message.hasOwnProperty("swapId"))
                            object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
                        return object;
                    };
    
                    /**
                     * Converts this DepositHTLTOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.DepositHTLTOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DepositHTLTOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DepositHTLTOrder;
                })();
    
                Proto.ClaimHTLOrder = (function() {
    
                    /**
                     * Properties of a ClaimHTLOrder.
                     * @memberof TW.Binance.Proto
                     * @interface IClaimHTLOrder
                     * @property {Uint8Array|null} [from] ClaimHTLOrder from
                     * @property {Uint8Array|null} [swapId] ClaimHTLOrder swapId
                     * @property {Uint8Array|null} [randomNumber] ClaimHTLOrder randomNumber
                     */
    
                    /**
                     * Constructs a new ClaimHTLOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a ClaimHTLOrder.
                     * @implements IClaimHTLOrder
                     * @constructor
                     * @param {TW.Binance.Proto.IClaimHTLOrder=} [properties] Properties to set
                     */
                    function ClaimHTLOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ClaimHTLOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @instance
                     */
                    ClaimHTLOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * ClaimHTLOrder swapId.
                     * @member {Uint8Array} swapId
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @instance
                     */
                    ClaimHTLOrder.prototype.swapId = $util.newBuffer([]);
    
                    /**
                     * ClaimHTLOrder randomNumber.
                     * @member {Uint8Array} randomNumber
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @instance
                     */
                    ClaimHTLOrder.prototype.randomNumber = $util.newBuffer([]);
    
                    /**
                     * Creates a new ClaimHTLOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @static
                     * @param {TW.Binance.Proto.IClaimHTLOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.ClaimHTLOrder} ClaimHTLOrder instance
                     */
                    ClaimHTLOrder.create = function create(properties) {
                        return new ClaimHTLOrder(properties);
                    };
    
                    /**
                     * Encodes the specified ClaimHTLOrder message. Does not implicitly {@link TW.Binance.Proto.ClaimHTLOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @static
                     * @param {TW.Binance.Proto.IClaimHTLOrder} message ClaimHTLOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClaimHTLOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.swapId);
                        if (message.randomNumber != null && Object.hasOwnProperty.call(message, "randomNumber"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.randomNumber);
                        return writer;
                    };
    
                    /**
                     * Decodes a ClaimHTLOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.ClaimHTLOrder} ClaimHTLOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClaimHTLOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.ClaimHTLOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.swapId = reader.bytes();
                                break;
                            case 3:
                                message.randomNumber = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a ClaimHTLOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClaimHTLOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.swapId != null && message.hasOwnProperty("swapId"))
                            if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                                return "swapId: buffer expected";
                        if (message.randomNumber != null && message.hasOwnProperty("randomNumber"))
                            if (!(message.randomNumber && typeof message.randomNumber.length === "number" || $util.isString(message.randomNumber)))
                                return "randomNumber: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a ClaimHTLOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.ClaimHTLOrder} ClaimHTLOrder
                     */
                    ClaimHTLOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.ClaimHTLOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.ClaimHTLOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.swapId != null)
                            if (typeof object.swapId === "string")
                                $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                            else if (object.swapId.length)
                                message.swapId = object.swapId;
                        if (object.randomNumber != null)
                            if (typeof object.randomNumber === "string")
                                $util.base64.decode(object.randomNumber, message.randomNumber = $util.newBuffer($util.base64.length(object.randomNumber)), 0);
                            else if (object.randomNumber.length)
                                message.randomNumber = object.randomNumber;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ClaimHTLOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @static
                     * @param {TW.Binance.Proto.ClaimHTLOrder} message ClaimHTLOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClaimHTLOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.swapId = "";
                            else {
                                object.swapId = [];
                                if (options.bytes !== Array)
                                    object.swapId = $util.newBuffer(object.swapId);
                            }
                            if (options.bytes === String)
                                object.randomNumber = "";
                            else {
                                object.randomNumber = [];
                                if (options.bytes !== Array)
                                    object.randomNumber = $util.newBuffer(object.randomNumber);
                            }
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.swapId != null && message.hasOwnProperty("swapId"))
                            object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
                        if (message.randomNumber != null && message.hasOwnProperty("randomNumber"))
                            object.randomNumber = options.bytes === String ? $util.base64.encode(message.randomNumber, 0, message.randomNumber.length) : options.bytes === Array ? Array.prototype.slice.call(message.randomNumber) : message.randomNumber;
                        return object;
                    };
    
                    /**
                     * Converts this ClaimHTLOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.ClaimHTLOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClaimHTLOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ClaimHTLOrder;
                })();
    
                Proto.RefundHTLTOrder = (function() {
    
                    /**
                     * Properties of a RefundHTLTOrder.
                     * @memberof TW.Binance.Proto
                     * @interface IRefundHTLTOrder
                     * @property {Uint8Array|null} [from] RefundHTLTOrder from
                     * @property {Uint8Array|null} [swapId] RefundHTLTOrder swapId
                     */
    
                    /**
                     * Constructs a new RefundHTLTOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a RefundHTLTOrder.
                     * @implements IRefundHTLTOrder
                     * @constructor
                     * @param {TW.Binance.Proto.IRefundHTLTOrder=} [properties] Properties to set
                     */
                    function RefundHTLTOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RefundHTLTOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @instance
                     */
                    RefundHTLTOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * RefundHTLTOrder swapId.
                     * @member {Uint8Array} swapId
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @instance
                     */
                    RefundHTLTOrder.prototype.swapId = $util.newBuffer([]);
    
                    /**
                     * Creates a new RefundHTLTOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.IRefundHTLTOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.RefundHTLTOrder} RefundHTLTOrder instance
                     */
                    RefundHTLTOrder.create = function create(properties) {
                        return new RefundHTLTOrder(properties);
                    };
    
                    /**
                     * Encodes the specified RefundHTLTOrder message. Does not implicitly {@link TW.Binance.Proto.RefundHTLTOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.IRefundHTLTOrder} message RefundHTLTOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RefundHTLTOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.swapId);
                        return writer;
                    };
    
                    /**
                     * Decodes a RefundHTLTOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.RefundHTLTOrder} RefundHTLTOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RefundHTLTOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.RefundHTLTOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.swapId = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a RefundHTLTOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RefundHTLTOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.swapId != null && message.hasOwnProperty("swapId"))
                            if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                                return "swapId: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a RefundHTLTOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.RefundHTLTOrder} RefundHTLTOrder
                     */
                    RefundHTLTOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.RefundHTLTOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.RefundHTLTOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.swapId != null)
                            if (typeof object.swapId === "string")
                                $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                            else if (object.swapId.length)
                                message.swapId = object.swapId;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a RefundHTLTOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @static
                     * @param {TW.Binance.Proto.RefundHTLTOrder} message RefundHTLTOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RefundHTLTOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.swapId = "";
                            else {
                                object.swapId = [];
                                if (options.bytes !== Array)
                                    object.swapId = $util.newBuffer(object.swapId);
                            }
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.swapId != null && message.hasOwnProperty("swapId"))
                            object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
                        return object;
                    };
    
                    /**
                     * Converts this RefundHTLTOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.RefundHTLTOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RefundHTLTOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return RefundHTLTOrder;
                })();
    
                Proto.TransferOut = (function() {
    
                    /**
                     * Properties of a TransferOut.
                     * @memberof TW.Binance.Proto
                     * @interface ITransferOut
                     * @property {Uint8Array|null} [from] TransferOut from
                     * @property {Uint8Array|null} [to] TransferOut to
                     * @property {TW.Binance.Proto.SendOrder.IToken|null} [amount] TransferOut amount
                     * @property {Long|null} [expireTime] TransferOut expireTime
                     */
    
                    /**
                     * Constructs a new TransferOut.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TransferOut.
                     * @implements ITransferOut
                     * @constructor
                     * @param {TW.Binance.Proto.ITransferOut=} [properties] Properties to set
                     */
                    function TransferOut(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferOut from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TransferOut
                     * @instance
                     */
                    TransferOut.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TransferOut to.
                     * @member {Uint8Array} to
                     * @memberof TW.Binance.Proto.TransferOut
                     * @instance
                     */
                    TransferOut.prototype.to = $util.newBuffer([]);
    
                    /**
                     * TransferOut amount.
                     * @member {TW.Binance.Proto.SendOrder.IToken|null|undefined} amount
                     * @memberof TW.Binance.Proto.TransferOut
                     * @instance
                     */
                    TransferOut.prototype.amount = null;
    
                    /**
                     * TransferOut expireTime.
                     * @member {Long} expireTime
                     * @memberof TW.Binance.Proto.TransferOut
                     * @instance
                     */
                    TransferOut.prototype.expireTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TransferOut instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TransferOut
                     * @static
                     * @param {TW.Binance.Proto.ITransferOut=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TransferOut} TransferOut instance
                     */
                    TransferOut.create = function create(properties) {
                        return new TransferOut(properties);
                    };
    
                    /**
                     * Encodes the specified TransferOut message. Does not implicitly {@link TW.Binance.Proto.TransferOut.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TransferOut
                     * @static
                     * @param {TW.Binance.Proto.ITransferOut} message TransferOut message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferOut.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            $root.TW.Binance.Proto.SendOrder.Token.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.expireTime);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransferOut message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TransferOut
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TransferOut} TransferOut
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferOut.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TransferOut();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.to = reader.bytes();
                                break;
                            case 3:
                                message.amount = $root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.expireTime = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransferOut message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TransferOut
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferOut.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.amount);
                            if (error)
                                return "amount." + error;
                        }
                        if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                            if (!$util.isInteger(message.expireTime) && !(message.expireTime && $util.isInteger(message.expireTime.low) && $util.isInteger(message.expireTime.high)))
                                return "expireTime: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferOut message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TransferOut
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TransferOut} TransferOut
                     */
                    TransferOut.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TransferOut)
                            return object;
                        var message = new $root.TW.Binance.Proto.TransferOut();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.amount != null) {
                            if (typeof object.amount !== "object")
                                throw TypeError(".TW.Binance.Proto.TransferOut.amount: object expected");
                            message.amount = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.amount);
                        }
                        if (object.expireTime != null)
                            if ($util.Long)
                                (message.expireTime = $util.Long.fromValue(object.expireTime)).unsigned = false;
                            else if (typeof object.expireTime === "string")
                                message.expireTime = parseInt(object.expireTime, 10);
                            else if (typeof object.expireTime === "number")
                                message.expireTime = object.expireTime;
                            else if (typeof object.expireTime === "object")
                                message.expireTime = new $util.LongBits(object.expireTime.low >>> 0, object.expireTime.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferOut message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TransferOut
                     * @static
                     * @param {TW.Binance.Proto.TransferOut} message TransferOut
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferOut.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            object.amount = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.expireTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.expireTime = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.amount, options);
                        if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                            if (typeof message.expireTime === "number")
                                object.expireTime = options.longs === String ? String(message.expireTime) : message.expireTime;
                            else
                                object.expireTime = options.longs === String ? $util.Long.prototype.toString.call(message.expireTime) : options.longs === Number ? new $util.LongBits(message.expireTime.low >>> 0, message.expireTime.high >>> 0).toNumber() : message.expireTime;
                        return object;
                    };
    
                    /**
                     * Converts this TransferOut to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TransferOut
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferOut.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferOut;
                })();
    
                Proto.SideChainDelegate = (function() {
    
                    /**
                     * Properties of a SideChainDelegate.
                     * @memberof TW.Binance.Proto
                     * @interface ISideChainDelegate
                     * @property {Uint8Array|null} [delegatorAddr] SideChainDelegate delegatorAddr
                     * @property {Uint8Array|null} [validatorAddr] SideChainDelegate validatorAddr
                     * @property {TW.Binance.Proto.SendOrder.IToken|null} [delegation] SideChainDelegate delegation
                     * @property {string|null} [chainId] SideChainDelegate chainId
                     */
    
                    /**
                     * Constructs a new SideChainDelegate.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SideChainDelegate.
                     * @implements ISideChainDelegate
                     * @constructor
                     * @param {TW.Binance.Proto.ISideChainDelegate=} [properties] Properties to set
                     */
                    function SideChainDelegate(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SideChainDelegate delegatorAddr.
                     * @member {Uint8Array} delegatorAddr
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @instance
                     */
                    SideChainDelegate.prototype.delegatorAddr = $util.newBuffer([]);
    
                    /**
                     * SideChainDelegate validatorAddr.
                     * @member {Uint8Array} validatorAddr
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @instance
                     */
                    SideChainDelegate.prototype.validatorAddr = $util.newBuffer([]);
    
                    /**
                     * SideChainDelegate delegation.
                     * @member {TW.Binance.Proto.SendOrder.IToken|null|undefined} delegation
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @instance
                     */
                    SideChainDelegate.prototype.delegation = null;
    
                    /**
                     * SideChainDelegate chainId.
                     * @member {string} chainId
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @instance
                     */
                    SideChainDelegate.prototype.chainId = "";
    
                    /**
                     * Creates a new SideChainDelegate instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @static
                     * @param {TW.Binance.Proto.ISideChainDelegate=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SideChainDelegate} SideChainDelegate instance
                     */
                    SideChainDelegate.create = function create(properties) {
                        return new SideChainDelegate(properties);
                    };
    
                    /**
                     * Encodes the specified SideChainDelegate message. Does not implicitly {@link TW.Binance.Proto.SideChainDelegate.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @static
                     * @param {TW.Binance.Proto.ISideChainDelegate} message SideChainDelegate message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SideChainDelegate.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddr != null && Object.hasOwnProperty.call(message, "delegatorAddr"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.delegatorAddr);
                        if (message.validatorAddr != null && Object.hasOwnProperty.call(message, "validatorAddr"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.validatorAddr);
                        if (message.delegation != null && Object.hasOwnProperty.call(message, "delegation"))
                            $root.TW.Binance.Proto.SendOrder.Token.encode(message.delegation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.chainId);
                        return writer;
                    };
    
                    /**
                     * Decodes a SideChainDelegate message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SideChainDelegate} SideChainDelegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SideChainDelegate.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SideChainDelegate();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddr = reader.bytes();
                                break;
                            case 2:
                                message.validatorAddr = reader.bytes();
                                break;
                            case 3:
                                message.delegation = $root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.chainId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SideChainDelegate message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SideChainDelegate.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddr != null && message.hasOwnProperty("delegatorAddr"))
                            if (!(message.delegatorAddr && typeof message.delegatorAddr.length === "number" || $util.isString(message.delegatorAddr)))
                                return "delegatorAddr: buffer expected";
                        if (message.validatorAddr != null && message.hasOwnProperty("validatorAddr"))
                            if (!(message.validatorAddr && typeof message.validatorAddr.length === "number" || $util.isString(message.validatorAddr)))
                                return "validatorAddr: buffer expected";
                        if (message.delegation != null && message.hasOwnProperty("delegation")) {
                            var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.delegation);
                            if (error)
                                return "delegation." + error;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SideChainDelegate message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SideChainDelegate} SideChainDelegate
                     */
                    SideChainDelegate.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SideChainDelegate)
                            return object;
                        var message = new $root.TW.Binance.Proto.SideChainDelegate();
                        if (object.delegatorAddr != null)
                            if (typeof object.delegatorAddr === "string")
                                $util.base64.decode(object.delegatorAddr, message.delegatorAddr = $util.newBuffer($util.base64.length(object.delegatorAddr)), 0);
                            else if (object.delegatorAddr.length)
                                message.delegatorAddr = object.delegatorAddr;
                        if (object.validatorAddr != null)
                            if (typeof object.validatorAddr === "string")
                                $util.base64.decode(object.validatorAddr, message.validatorAddr = $util.newBuffer($util.base64.length(object.validatorAddr)), 0);
                            else if (object.validatorAddr.length)
                                message.validatorAddr = object.validatorAddr;
                        if (object.delegation != null) {
                            if (typeof object.delegation !== "object")
                                throw TypeError(".TW.Binance.Proto.SideChainDelegate.delegation: object expected");
                            message.delegation = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.delegation);
                        }
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SideChainDelegate message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @static
                     * @param {TW.Binance.Proto.SideChainDelegate} message SideChainDelegate
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SideChainDelegate.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.delegatorAddr = "";
                            else {
                                object.delegatorAddr = [];
                                if (options.bytes !== Array)
                                    object.delegatorAddr = $util.newBuffer(object.delegatorAddr);
                            }
                            if (options.bytes === String)
                                object.validatorAddr = "";
                            else {
                                object.validatorAddr = [];
                                if (options.bytes !== Array)
                                    object.validatorAddr = $util.newBuffer(object.validatorAddr);
                            }
                            object.delegation = null;
                            object.chainId = "";
                        }
                        if (message.delegatorAddr != null && message.hasOwnProperty("delegatorAddr"))
                            object.delegatorAddr = options.bytes === String ? $util.base64.encode(message.delegatorAddr, 0, message.delegatorAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.delegatorAddr) : message.delegatorAddr;
                        if (message.validatorAddr != null && message.hasOwnProperty("validatorAddr"))
                            object.validatorAddr = options.bytes === String ? $util.base64.encode(message.validatorAddr, 0, message.validatorAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorAddr) : message.validatorAddr;
                        if (message.delegation != null && message.hasOwnProperty("delegation"))
                            object.delegation = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.delegation, options);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        return object;
                    };
    
                    /**
                     * Converts this SideChainDelegate to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SideChainDelegate
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SideChainDelegate.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SideChainDelegate;
                })();
    
                Proto.SideChainRedelegate = (function() {
    
                    /**
                     * Properties of a SideChainRedelegate.
                     * @memberof TW.Binance.Proto
                     * @interface ISideChainRedelegate
                     * @property {Uint8Array|null} [delegatorAddr] SideChainRedelegate delegatorAddr
                     * @property {Uint8Array|null} [validatorSrcAddr] SideChainRedelegate validatorSrcAddr
                     * @property {Uint8Array|null} [validatorDstAddr] SideChainRedelegate validatorDstAddr
                     * @property {TW.Binance.Proto.SendOrder.IToken|null} [amount] SideChainRedelegate amount
                     * @property {string|null} [chainId] SideChainRedelegate chainId
                     */
    
                    /**
                     * Constructs a new SideChainRedelegate.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SideChainRedelegate.
                     * @implements ISideChainRedelegate
                     * @constructor
                     * @param {TW.Binance.Proto.ISideChainRedelegate=} [properties] Properties to set
                     */
                    function SideChainRedelegate(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SideChainRedelegate delegatorAddr.
                     * @member {Uint8Array} delegatorAddr
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @instance
                     */
                    SideChainRedelegate.prototype.delegatorAddr = $util.newBuffer([]);
    
                    /**
                     * SideChainRedelegate validatorSrcAddr.
                     * @member {Uint8Array} validatorSrcAddr
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @instance
                     */
                    SideChainRedelegate.prototype.validatorSrcAddr = $util.newBuffer([]);
    
                    /**
                     * SideChainRedelegate validatorDstAddr.
                     * @member {Uint8Array} validatorDstAddr
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @instance
                     */
                    SideChainRedelegate.prototype.validatorDstAddr = $util.newBuffer([]);
    
                    /**
                     * SideChainRedelegate amount.
                     * @member {TW.Binance.Proto.SendOrder.IToken|null|undefined} amount
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @instance
                     */
                    SideChainRedelegate.prototype.amount = null;
    
                    /**
                     * SideChainRedelegate chainId.
                     * @member {string} chainId
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @instance
                     */
                    SideChainRedelegate.prototype.chainId = "";
    
                    /**
                     * Creates a new SideChainRedelegate instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @static
                     * @param {TW.Binance.Proto.ISideChainRedelegate=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SideChainRedelegate} SideChainRedelegate instance
                     */
                    SideChainRedelegate.create = function create(properties) {
                        return new SideChainRedelegate(properties);
                    };
    
                    /**
                     * Encodes the specified SideChainRedelegate message. Does not implicitly {@link TW.Binance.Proto.SideChainRedelegate.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @static
                     * @param {TW.Binance.Proto.ISideChainRedelegate} message SideChainRedelegate message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SideChainRedelegate.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddr != null && Object.hasOwnProperty.call(message, "delegatorAddr"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.delegatorAddr);
                        if (message.validatorSrcAddr != null && Object.hasOwnProperty.call(message, "validatorSrcAddr"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.validatorSrcAddr);
                        if (message.validatorDstAddr != null && Object.hasOwnProperty.call(message, "validatorDstAddr"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.validatorDstAddr);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            $root.TW.Binance.Proto.SendOrder.Token.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.chainId);
                        return writer;
                    };
    
                    /**
                     * Decodes a SideChainRedelegate message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SideChainRedelegate} SideChainRedelegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SideChainRedelegate.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SideChainRedelegate();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddr = reader.bytes();
                                break;
                            case 2:
                                message.validatorSrcAddr = reader.bytes();
                                break;
                            case 3:
                                message.validatorDstAddr = reader.bytes();
                                break;
                            case 4:
                                message.amount = $root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.chainId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SideChainRedelegate message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SideChainRedelegate.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddr != null && message.hasOwnProperty("delegatorAddr"))
                            if (!(message.delegatorAddr && typeof message.delegatorAddr.length === "number" || $util.isString(message.delegatorAddr)))
                                return "delegatorAddr: buffer expected";
                        if (message.validatorSrcAddr != null && message.hasOwnProperty("validatorSrcAddr"))
                            if (!(message.validatorSrcAddr && typeof message.validatorSrcAddr.length === "number" || $util.isString(message.validatorSrcAddr)))
                                return "validatorSrcAddr: buffer expected";
                        if (message.validatorDstAddr != null && message.hasOwnProperty("validatorDstAddr"))
                            if (!(message.validatorDstAddr && typeof message.validatorDstAddr.length === "number" || $util.isString(message.validatorDstAddr)))
                                return "validatorDstAddr: buffer expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.amount);
                            if (error)
                                return "amount." + error;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SideChainRedelegate message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SideChainRedelegate} SideChainRedelegate
                     */
                    SideChainRedelegate.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SideChainRedelegate)
                            return object;
                        var message = new $root.TW.Binance.Proto.SideChainRedelegate();
                        if (object.delegatorAddr != null)
                            if (typeof object.delegatorAddr === "string")
                                $util.base64.decode(object.delegatorAddr, message.delegatorAddr = $util.newBuffer($util.base64.length(object.delegatorAddr)), 0);
                            else if (object.delegatorAddr.length)
                                message.delegatorAddr = object.delegatorAddr;
                        if (object.validatorSrcAddr != null)
                            if (typeof object.validatorSrcAddr === "string")
                                $util.base64.decode(object.validatorSrcAddr, message.validatorSrcAddr = $util.newBuffer($util.base64.length(object.validatorSrcAddr)), 0);
                            else if (object.validatorSrcAddr.length)
                                message.validatorSrcAddr = object.validatorSrcAddr;
                        if (object.validatorDstAddr != null)
                            if (typeof object.validatorDstAddr === "string")
                                $util.base64.decode(object.validatorDstAddr, message.validatorDstAddr = $util.newBuffer($util.base64.length(object.validatorDstAddr)), 0);
                            else if (object.validatorDstAddr.length)
                                message.validatorDstAddr = object.validatorDstAddr;
                        if (object.amount != null) {
                            if (typeof object.amount !== "object")
                                throw TypeError(".TW.Binance.Proto.SideChainRedelegate.amount: object expected");
                            message.amount = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.amount);
                        }
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SideChainRedelegate message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @static
                     * @param {TW.Binance.Proto.SideChainRedelegate} message SideChainRedelegate
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SideChainRedelegate.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.delegatorAddr = "";
                            else {
                                object.delegatorAddr = [];
                                if (options.bytes !== Array)
                                    object.delegatorAddr = $util.newBuffer(object.delegatorAddr);
                            }
                            if (options.bytes === String)
                                object.validatorSrcAddr = "";
                            else {
                                object.validatorSrcAddr = [];
                                if (options.bytes !== Array)
                                    object.validatorSrcAddr = $util.newBuffer(object.validatorSrcAddr);
                            }
                            if (options.bytes === String)
                                object.validatorDstAddr = "";
                            else {
                                object.validatorDstAddr = [];
                                if (options.bytes !== Array)
                                    object.validatorDstAddr = $util.newBuffer(object.validatorDstAddr);
                            }
                            object.amount = null;
                            object.chainId = "";
                        }
                        if (message.delegatorAddr != null && message.hasOwnProperty("delegatorAddr"))
                            object.delegatorAddr = options.bytes === String ? $util.base64.encode(message.delegatorAddr, 0, message.delegatorAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.delegatorAddr) : message.delegatorAddr;
                        if (message.validatorSrcAddr != null && message.hasOwnProperty("validatorSrcAddr"))
                            object.validatorSrcAddr = options.bytes === String ? $util.base64.encode(message.validatorSrcAddr, 0, message.validatorSrcAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorSrcAddr) : message.validatorSrcAddr;
                        if (message.validatorDstAddr != null && message.hasOwnProperty("validatorDstAddr"))
                            object.validatorDstAddr = options.bytes === String ? $util.base64.encode(message.validatorDstAddr, 0, message.validatorDstAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorDstAddr) : message.validatorDstAddr;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.amount, options);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        return object;
                    };
    
                    /**
                     * Converts this SideChainRedelegate to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SideChainRedelegate
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SideChainRedelegate.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SideChainRedelegate;
                })();
    
                Proto.SideChainUndelegate = (function() {
    
                    /**
                     * Properties of a SideChainUndelegate.
                     * @memberof TW.Binance.Proto
                     * @interface ISideChainUndelegate
                     * @property {Uint8Array|null} [delegatorAddr] SideChainUndelegate delegatorAddr
                     * @property {Uint8Array|null} [validatorAddr] SideChainUndelegate validatorAddr
                     * @property {TW.Binance.Proto.SendOrder.IToken|null} [amount] SideChainUndelegate amount
                     * @property {string|null} [chainId] SideChainUndelegate chainId
                     */
    
                    /**
                     * Constructs a new SideChainUndelegate.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SideChainUndelegate.
                     * @implements ISideChainUndelegate
                     * @constructor
                     * @param {TW.Binance.Proto.ISideChainUndelegate=} [properties] Properties to set
                     */
                    function SideChainUndelegate(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SideChainUndelegate delegatorAddr.
                     * @member {Uint8Array} delegatorAddr
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @instance
                     */
                    SideChainUndelegate.prototype.delegatorAddr = $util.newBuffer([]);
    
                    /**
                     * SideChainUndelegate validatorAddr.
                     * @member {Uint8Array} validatorAddr
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @instance
                     */
                    SideChainUndelegate.prototype.validatorAddr = $util.newBuffer([]);
    
                    /**
                     * SideChainUndelegate amount.
                     * @member {TW.Binance.Proto.SendOrder.IToken|null|undefined} amount
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @instance
                     */
                    SideChainUndelegate.prototype.amount = null;
    
                    /**
                     * SideChainUndelegate chainId.
                     * @member {string} chainId
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @instance
                     */
                    SideChainUndelegate.prototype.chainId = "";
    
                    /**
                     * Creates a new SideChainUndelegate instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @static
                     * @param {TW.Binance.Proto.ISideChainUndelegate=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SideChainUndelegate} SideChainUndelegate instance
                     */
                    SideChainUndelegate.create = function create(properties) {
                        return new SideChainUndelegate(properties);
                    };
    
                    /**
                     * Encodes the specified SideChainUndelegate message. Does not implicitly {@link TW.Binance.Proto.SideChainUndelegate.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @static
                     * @param {TW.Binance.Proto.ISideChainUndelegate} message SideChainUndelegate message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SideChainUndelegate.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddr != null && Object.hasOwnProperty.call(message, "delegatorAddr"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.delegatorAddr);
                        if (message.validatorAddr != null && Object.hasOwnProperty.call(message, "validatorAddr"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.validatorAddr);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            $root.TW.Binance.Proto.SendOrder.Token.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.chainId);
                        return writer;
                    };
    
                    /**
                     * Decodes a SideChainUndelegate message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SideChainUndelegate} SideChainUndelegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SideChainUndelegate.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SideChainUndelegate();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddr = reader.bytes();
                                break;
                            case 2:
                                message.validatorAddr = reader.bytes();
                                break;
                            case 3:
                                message.amount = $root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.chainId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SideChainUndelegate message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SideChainUndelegate.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddr != null && message.hasOwnProperty("delegatorAddr"))
                            if (!(message.delegatorAddr && typeof message.delegatorAddr.length === "number" || $util.isString(message.delegatorAddr)))
                                return "delegatorAddr: buffer expected";
                        if (message.validatorAddr != null && message.hasOwnProperty("validatorAddr"))
                            if (!(message.validatorAddr && typeof message.validatorAddr.length === "number" || $util.isString(message.validatorAddr)))
                                return "validatorAddr: buffer expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.amount);
                            if (error)
                                return "amount." + error;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SideChainUndelegate message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SideChainUndelegate} SideChainUndelegate
                     */
                    SideChainUndelegate.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SideChainUndelegate)
                            return object;
                        var message = new $root.TW.Binance.Proto.SideChainUndelegate();
                        if (object.delegatorAddr != null)
                            if (typeof object.delegatorAddr === "string")
                                $util.base64.decode(object.delegatorAddr, message.delegatorAddr = $util.newBuffer($util.base64.length(object.delegatorAddr)), 0);
                            else if (object.delegatorAddr.length)
                                message.delegatorAddr = object.delegatorAddr;
                        if (object.validatorAddr != null)
                            if (typeof object.validatorAddr === "string")
                                $util.base64.decode(object.validatorAddr, message.validatorAddr = $util.newBuffer($util.base64.length(object.validatorAddr)), 0);
                            else if (object.validatorAddr.length)
                                message.validatorAddr = object.validatorAddr;
                        if (object.amount != null) {
                            if (typeof object.amount !== "object")
                                throw TypeError(".TW.Binance.Proto.SideChainUndelegate.amount: object expected");
                            message.amount = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.amount);
                        }
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SideChainUndelegate message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @static
                     * @param {TW.Binance.Proto.SideChainUndelegate} message SideChainUndelegate
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SideChainUndelegate.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.delegatorAddr = "";
                            else {
                                object.delegatorAddr = [];
                                if (options.bytes !== Array)
                                    object.delegatorAddr = $util.newBuffer(object.delegatorAddr);
                            }
                            if (options.bytes === String)
                                object.validatorAddr = "";
                            else {
                                object.validatorAddr = [];
                                if (options.bytes !== Array)
                                    object.validatorAddr = $util.newBuffer(object.validatorAddr);
                            }
                            object.amount = null;
                            object.chainId = "";
                        }
                        if (message.delegatorAddr != null && message.hasOwnProperty("delegatorAddr"))
                            object.delegatorAddr = options.bytes === String ? $util.base64.encode(message.delegatorAddr, 0, message.delegatorAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.delegatorAddr) : message.delegatorAddr;
                        if (message.validatorAddr != null && message.hasOwnProperty("validatorAddr"))
                            object.validatorAddr = options.bytes === String ? $util.base64.encode(message.validatorAddr, 0, message.validatorAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorAddr) : message.validatorAddr;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.amount, options);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        return object;
                    };
    
                    /**
                     * Converts this SideChainUndelegate to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SideChainUndelegate
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SideChainUndelegate.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SideChainUndelegate;
                })();
    
                Proto.TimeLockOrder = (function() {
    
                    /**
                     * Properties of a TimeLockOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITimeLockOrder
                     * @property {Uint8Array|null} [fromAddress] TimeLockOrder fromAddress
                     * @property {string|null} [description] TimeLockOrder description
                     * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [amount] TimeLockOrder amount
                     * @property {Long|null} [lockTime] TimeLockOrder lockTime
                     */
    
                    /**
                     * Constructs a new TimeLockOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TimeLockOrder.
                     * @implements ITimeLockOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITimeLockOrder=} [properties] Properties to set
                     */
                    function TimeLockOrder(properties) {
                        this.amount = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TimeLockOrder fromAddress.
                     * @member {Uint8Array} fromAddress
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @instance
                     */
                    TimeLockOrder.prototype.fromAddress = $util.newBuffer([]);
    
                    /**
                     * TimeLockOrder description.
                     * @member {string} description
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @instance
                     */
                    TimeLockOrder.prototype.description = "";
    
                    /**
                     * TimeLockOrder amount.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} amount
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @instance
                     */
                    TimeLockOrder.prototype.amount = $util.emptyArray;
    
                    /**
                     * TimeLockOrder lockTime.
                     * @member {Long} lockTime
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @instance
                     */
                    TimeLockOrder.prototype.lockTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TimeLockOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @static
                     * @param {TW.Binance.Proto.ITimeLockOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TimeLockOrder} TimeLockOrder instance
                     */
                    TimeLockOrder.create = function create(properties) {
                        return new TimeLockOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TimeLockOrder message. Does not implicitly {@link TW.Binance.Proto.TimeLockOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @static
                     * @param {TW.Binance.Proto.ITimeLockOrder} message TimeLockOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimeLockOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fromAddress);
                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                        if (message.amount != null && message.amount.length)
                            for (var i = 0; i < message.amount.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Token.encode(message.amount[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.lockTime != null && Object.hasOwnProperty.call(message, "lockTime"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lockTime);
                        return writer;
                    };
    
                    /**
                     * Decodes a TimeLockOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TimeLockOrder} TimeLockOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimeLockOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TimeLockOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.bytes();
                                break;
                            case 2:
                                message.description = reader.string();
                                break;
                            case 3:
                                if (!(message.amount && message.amount.length))
                                    message.amount = [];
                                message.amount.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                message.lockTime = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TimeLockOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TimeLockOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!(message.fromAddress && typeof message.fromAddress.length === "number" || $util.isString(message.fromAddress)))
                                return "fromAddress: buffer expected";
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            if (!Array.isArray(message.amount))
                                return "amount: array expected";
                            for (var i = 0; i < message.amount.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.amount[i]);
                                if (error)
                                    return "amount." + error;
                            }
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime) && !(message.lockTime && $util.isInteger(message.lockTime.low) && $util.isInteger(message.lockTime.high)))
                                return "lockTime: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TimeLockOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TimeLockOrder} TimeLockOrder
                     */
                    TimeLockOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TimeLockOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TimeLockOrder();
                        if (object.fromAddress != null)
                            if (typeof object.fromAddress === "string")
                                $util.base64.decode(object.fromAddress, message.fromAddress = $util.newBuffer($util.base64.length(object.fromAddress)), 0);
                            else if (object.fromAddress.length)
                                message.fromAddress = object.fromAddress;
                        if (object.description != null)
                            message.description = String(object.description);
                        if (object.amount) {
                            if (!Array.isArray(object.amount))
                                throw TypeError(".TW.Binance.Proto.TimeLockOrder.amount: array expected");
                            message.amount = [];
                            for (var i = 0; i < object.amount.length; ++i) {
                                if (typeof object.amount[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.TimeLockOrder.amount: object expected");
                                message.amount[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.amount[i]);
                            }
                        }
                        if (object.lockTime != null)
                            if ($util.Long)
                                (message.lockTime = $util.Long.fromValue(object.lockTime)).unsigned = false;
                            else if (typeof object.lockTime === "string")
                                message.lockTime = parseInt(object.lockTime, 10);
                            else if (typeof object.lockTime === "number")
                                message.lockTime = object.lockTime;
                            else if (typeof object.lockTime === "object")
                                message.lockTime = new $util.LongBits(object.lockTime.low >>> 0, object.lockTime.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TimeLockOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @static
                     * @param {TW.Binance.Proto.TimeLockOrder} message TimeLockOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TimeLockOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amount = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.fromAddress = "";
                            else {
                                object.fromAddress = [];
                                if (options.bytes !== Array)
                                    object.fromAddress = $util.newBuffer(object.fromAddress);
                            }
                            object.description = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.lockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.lockTime = options.longs === String ? "0" : 0;
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = options.bytes === String ? $util.base64.encode(message.fromAddress, 0, message.fromAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAddress) : message.fromAddress;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.amount && message.amount.length) {
                            object.amount = [];
                            for (var j = 0; j < message.amount.length; ++j)
                                object.amount[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.amount[j], options);
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (typeof message.lockTime === "number")
                                object.lockTime = options.longs === String ? String(message.lockTime) : message.lockTime;
                            else
                                object.lockTime = options.longs === String ? $util.Long.prototype.toString.call(message.lockTime) : options.longs === Number ? new $util.LongBits(message.lockTime.low >>> 0, message.lockTime.high >>> 0).toNumber() : message.lockTime;
                        return object;
                    };
    
                    /**
                     * Converts this TimeLockOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TimeLockOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TimeLockOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TimeLockOrder;
                })();
    
                Proto.TimeRelockOrder = (function() {
    
                    /**
                     * Properties of a TimeRelockOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITimeRelockOrder
                     * @property {Uint8Array|null} [fromAddress] TimeRelockOrder fromAddress
                     * @property {Long|null} [id] TimeRelockOrder id
                     * @property {string|null} [description] TimeRelockOrder description
                     * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [amount] TimeRelockOrder amount
                     * @property {Long|null} [lockTime] TimeRelockOrder lockTime
                     */
    
                    /**
                     * Constructs a new TimeRelockOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TimeRelockOrder.
                     * @implements ITimeRelockOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITimeRelockOrder=} [properties] Properties to set
                     */
                    function TimeRelockOrder(properties) {
                        this.amount = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TimeRelockOrder fromAddress.
                     * @member {Uint8Array} fromAddress
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @instance
                     */
                    TimeRelockOrder.prototype.fromAddress = $util.newBuffer([]);
    
                    /**
                     * TimeRelockOrder id.
                     * @member {Long} id
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @instance
                     */
                    TimeRelockOrder.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TimeRelockOrder description.
                     * @member {string} description
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @instance
                     */
                    TimeRelockOrder.prototype.description = "";
    
                    /**
                     * TimeRelockOrder amount.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} amount
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @instance
                     */
                    TimeRelockOrder.prototype.amount = $util.emptyArray;
    
                    /**
                     * TimeRelockOrder lockTime.
                     * @member {Long} lockTime
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @instance
                     */
                    TimeRelockOrder.prototype.lockTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TimeRelockOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @static
                     * @param {TW.Binance.Proto.ITimeRelockOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TimeRelockOrder} TimeRelockOrder instance
                     */
                    TimeRelockOrder.create = function create(properties) {
                        return new TimeRelockOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TimeRelockOrder message. Does not implicitly {@link TW.Binance.Proto.TimeRelockOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @static
                     * @param {TW.Binance.Proto.ITimeRelockOrder} message TimeRelockOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimeRelockOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fromAddress);
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                        if (message.amount != null && message.amount.length)
                            for (var i = 0; i < message.amount.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Token.encode(message.amount[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.lockTime != null && Object.hasOwnProperty.call(message, "lockTime"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.lockTime);
                        return writer;
                    };
    
                    /**
                     * Decodes a TimeRelockOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TimeRelockOrder} TimeRelockOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimeRelockOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TimeRelockOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.bytes();
                                break;
                            case 2:
                                message.id = reader.int64();
                                break;
                            case 3:
                                message.description = reader.string();
                                break;
                            case 4:
                                if (!(message.amount && message.amount.length))
                                    message.amount = [];
                                message.amount.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.lockTime = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TimeRelockOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TimeRelockOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!(message.fromAddress && typeof message.fromAddress.length === "number" || $util.isString(message.fromAddress)))
                                return "fromAddress: buffer expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                                return "id: integer|Long expected";
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            if (!Array.isArray(message.amount))
                                return "amount: array expected";
                            for (var i = 0; i < message.amount.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.amount[i]);
                                if (error)
                                    return "amount." + error;
                            }
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime) && !(message.lockTime && $util.isInteger(message.lockTime.low) && $util.isInteger(message.lockTime.high)))
                                return "lockTime: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TimeRelockOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TimeRelockOrder} TimeRelockOrder
                     */
                    TimeRelockOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TimeRelockOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TimeRelockOrder();
                        if (object.fromAddress != null)
                            if (typeof object.fromAddress === "string")
                                $util.base64.decode(object.fromAddress, message.fromAddress = $util.newBuffer($util.base64.length(object.fromAddress)), 0);
                            else if (object.fromAddress.length)
                                message.fromAddress = object.fromAddress;
                        if (object.id != null)
                            if ($util.Long)
                                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                            else if (typeof object.id === "string")
                                message.id = parseInt(object.id, 10);
                            else if (typeof object.id === "number")
                                message.id = object.id;
                            else if (typeof object.id === "object")
                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                        if (object.description != null)
                            message.description = String(object.description);
                        if (object.amount) {
                            if (!Array.isArray(object.amount))
                                throw TypeError(".TW.Binance.Proto.TimeRelockOrder.amount: array expected");
                            message.amount = [];
                            for (var i = 0; i < object.amount.length; ++i) {
                                if (typeof object.amount[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.TimeRelockOrder.amount: object expected");
                                message.amount[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.amount[i]);
                            }
                        }
                        if (object.lockTime != null)
                            if ($util.Long)
                                (message.lockTime = $util.Long.fromValue(object.lockTime)).unsigned = false;
                            else if (typeof object.lockTime === "string")
                                message.lockTime = parseInt(object.lockTime, 10);
                            else if (typeof object.lockTime === "number")
                                message.lockTime = object.lockTime;
                            else if (typeof object.lockTime === "object")
                                message.lockTime = new $util.LongBits(object.lockTime.low >>> 0, object.lockTime.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TimeRelockOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @static
                     * @param {TW.Binance.Proto.TimeRelockOrder} message TimeRelockOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TimeRelockOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amount = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.fromAddress = "";
                            else {
                                object.fromAddress = [];
                                if (options.bytes !== Array)
                                    object.fromAddress = $util.newBuffer(object.fromAddress);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.id = options.longs === String ? "0" : 0;
                            object.description = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.lockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.lockTime = options.longs === String ? "0" : 0;
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = options.bytes === String ? $util.base64.encode(message.fromAddress, 0, message.fromAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAddress) : message.fromAddress;
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (typeof message.id === "number")
                                object.id = options.longs === String ? String(message.id) : message.id;
                            else
                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.amount && message.amount.length) {
                            object.amount = [];
                            for (var j = 0; j < message.amount.length; ++j)
                                object.amount[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.amount[j], options);
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (typeof message.lockTime === "number")
                                object.lockTime = options.longs === String ? String(message.lockTime) : message.lockTime;
                            else
                                object.lockTime = options.longs === String ? $util.Long.prototype.toString.call(message.lockTime) : options.longs === Number ? new $util.LongBits(message.lockTime.low >>> 0, message.lockTime.high >>> 0).toNumber() : message.lockTime;
                        return object;
                    };
    
                    /**
                     * Converts this TimeRelockOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TimeRelockOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TimeRelockOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TimeRelockOrder;
                })();
    
                Proto.TimeUnlockOrder = (function() {
    
                    /**
                     * Properties of a TimeUnlockOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITimeUnlockOrder
                     * @property {Uint8Array|null} [fromAddress] TimeUnlockOrder fromAddress
                     * @property {Long|null} [id] TimeUnlockOrder id
                     */
    
                    /**
                     * Constructs a new TimeUnlockOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TimeUnlockOrder.
                     * @implements ITimeUnlockOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITimeUnlockOrder=} [properties] Properties to set
                     */
                    function TimeUnlockOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TimeUnlockOrder fromAddress.
                     * @member {Uint8Array} fromAddress
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @instance
                     */
                    TimeUnlockOrder.prototype.fromAddress = $util.newBuffer([]);
    
                    /**
                     * TimeUnlockOrder id.
                     * @member {Long} id
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @instance
                     */
                    TimeUnlockOrder.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TimeUnlockOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @static
                     * @param {TW.Binance.Proto.ITimeUnlockOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TimeUnlockOrder} TimeUnlockOrder instance
                     */
                    TimeUnlockOrder.create = function create(properties) {
                        return new TimeUnlockOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TimeUnlockOrder message. Does not implicitly {@link TW.Binance.Proto.TimeUnlockOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @static
                     * @param {TW.Binance.Proto.ITimeUnlockOrder} message TimeUnlockOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimeUnlockOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fromAddress);
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
                        return writer;
                    };
    
                    /**
                     * Decodes a TimeUnlockOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TimeUnlockOrder} TimeUnlockOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimeUnlockOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TimeUnlockOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.bytes();
                                break;
                            case 2:
                                message.id = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TimeUnlockOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TimeUnlockOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!(message.fromAddress && typeof message.fromAddress.length === "number" || $util.isString(message.fromAddress)))
                                return "fromAddress: buffer expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                                return "id: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TimeUnlockOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TimeUnlockOrder} TimeUnlockOrder
                     */
                    TimeUnlockOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TimeUnlockOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TimeUnlockOrder();
                        if (object.fromAddress != null)
                            if (typeof object.fromAddress === "string")
                                $util.base64.decode(object.fromAddress, message.fromAddress = $util.newBuffer($util.base64.length(object.fromAddress)), 0);
                            else if (object.fromAddress.length)
                                message.fromAddress = object.fromAddress;
                        if (object.id != null)
                            if ($util.Long)
                                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                            else if (typeof object.id === "string")
                                message.id = parseInt(object.id, 10);
                            else if (typeof object.id === "number")
                                message.id = object.id;
                            else if (typeof object.id === "object")
                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TimeUnlockOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @static
                     * @param {TW.Binance.Proto.TimeUnlockOrder} message TimeUnlockOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TimeUnlockOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.fromAddress = "";
                            else {
                                object.fromAddress = [];
                                if (options.bytes !== Array)
                                    object.fromAddress = $util.newBuffer(object.fromAddress);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.id = options.longs === String ? "0" : 0;
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = options.bytes === String ? $util.base64.encode(message.fromAddress, 0, message.fromAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAddress) : message.fromAddress;
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (typeof message.id === "number")
                                object.id = options.longs === String ? String(message.id) : message.id;
                            else
                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                        return object;
                    };
    
                    /**
                     * Converts this TimeUnlockOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TimeUnlockOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TimeUnlockOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TimeUnlockOrder;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Binance.Proto
                     * @interface ISigningInput
                     * @property {string|null} [chainId] SigningInput chainId
                     * @property {Long|null} [accountNumber] SigningInput accountNumber
                     * @property {Long|null} [sequence] SigningInput sequence
                     * @property {Long|null} [source] SigningInput source
                     * @property {string|null} [memo] SigningInput memo
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Binance.Proto.ITradeOrder|null} [tradeOrder] SigningInput tradeOrder
                     * @property {TW.Binance.Proto.ICancelTradeOrder|null} [cancelTradeOrder] SigningInput cancelTradeOrder
                     * @property {TW.Binance.Proto.ISendOrder|null} [sendOrder] SigningInput sendOrder
                     * @property {TW.Binance.Proto.ITokenFreezeOrder|null} [freezeOrder] SigningInput freezeOrder
                     * @property {TW.Binance.Proto.ITokenUnfreezeOrder|null} [unfreezeOrder] SigningInput unfreezeOrder
                     * @property {TW.Binance.Proto.IHTLTOrder|null} [htltOrder] SigningInput htltOrder
                     * @property {TW.Binance.Proto.IDepositHTLTOrder|null} [depositHTLTOrder] SigningInput depositHTLTOrder
                     * @property {TW.Binance.Proto.IClaimHTLOrder|null} [claimHTLTOrder] SigningInput claimHTLTOrder
                     * @property {TW.Binance.Proto.IRefundHTLTOrder|null} [refundHTLTOrder] SigningInput refundHTLTOrder
                     * @property {TW.Binance.Proto.ITokenIssueOrder|null} [issueOrder] SigningInput issueOrder
                     * @property {TW.Binance.Proto.ITokenMintOrder|null} [mintOrder] SigningInput mintOrder
                     * @property {TW.Binance.Proto.ITokenBurnOrder|null} [burnOrder] SigningInput burnOrder
                     * @property {TW.Binance.Proto.ITransferOut|null} [transferOutOrder] SigningInput transferOutOrder
                     * @property {TW.Binance.Proto.ISideChainDelegate|null} [sideDelegateOrder] SigningInput sideDelegateOrder
                     * @property {TW.Binance.Proto.ISideChainRedelegate|null} [sideRedelegateOrder] SigningInput sideRedelegateOrder
                     * @property {TW.Binance.Proto.ISideChainUndelegate|null} [sideUndelegateOrder] SigningInput sideUndelegateOrder
                     * @property {TW.Binance.Proto.ITimeLockOrder|null} [timeLockOrder] SigningInput timeLockOrder
                     * @property {TW.Binance.Proto.ITimeRelockOrder|null} [timeRelockOrder] SigningInput timeRelockOrder
                     * @property {TW.Binance.Proto.ITimeUnlockOrder|null} [timeUnlockOrder] SigningInput timeUnlockOrder
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Binance.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {string} chainId
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * SigningInput accountNumber.
                     * @member {Long} accountNumber
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput sequence.
                     * @member {Long} sequence
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput source.
                     * @member {Long} source
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.source = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput tradeOrder.
                     * @member {TW.Binance.Proto.ITradeOrder|null|undefined} tradeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.tradeOrder = null;
    
                    /**
                     * SigningInput cancelTradeOrder.
                     * @member {TW.Binance.Proto.ICancelTradeOrder|null|undefined} cancelTradeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.cancelTradeOrder = null;
    
                    /**
                     * SigningInput sendOrder.
                     * @member {TW.Binance.Proto.ISendOrder|null|undefined} sendOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sendOrder = null;
    
                    /**
                     * SigningInput freezeOrder.
                     * @member {TW.Binance.Proto.ITokenFreezeOrder|null|undefined} freezeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.freezeOrder = null;
    
                    /**
                     * SigningInput unfreezeOrder.
                     * @member {TW.Binance.Proto.ITokenUnfreezeOrder|null|undefined} unfreezeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.unfreezeOrder = null;
    
                    /**
                     * SigningInput htltOrder.
                     * @member {TW.Binance.Proto.IHTLTOrder|null|undefined} htltOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.htltOrder = null;
    
                    /**
                     * SigningInput depositHTLTOrder.
                     * @member {TW.Binance.Proto.IDepositHTLTOrder|null|undefined} depositHTLTOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.depositHTLTOrder = null;
    
                    /**
                     * SigningInput claimHTLTOrder.
                     * @member {TW.Binance.Proto.IClaimHTLOrder|null|undefined} claimHTLTOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.claimHTLTOrder = null;
    
                    /**
                     * SigningInput refundHTLTOrder.
                     * @member {TW.Binance.Proto.IRefundHTLTOrder|null|undefined} refundHTLTOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.refundHTLTOrder = null;
    
                    /**
                     * SigningInput issueOrder.
                     * @member {TW.Binance.Proto.ITokenIssueOrder|null|undefined} issueOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.issueOrder = null;
    
                    /**
                     * SigningInput mintOrder.
                     * @member {TW.Binance.Proto.ITokenMintOrder|null|undefined} mintOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.mintOrder = null;
    
                    /**
                     * SigningInput burnOrder.
                     * @member {TW.Binance.Proto.ITokenBurnOrder|null|undefined} burnOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.burnOrder = null;
    
                    /**
                     * SigningInput transferOutOrder.
                     * @member {TW.Binance.Proto.ITransferOut|null|undefined} transferOutOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transferOutOrder = null;
    
                    /**
                     * SigningInput sideDelegateOrder.
                     * @member {TW.Binance.Proto.ISideChainDelegate|null|undefined} sideDelegateOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sideDelegateOrder = null;
    
                    /**
                     * SigningInput sideRedelegateOrder.
                     * @member {TW.Binance.Proto.ISideChainRedelegate|null|undefined} sideRedelegateOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sideRedelegateOrder = null;
    
                    /**
                     * SigningInput sideUndelegateOrder.
                     * @member {TW.Binance.Proto.ISideChainUndelegate|null|undefined} sideUndelegateOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sideUndelegateOrder = null;
    
                    /**
                     * SigningInput timeLockOrder.
                     * @member {TW.Binance.Proto.ITimeLockOrder|null|undefined} timeLockOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timeLockOrder = null;
    
                    /**
                     * SigningInput timeRelockOrder.
                     * @member {TW.Binance.Proto.ITimeRelockOrder|null|undefined} timeRelockOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timeRelockOrder = null;
    
                    /**
                     * SigningInput timeUnlockOrder.
                     * @member {TW.Binance.Proto.ITimeUnlockOrder|null|undefined} timeUnlockOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timeUnlockOrder = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput orderOneof.
                     * @member {"tradeOrder"|"cancelTradeOrder"|"sendOrder"|"freezeOrder"|"unfreezeOrder"|"htltOrder"|"depositHTLTOrder"|"claimHTLTOrder"|"refundHTLTOrder"|"issueOrder"|"mintOrder"|"burnOrder"|"transferOutOrder"|"sideDelegateOrder"|"sideRedelegateOrder"|"sideUndelegateOrder"|"timeLockOrder"|"timeRelockOrder"|"timeUnlockOrder"|undefined} orderOneof
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "orderOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["tradeOrder", "cancelTradeOrder", "sendOrder", "freezeOrder", "unfreezeOrder", "htltOrder", "depositHTLTOrder", "claimHTLTOrder", "refundHTLTOrder", "issueOrder", "mintOrder", "burnOrder", "transferOutOrder", "sideDelegateOrder", "sideRedelegateOrder", "sideUndelegateOrder", "timeLockOrder", "timeRelockOrder", "timeUnlockOrder"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {TW.Binance.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Binance.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {TW.Binance.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.chainId);
                        if (message.accountNumber != null && Object.hasOwnProperty.call(message, "accountNumber"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.accountNumber);
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sequence);
                        if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.source);
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        if (message.tradeOrder != null && Object.hasOwnProperty.call(message, "tradeOrder"))
                            $root.TW.Binance.Proto.TradeOrder.encode(message.tradeOrder, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.cancelTradeOrder != null && Object.hasOwnProperty.call(message, "cancelTradeOrder"))
                            $root.TW.Binance.Proto.CancelTradeOrder.encode(message.cancelTradeOrder, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.sendOrder != null && Object.hasOwnProperty.call(message, "sendOrder"))
                            $root.TW.Binance.Proto.SendOrder.encode(message.sendOrder, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.freezeOrder != null && Object.hasOwnProperty.call(message, "freezeOrder"))
                            $root.TW.Binance.Proto.TokenFreezeOrder.encode(message.freezeOrder, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.unfreezeOrder != null && Object.hasOwnProperty.call(message, "unfreezeOrder"))
                            $root.TW.Binance.Proto.TokenUnfreezeOrder.encode(message.unfreezeOrder, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.htltOrder != null && Object.hasOwnProperty.call(message, "htltOrder"))
                            $root.TW.Binance.Proto.HTLTOrder.encode(message.htltOrder, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                        if (message.depositHTLTOrder != null && Object.hasOwnProperty.call(message, "depositHTLTOrder"))
                            $root.TW.Binance.Proto.DepositHTLTOrder.encode(message.depositHTLTOrder, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                        if (message.claimHTLTOrder != null && Object.hasOwnProperty.call(message, "claimHTLTOrder"))
                            $root.TW.Binance.Proto.ClaimHTLOrder.encode(message.claimHTLTOrder, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                        if (message.refundHTLTOrder != null && Object.hasOwnProperty.call(message, "refundHTLTOrder"))
                            $root.TW.Binance.Proto.RefundHTLTOrder.encode(message.refundHTLTOrder, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                        if (message.issueOrder != null && Object.hasOwnProperty.call(message, "issueOrder"))
                            $root.TW.Binance.Proto.TokenIssueOrder.encode(message.issueOrder, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                        if (message.mintOrder != null && Object.hasOwnProperty.call(message, "mintOrder"))
                            $root.TW.Binance.Proto.TokenMintOrder.encode(message.mintOrder, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                        if (message.burnOrder != null && Object.hasOwnProperty.call(message, "burnOrder"))
                            $root.TW.Binance.Proto.TokenBurnOrder.encode(message.burnOrder, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                        if (message.transferOutOrder != null && Object.hasOwnProperty.call(message, "transferOutOrder"))
                            $root.TW.Binance.Proto.TransferOut.encode(message.transferOutOrder, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                        if (message.sideDelegateOrder != null && Object.hasOwnProperty.call(message, "sideDelegateOrder"))
                            $root.TW.Binance.Proto.SideChainDelegate.encode(message.sideDelegateOrder, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                        if (message.sideRedelegateOrder != null && Object.hasOwnProperty.call(message, "sideRedelegateOrder"))
                            $root.TW.Binance.Proto.SideChainRedelegate.encode(message.sideRedelegateOrder, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                        if (message.sideUndelegateOrder != null && Object.hasOwnProperty.call(message, "sideUndelegateOrder"))
                            $root.TW.Binance.Proto.SideChainUndelegate.encode(message.sideUndelegateOrder, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                        if (message.timeLockOrder != null && Object.hasOwnProperty.call(message, "timeLockOrder"))
                            $root.TW.Binance.Proto.TimeLockOrder.encode(message.timeLockOrder, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                        if (message.timeRelockOrder != null && Object.hasOwnProperty.call(message, "timeRelockOrder"))
                            $root.TW.Binance.Proto.TimeRelockOrder.encode(message.timeRelockOrder, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                        if (message.timeUnlockOrder != null && Object.hasOwnProperty.call(message, "timeUnlockOrder"))
                            $root.TW.Binance.Proto.TimeUnlockOrder.encode(message.timeUnlockOrder, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.string();
                                break;
                            case 2:
                                message.accountNumber = reader.int64();
                                break;
                            case 3:
                                message.sequence = reader.int64();
                                break;
                            case 4:
                                message.source = reader.int64();
                                break;
                            case 5:
                                message.memo = reader.string();
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            case 8:
                                message.tradeOrder = $root.TW.Binance.Proto.TradeOrder.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.cancelTradeOrder = $root.TW.Binance.Proto.CancelTradeOrder.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.sendOrder = $root.TW.Binance.Proto.SendOrder.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.freezeOrder = $root.TW.Binance.Proto.TokenFreezeOrder.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.unfreezeOrder = $root.TW.Binance.Proto.TokenUnfreezeOrder.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.htltOrder = $root.TW.Binance.Proto.HTLTOrder.decode(reader, reader.uint32());
                                break;
                            case 14:
                                message.depositHTLTOrder = $root.TW.Binance.Proto.DepositHTLTOrder.decode(reader, reader.uint32());
                                break;
                            case 15:
                                message.claimHTLTOrder = $root.TW.Binance.Proto.ClaimHTLOrder.decode(reader, reader.uint32());
                                break;
                            case 16:
                                message.refundHTLTOrder = $root.TW.Binance.Proto.RefundHTLTOrder.decode(reader, reader.uint32());
                                break;
                            case 17:
                                message.issueOrder = $root.TW.Binance.Proto.TokenIssueOrder.decode(reader, reader.uint32());
                                break;
                            case 18:
                                message.mintOrder = $root.TW.Binance.Proto.TokenMintOrder.decode(reader, reader.uint32());
                                break;
                            case 19:
                                message.burnOrder = $root.TW.Binance.Proto.TokenBurnOrder.decode(reader, reader.uint32());
                                break;
                            case 20:
                                message.transferOutOrder = $root.TW.Binance.Proto.TransferOut.decode(reader, reader.uint32());
                                break;
                            case 21:
                                message.sideDelegateOrder = $root.TW.Binance.Proto.SideChainDelegate.decode(reader, reader.uint32());
                                break;
                            case 22:
                                message.sideRedelegateOrder = $root.TW.Binance.Proto.SideChainRedelegate.decode(reader, reader.uint32());
                                break;
                            case 23:
                                message.sideUndelegateOrder = $root.TW.Binance.Proto.SideChainUndelegate.decode(reader, reader.uint32());
                                break;
                            case 24:
                                message.timeLockOrder = $root.TW.Binance.Proto.TimeLockOrder.decode(reader, reader.uint32());
                                break;
                            case 25:
                                message.timeRelockOrder = $root.TW.Binance.Proto.TimeRelockOrder.decode(reader, reader.uint32());
                                break;
                            case 26:
                                message.timeUnlockOrder = $root.TW.Binance.Proto.TimeUnlockOrder.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                                return "accountNumber: integer|Long expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (!$util.isInteger(message.source) && !(message.source && $util.isInteger(message.source.low) && $util.isInteger(message.source.high)))
                                return "source: integer|Long expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.tradeOrder != null && message.hasOwnProperty("tradeOrder")) {
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TradeOrder.verify(message.tradeOrder);
                                if (error)
                                    return "tradeOrder." + error;
                            }
                        }
                        if (message.cancelTradeOrder != null && message.hasOwnProperty("cancelTradeOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.CancelTradeOrder.verify(message.cancelTradeOrder);
                                if (error)
                                    return "cancelTradeOrder." + error;
                            }
                        }
                        if (message.sendOrder != null && message.hasOwnProperty("sendOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.SendOrder.verify(message.sendOrder);
                                if (error)
                                    return "sendOrder." + error;
                            }
                        }
                        if (message.freezeOrder != null && message.hasOwnProperty("freezeOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TokenFreezeOrder.verify(message.freezeOrder);
                                if (error)
                                    return "freezeOrder." + error;
                            }
                        }
                        if (message.unfreezeOrder != null && message.hasOwnProperty("unfreezeOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TokenUnfreezeOrder.verify(message.unfreezeOrder);
                                if (error)
                                    return "unfreezeOrder." + error;
                            }
                        }
                        if (message.htltOrder != null && message.hasOwnProperty("htltOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.HTLTOrder.verify(message.htltOrder);
                                if (error)
                                    return "htltOrder." + error;
                            }
                        }
                        if (message.depositHTLTOrder != null && message.hasOwnProperty("depositHTLTOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.DepositHTLTOrder.verify(message.depositHTLTOrder);
                                if (error)
                                    return "depositHTLTOrder." + error;
                            }
                        }
                        if (message.claimHTLTOrder != null && message.hasOwnProperty("claimHTLTOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.ClaimHTLOrder.verify(message.claimHTLTOrder);
                                if (error)
                                    return "claimHTLTOrder." + error;
                            }
                        }
                        if (message.refundHTLTOrder != null && message.hasOwnProperty("refundHTLTOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.RefundHTLTOrder.verify(message.refundHTLTOrder);
                                if (error)
                                    return "refundHTLTOrder." + error;
                            }
                        }
                        if (message.issueOrder != null && message.hasOwnProperty("issueOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TokenIssueOrder.verify(message.issueOrder);
                                if (error)
                                    return "issueOrder." + error;
                            }
                        }
                        if (message.mintOrder != null && message.hasOwnProperty("mintOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TokenMintOrder.verify(message.mintOrder);
                                if (error)
                                    return "mintOrder." + error;
                            }
                        }
                        if (message.burnOrder != null && message.hasOwnProperty("burnOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TokenBurnOrder.verify(message.burnOrder);
                                if (error)
                                    return "burnOrder." + error;
                            }
                        }
                        if (message.transferOutOrder != null && message.hasOwnProperty("transferOutOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TransferOut.verify(message.transferOutOrder);
                                if (error)
                                    return "transferOutOrder." + error;
                            }
                        }
                        if (message.sideDelegateOrder != null && message.hasOwnProperty("sideDelegateOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.SideChainDelegate.verify(message.sideDelegateOrder);
                                if (error)
                                    return "sideDelegateOrder." + error;
                            }
                        }
                        if (message.sideRedelegateOrder != null && message.hasOwnProperty("sideRedelegateOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.SideChainRedelegate.verify(message.sideRedelegateOrder);
                                if (error)
                                    return "sideRedelegateOrder." + error;
                            }
                        }
                        if (message.sideUndelegateOrder != null && message.hasOwnProperty("sideUndelegateOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.SideChainUndelegate.verify(message.sideUndelegateOrder);
                                if (error)
                                    return "sideUndelegateOrder." + error;
                            }
                        }
                        if (message.timeLockOrder != null && message.hasOwnProperty("timeLockOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TimeLockOrder.verify(message.timeLockOrder);
                                if (error)
                                    return "timeLockOrder." + error;
                            }
                        }
                        if (message.timeRelockOrder != null && message.hasOwnProperty("timeRelockOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TimeRelockOrder.verify(message.timeRelockOrder);
                                if (error)
                                    return "timeRelockOrder." + error;
                            }
                        }
                        if (message.timeUnlockOrder != null && message.hasOwnProperty("timeUnlockOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TimeUnlockOrder.verify(message.timeUnlockOrder);
                                if (error)
                                    return "timeUnlockOrder." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Binance.Proto.SigningInput();
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.accountNumber != null)
                            if ($util.Long)
                                (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = false;
                            else if (typeof object.accountNumber === "string")
                                message.accountNumber = parseInt(object.accountNumber, 10);
                            else if (typeof object.accountNumber === "number")
                                message.accountNumber = object.accountNumber;
                            else if (typeof object.accountNumber === "object")
                                message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber();
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                        if (object.source != null)
                            if ($util.Long)
                                (message.source = $util.Long.fromValue(object.source)).unsigned = false;
                            else if (typeof object.source === "string")
                                message.source = parseInt(object.source, 10);
                            else if (typeof object.source === "number")
                                message.source = object.source;
                            else if (typeof object.source === "object")
                                message.source = new $util.LongBits(object.source.low >>> 0, object.source.high >>> 0).toNumber();
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.tradeOrder != null) {
                            if (typeof object.tradeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.tradeOrder: object expected");
                            message.tradeOrder = $root.TW.Binance.Proto.TradeOrder.fromObject(object.tradeOrder);
                        }
                        if (object.cancelTradeOrder != null) {
                            if (typeof object.cancelTradeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.cancelTradeOrder: object expected");
                            message.cancelTradeOrder = $root.TW.Binance.Proto.CancelTradeOrder.fromObject(object.cancelTradeOrder);
                        }
                        if (object.sendOrder != null) {
                            if (typeof object.sendOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.sendOrder: object expected");
                            message.sendOrder = $root.TW.Binance.Proto.SendOrder.fromObject(object.sendOrder);
                        }
                        if (object.freezeOrder != null) {
                            if (typeof object.freezeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.freezeOrder: object expected");
                            message.freezeOrder = $root.TW.Binance.Proto.TokenFreezeOrder.fromObject(object.freezeOrder);
                        }
                        if (object.unfreezeOrder != null) {
                            if (typeof object.unfreezeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.unfreezeOrder: object expected");
                            message.unfreezeOrder = $root.TW.Binance.Proto.TokenUnfreezeOrder.fromObject(object.unfreezeOrder);
                        }
                        if (object.htltOrder != null) {
                            if (typeof object.htltOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.htltOrder: object expected");
                            message.htltOrder = $root.TW.Binance.Proto.HTLTOrder.fromObject(object.htltOrder);
                        }
                        if (object.depositHTLTOrder != null) {
                            if (typeof object.depositHTLTOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.depositHTLTOrder: object expected");
                            message.depositHTLTOrder = $root.TW.Binance.Proto.DepositHTLTOrder.fromObject(object.depositHTLTOrder);
                        }
                        if (object.claimHTLTOrder != null) {
                            if (typeof object.claimHTLTOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.claimHTLTOrder: object expected");
                            message.claimHTLTOrder = $root.TW.Binance.Proto.ClaimHTLOrder.fromObject(object.claimHTLTOrder);
                        }
                        if (object.refundHTLTOrder != null) {
                            if (typeof object.refundHTLTOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.refundHTLTOrder: object expected");
                            message.refundHTLTOrder = $root.TW.Binance.Proto.RefundHTLTOrder.fromObject(object.refundHTLTOrder);
                        }
                        if (object.issueOrder != null) {
                            if (typeof object.issueOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.issueOrder: object expected");
                            message.issueOrder = $root.TW.Binance.Proto.TokenIssueOrder.fromObject(object.issueOrder);
                        }
                        if (object.mintOrder != null) {
                            if (typeof object.mintOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.mintOrder: object expected");
                            message.mintOrder = $root.TW.Binance.Proto.TokenMintOrder.fromObject(object.mintOrder);
                        }
                        if (object.burnOrder != null) {
                            if (typeof object.burnOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.burnOrder: object expected");
                            message.burnOrder = $root.TW.Binance.Proto.TokenBurnOrder.fromObject(object.burnOrder);
                        }
                        if (object.transferOutOrder != null) {
                            if (typeof object.transferOutOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.transferOutOrder: object expected");
                            message.transferOutOrder = $root.TW.Binance.Proto.TransferOut.fromObject(object.transferOutOrder);
                        }
                        if (object.sideDelegateOrder != null) {
                            if (typeof object.sideDelegateOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.sideDelegateOrder: object expected");
                            message.sideDelegateOrder = $root.TW.Binance.Proto.SideChainDelegate.fromObject(object.sideDelegateOrder);
                        }
                        if (object.sideRedelegateOrder != null) {
                            if (typeof object.sideRedelegateOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.sideRedelegateOrder: object expected");
                            message.sideRedelegateOrder = $root.TW.Binance.Proto.SideChainRedelegate.fromObject(object.sideRedelegateOrder);
                        }
                        if (object.sideUndelegateOrder != null) {
                            if (typeof object.sideUndelegateOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.sideUndelegateOrder: object expected");
                            message.sideUndelegateOrder = $root.TW.Binance.Proto.SideChainUndelegate.fromObject(object.sideUndelegateOrder);
                        }
                        if (object.timeLockOrder != null) {
                            if (typeof object.timeLockOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.timeLockOrder: object expected");
                            message.timeLockOrder = $root.TW.Binance.Proto.TimeLockOrder.fromObject(object.timeLockOrder);
                        }
                        if (object.timeRelockOrder != null) {
                            if (typeof object.timeRelockOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.timeRelockOrder: object expected");
                            message.timeRelockOrder = $root.TW.Binance.Proto.TimeRelockOrder.fromObject(object.timeRelockOrder);
                        }
                        if (object.timeUnlockOrder != null) {
                            if (typeof object.timeUnlockOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.timeUnlockOrder: object expected");
                            message.timeUnlockOrder = $root.TW.Binance.Proto.TimeUnlockOrder.fromObject(object.timeUnlockOrder);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {TW.Binance.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.chainId = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.accountNumber = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.source = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.source = options.longs === String ? "0" : 0;
                            object.memo = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (typeof message.accountNumber === "number")
                                object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                            else
                                object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber() : message.accountNumber;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (typeof message.source === "number")
                                object.source = options.longs === String ? String(message.source) : message.source;
                            else
                                object.source = options.longs === String ? $util.Long.prototype.toString.call(message.source) : options.longs === Number ? new $util.LongBits(message.source.low >>> 0, message.source.high >>> 0).toNumber() : message.source;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.tradeOrder != null && message.hasOwnProperty("tradeOrder")) {
                            object.tradeOrder = $root.TW.Binance.Proto.TradeOrder.toObject(message.tradeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "tradeOrder";
                        }
                        if (message.cancelTradeOrder != null && message.hasOwnProperty("cancelTradeOrder")) {
                            object.cancelTradeOrder = $root.TW.Binance.Proto.CancelTradeOrder.toObject(message.cancelTradeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "cancelTradeOrder";
                        }
                        if (message.sendOrder != null && message.hasOwnProperty("sendOrder")) {
                            object.sendOrder = $root.TW.Binance.Proto.SendOrder.toObject(message.sendOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "sendOrder";
                        }
                        if (message.freezeOrder != null && message.hasOwnProperty("freezeOrder")) {
                            object.freezeOrder = $root.TW.Binance.Proto.TokenFreezeOrder.toObject(message.freezeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "freezeOrder";
                        }
                        if (message.unfreezeOrder != null && message.hasOwnProperty("unfreezeOrder")) {
                            object.unfreezeOrder = $root.TW.Binance.Proto.TokenUnfreezeOrder.toObject(message.unfreezeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "unfreezeOrder";
                        }
                        if (message.htltOrder != null && message.hasOwnProperty("htltOrder")) {
                            object.htltOrder = $root.TW.Binance.Proto.HTLTOrder.toObject(message.htltOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "htltOrder";
                        }
                        if (message.depositHTLTOrder != null && message.hasOwnProperty("depositHTLTOrder")) {
                            object.depositHTLTOrder = $root.TW.Binance.Proto.DepositHTLTOrder.toObject(message.depositHTLTOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "depositHTLTOrder";
                        }
                        if (message.claimHTLTOrder != null && message.hasOwnProperty("claimHTLTOrder")) {
                            object.claimHTLTOrder = $root.TW.Binance.Proto.ClaimHTLOrder.toObject(message.claimHTLTOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "claimHTLTOrder";
                        }
                        if (message.refundHTLTOrder != null && message.hasOwnProperty("refundHTLTOrder")) {
                            object.refundHTLTOrder = $root.TW.Binance.Proto.RefundHTLTOrder.toObject(message.refundHTLTOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "refundHTLTOrder";
                        }
                        if (message.issueOrder != null && message.hasOwnProperty("issueOrder")) {
                            object.issueOrder = $root.TW.Binance.Proto.TokenIssueOrder.toObject(message.issueOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "issueOrder";
                        }
                        if (message.mintOrder != null && message.hasOwnProperty("mintOrder")) {
                            object.mintOrder = $root.TW.Binance.Proto.TokenMintOrder.toObject(message.mintOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "mintOrder";
                        }
                        if (message.burnOrder != null && message.hasOwnProperty("burnOrder")) {
                            object.burnOrder = $root.TW.Binance.Proto.TokenBurnOrder.toObject(message.burnOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "burnOrder";
                        }
                        if (message.transferOutOrder != null && message.hasOwnProperty("transferOutOrder")) {
                            object.transferOutOrder = $root.TW.Binance.Proto.TransferOut.toObject(message.transferOutOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "transferOutOrder";
                        }
                        if (message.sideDelegateOrder != null && message.hasOwnProperty("sideDelegateOrder")) {
                            object.sideDelegateOrder = $root.TW.Binance.Proto.SideChainDelegate.toObject(message.sideDelegateOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "sideDelegateOrder";
                        }
                        if (message.sideRedelegateOrder != null && message.hasOwnProperty("sideRedelegateOrder")) {
                            object.sideRedelegateOrder = $root.TW.Binance.Proto.SideChainRedelegate.toObject(message.sideRedelegateOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "sideRedelegateOrder";
                        }
                        if (message.sideUndelegateOrder != null && message.hasOwnProperty("sideUndelegateOrder")) {
                            object.sideUndelegateOrder = $root.TW.Binance.Proto.SideChainUndelegate.toObject(message.sideUndelegateOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "sideUndelegateOrder";
                        }
                        if (message.timeLockOrder != null && message.hasOwnProperty("timeLockOrder")) {
                            object.timeLockOrder = $root.TW.Binance.Proto.TimeLockOrder.toObject(message.timeLockOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "timeLockOrder";
                        }
                        if (message.timeRelockOrder != null && message.hasOwnProperty("timeRelockOrder")) {
                            object.timeRelockOrder = $root.TW.Binance.Proto.TimeRelockOrder.toObject(message.timeRelockOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "timeRelockOrder";
                        }
                        if (message.timeUnlockOrder != null && message.hasOwnProperty("timeUnlockOrder")) {
                            object.timeUnlockOrder = $root.TW.Binance.Proto.TimeUnlockOrder.toObject(message.timeUnlockOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "timeUnlockOrder";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Binance.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {TW.Common.Proto.SigningError|null} [error] error code, 0 is ok, other codes will be treated as errors
                     * @property {string|null} [errorMessage] error description
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Binance.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * error code, 0 is ok, other codes will be treated as errors
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * error description
                     * @member {string} errorMessage
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.errorMessage = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {TW.Binance.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Binance.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {TW.Binance.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.error);
                        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMessage);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.error = reader.int32();
                                break;
                            case 3:
                                message.errorMessage = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            if (!$util.isString(message.errorMessage))
                                return "errorMessage: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Binance.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        if (object.errorMessage != null)
                            message.errorMessage = String(object.errorMessage);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {TW.Binance.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            object.error = options.enums === String ? "OK" : 0;
                            object.errorMessage = "";
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            object.errorMessage = message.errorMessage;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Binance;
        })();
    
        TW.Common = (function() {
    
            /**
             * Namespace Common.
             * @memberof TW
             * @namespace
             */
            var Common = {};
    
            Common.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Common
                 * @namespace
                 */
                var Proto = {};
    
                /**
                 * SigningError enum.
                 * @name TW.Common.Proto.SigningError
                 * @enum {number}
                 * @property {number} OK=0 OK value
                 * @property {number} Error_general=1 Error_general value
                 * @property {number} Error_internal=2 Error_internal value
                 * @property {number} Error_low_balance=3 Error_low_balance value
                 * @property {number} Error_zero_amount_requested=4 Error_zero_amount_requested value
                 * @property {number} Error_missing_private_key=5 Error_missing_private_key value
                 * @property {number} Error_invalid_private_key=15 Error_invalid_private_key value
                 * @property {number} Error_invalid_address=16 Error_invalid_address value
                 * @property {number} Error_invalid_utxo=17 Error_invalid_utxo value
                 * @property {number} Error_invalid_utxo_amount=18 Error_invalid_utxo_amount value
                 * @property {number} Error_wrong_fee=6 Error_wrong_fee value
                 * @property {number} Error_signing=7 Error_signing value
                 * @property {number} Error_tx_too_big=8 Error_tx_too_big value
                 * @property {number} Error_missing_input_utxos=9 Error_missing_input_utxos value
                 * @property {number} Error_not_enough_utxos=10 Error_not_enough_utxos value
                 * @property {number} Error_script_redeem=11 Error_script_redeem value
                 * @property {number} Error_script_output=12 Error_script_output value
                 * @property {number} Error_script_witness_program=13 Error_script_witness_program value
                 * @property {number} Error_invalid_memo=14 Error_invalid_memo value
                 * @property {number} Error_input_parse=19 Error_input_parse value
                 * @property {number} Error_no_support_n2n=20 Error_no_support_n2n value
                 * @property {number} Error_signatures_count=21 Error_signatures_count value
                 * @property {number} Error_invalid_params=22 Error_invalid_params value
                 * @property {number} Error_invalid_requested_token_amount=23 Error_invalid_requested_token_amount value
                 */
                Proto.SigningError = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "OK"] = 0;
                    values[valuesById[1] = "Error_general"] = 1;
                    values[valuesById[2] = "Error_internal"] = 2;
                    values[valuesById[3] = "Error_low_balance"] = 3;
                    values[valuesById[4] = "Error_zero_amount_requested"] = 4;
                    values[valuesById[5] = "Error_missing_private_key"] = 5;
                    values[valuesById[15] = "Error_invalid_private_key"] = 15;
                    values[valuesById[16] = "Error_invalid_address"] = 16;
                    values[valuesById[17] = "Error_invalid_utxo"] = 17;
                    values[valuesById[18] = "Error_invalid_utxo_amount"] = 18;
                    values[valuesById[6] = "Error_wrong_fee"] = 6;
                    values[valuesById[7] = "Error_signing"] = 7;
                    values[valuesById[8] = "Error_tx_too_big"] = 8;
                    values[valuesById[9] = "Error_missing_input_utxos"] = 9;
                    values[valuesById[10] = "Error_not_enough_utxos"] = 10;
                    values[valuesById[11] = "Error_script_redeem"] = 11;
                    values[valuesById[12] = "Error_script_output"] = 12;
                    values[valuesById[13] = "Error_script_witness_program"] = 13;
                    values[valuesById[14] = "Error_invalid_memo"] = 14;
                    values[valuesById[19] = "Error_input_parse"] = 19;
                    values[valuesById[20] = "Error_no_support_n2n"] = 20;
                    values[valuesById[21] = "Error_signatures_count"] = 21;
                    values[valuesById[22] = "Error_invalid_params"] = 22;
                    values[valuesById[23] = "Error_invalid_requested_token_amount"] = 23;
                    return values;
                })();
    
                return Proto;
            })();
    
            return Common;
        })();
    
        TW.Bitcoin = (function() {
    
            /**
             * Namespace Bitcoin.
             * @memberof TW
             * @namespace
             */
            var Bitcoin = {};
    
            Bitcoin.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Bitcoin
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransaction
                     * @property {number|null} [version] Transaction version
                     * @property {number|null} [lockTime] Transaction lockTime
                     * @property {Array.<TW.Bitcoin.Proto.ITransactionInput>|null} [inputs] Transaction inputs
                     * @property {Array.<TW.Bitcoin.Proto.ITransactionOutput>|null} [outputs] Transaction outputs
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction version.
                     * @member {number} version
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.version = 0;
    
                    /**
                     * Transaction lockTime.
                     * @member {number} lockTime
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.lockTime = 0;
    
                    /**
                     * Transaction inputs.
                     * @member {Array.<TW.Bitcoin.Proto.ITransactionInput>} inputs
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.inputs = $util.emptyArray;
    
                    /**
                     * Transaction outputs.
                     * @member {Array.<TW.Bitcoin.Proto.ITransactionOutput>} outputs
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.outputs = $util.emptyArray;
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Bitcoin.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.version);
                        if (message.lockTime != null && Object.hasOwnProperty.call(message, "lockTime"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lockTime);
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.Bitcoin.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.Bitcoin.Proto.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.sint32();
                                break;
                            case 2:
                                message.lockTime = reader.uint32();
                                break;
                            case 3:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.Bitcoin.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.Bitcoin.Proto.TransactionOutput.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime))
                                return "lockTime: integer expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.TransactionOutput.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.Transaction();
                        if (object.version != null)
                            message.version = object.version | 0;
                        if (object.lockTime != null)
                            message.lockTime = object.lockTime >>> 0;
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.Bitcoin.Proto.Transaction.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.Transaction.inputs: object expected");
                                message.inputs[i] = $root.TW.Bitcoin.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.Bitcoin.Proto.Transaction.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.Transaction.outputs: object expected");
                                message.outputs[i] = $root.TW.Bitcoin.Proto.TransactionOutput.fromObject(object.outputs[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {TW.Bitcoin.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (options.defaults) {
                            object.version = 0;
                            object.lockTime = 0;
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            object.lockTime = message.lockTime;
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.Bitcoin.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.Bitcoin.Proto.TransactionOutput.toObject(message.outputs[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.TransactionInput = (function() {
    
                    /**
                     * Properties of a TransactionInput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransactionInput
                     * @property {TW.Bitcoin.Proto.IOutPoint|null} [previousOutput] TransactionInput previousOutput
                     * @property {number|null} [sequence] TransactionInput sequence
                     * @property {Uint8Array|null} [script] TransactionInput script
                     */
    
                    /**
                     * Constructs a new TransactionInput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a TransactionInput.
                     * @implements ITransactionInput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransactionInput=} [properties] Properties to set
                     */
                    function TransactionInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionInput previousOutput.
                     * @member {TW.Bitcoin.Proto.IOutPoint|null|undefined} previousOutput
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.previousOutput = null;
    
                    /**
                     * TransactionInput sequence.
                     * @member {number} sequence
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.sequence = 0;
    
                    /**
                     * TransactionInput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionInput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.TransactionInput} TransactionInput instance
                     */
                    TransactionInput.create = function create(properties) {
                        return new TransactionInput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionInput message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.previousOutput != null && Object.hasOwnProperty.call(message, "previousOutput"))
                            $root.TW.Bitcoin.Proto.OutPoint.encode(message.previousOutput, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sequence);
                        if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.TransactionInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.sequence = reader.uint32();
                                break;
                            case 3:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionInput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput")) {
                            var error = $root.TW.Bitcoin.Proto.OutPoint.verify(message.previousOutput);
                            if (error)
                                return "previousOutput." + error;
                        }
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.TransactionInput} TransactionInput
                     */
                    TransactionInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.TransactionInput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.TransactionInput();
                        if (object.previousOutput != null) {
                            if (typeof object.previousOutput !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.TransactionInput.previousOutput: object expected");
                            message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.fromObject(object.previousOutput);
                        }
                        if (object.sequence != null)
                            message.sequence = object.sequence >>> 0;
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {TW.Bitcoin.Proto.TransactionInput} message TransactionInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.previousOutput = null;
                            object.sequence = 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput"))
                            object.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.toObject(message.previousOutput, options);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionInput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionInput;
                })();
    
                Proto.OutPoint = (function() {
    
                    /**
                     * Properties of an OutPoint.
                     * @memberof TW.Bitcoin.Proto
                     * @interface IOutPoint
                     * @property {Uint8Array|null} [hash] OutPoint hash
                     * @property {number|null} [index] OutPoint index
                     * @property {number|null} [sequence] OutPoint sequence
                     */
    
                    /**
                     * Constructs a new OutPoint.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents an OutPoint.
                     * @implements IOutPoint
                     * @constructor
                     * @param {TW.Bitcoin.Proto.IOutPoint=} [properties] Properties to set
                     */
                    function OutPoint(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OutPoint hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * OutPoint index.
                     * @member {number} index
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.index = 0;
    
                    /**
                     * OutPoint sequence.
                     * @member {number} sequence
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.sequence = 0;
    
                    /**
                     * Creates a new OutPoint instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {TW.Bitcoin.Proto.IOutPoint=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.OutPoint} OutPoint instance
                     */
                    OutPoint.create = function create(properties) {
                        return new OutPoint(properties);
                    };
    
                    /**
                     * Encodes the specified OutPoint message. Does not implicitly {@link TW.Bitcoin.Proto.OutPoint.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {TW.Bitcoin.Proto.IOutPoint} message OutPoint message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OutPoint.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sequence);
                        return writer;
                    };
    
                    /**
                     * Decodes an OutPoint message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.OutPoint} OutPoint
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OutPoint.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.OutPoint();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hash = reader.bytes();
                                break;
                            case 2:
                                message.index = reader.uint32();
                                break;
                            case 3:
                                message.sequence = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OutPoint message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OutPoint.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        if (message.index != null && message.hasOwnProperty("index"))
                            if (!$util.isInteger(message.index))
                                return "index: integer expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.OutPoint} OutPoint
                     */
                    OutPoint.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.OutPoint)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.OutPoint();
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        if (object.index != null)
                            message.index = object.index >>> 0;
                        if (object.sequence != null)
                            message.sequence = object.sequence >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {TW.Bitcoin.Proto.OutPoint} message OutPoint
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OutPoint.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                            object.index = 0;
                            object.sequence = 0;
                        }
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        if (message.index != null && message.hasOwnProperty("index"))
                            object.index = message.index;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        return object;
                    };
    
                    /**
                     * Converts this OutPoint to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OutPoint.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OutPoint;
                })();
    
                Proto.TransactionOutput = (function() {
    
                    /**
                     * Properties of a TransactionOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransactionOutput
                     * @property {Long|null} [value] TransactionOutput value
                     * @property {Uint8Array|null} [script] TransactionOutput script
                     */
    
                    /**
                     * Constructs a new TransactionOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a TransactionOutput.
                     * @implements ITransactionOutput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransactionOutput=} [properties] Properties to set
                     */
                    function TransactionOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOutput value.
                     * @member {Long} value
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionOutput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.TransactionOutput} TransactionOutput instance
                     */
                    TransactionOutput.create = function create(properties) {
                        return new TransactionOutput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                        if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.TransactionOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.int64();
                                break;
                            case 2:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionOutput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.TransactionOutput} TransactionOutput
                     */
                    TransactionOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.TransactionOutput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.TransactionOutput();
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.TransactionOutput} message TransactionOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOutput;
                })();
    
                Proto.UnspentTransaction = (function() {
    
                    /**
                     * Properties of an UnspentTransaction.
                     * @memberof TW.Bitcoin.Proto
                     * @interface IUnspentTransaction
                     * @property {TW.Bitcoin.Proto.IOutPoint|null} [outPoint] UnspentTransaction outPoint
                     * @property {Uint8Array|null} [script] UnspentTransaction script
                     * @property {Long|null} [amount] UnspentTransaction amount
                     */
    
                    /**
                     * Constructs a new UnspentTransaction.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents an UnspentTransaction.
                     * @implements IUnspentTransaction
                     * @constructor
                     * @param {TW.Bitcoin.Proto.IUnspentTransaction=} [properties] Properties to set
                     */
                    function UnspentTransaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * UnspentTransaction outPoint.
                     * @member {TW.Bitcoin.Proto.IOutPoint|null|undefined} outPoint
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     */
                    UnspentTransaction.prototype.outPoint = null;
    
                    /**
                     * UnspentTransaction script.
                     * @member {Uint8Array} script
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     */
                    UnspentTransaction.prototype.script = $util.newBuffer([]);
    
                    /**
                     * UnspentTransaction amount.
                     * @member {Long} amount
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     */
                    UnspentTransaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new UnspentTransaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {TW.Bitcoin.Proto.IUnspentTransaction=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.UnspentTransaction} UnspentTransaction instance
                     */
                    UnspentTransaction.create = function create(properties) {
                        return new UnspentTransaction(properties);
                    };
    
                    /**
                     * Encodes the specified UnspentTransaction message. Does not implicitly {@link TW.Bitcoin.Proto.UnspentTransaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {TW.Bitcoin.Proto.IUnspentTransaction} message UnspentTransaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UnspentTransaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.outPoint != null && Object.hasOwnProperty.call(message, "outPoint"))
                            $root.TW.Bitcoin.Proto.OutPoint.encode(message.outPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.script);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes an UnspentTransaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.UnspentTransaction} UnspentTransaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UnspentTransaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.UnspentTransaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.outPoint = $root.TW.Bitcoin.Proto.OutPoint.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.script = reader.bytes();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an UnspentTransaction message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UnspentTransaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.outPoint != null && message.hasOwnProperty("outPoint")) {
                            var error = $root.TW.Bitcoin.Proto.OutPoint.verify(message.outPoint);
                            if (error)
                                return "outPoint." + error;
                        }
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an UnspentTransaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.UnspentTransaction} UnspentTransaction
                     */
                    UnspentTransaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.UnspentTransaction)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.UnspentTransaction();
                        if (object.outPoint != null) {
                            if (typeof object.outPoint !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.UnspentTransaction.outPoint: object expected");
                            message.outPoint = $root.TW.Bitcoin.Proto.OutPoint.fromObject(object.outPoint);
                        }
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an UnspentTransaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {TW.Bitcoin.Proto.UnspentTransaction} message UnspentTransaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UnspentTransaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.outPoint = null;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.outPoint != null && message.hasOwnProperty("outPoint"))
                            object.outPoint = $root.TW.Bitcoin.Proto.OutPoint.toObject(message.outPoint, options);
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this UnspentTransaction to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UnspentTransaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return UnspentTransaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ISigningInput
                     * @property {number|null} [hashType] SigningInput hashType
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {Long|null} [byteFee] SigningInput byteFee
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {string|null} [changeAddress] SigningInput changeAddress
                     * @property {Array.<Uint8Array>|null} [privateKey] SigningInput privateKey
                     * @property {Object.<string,Uint8Array>|null} [scripts] SigningInput scripts
                     * @property {Array.<TW.Bitcoin.Proto.IUnspentTransaction>|null} [utxo] SigningInput utxo
                     * @property {boolean|null} [useMaxAmount] SigningInput useMaxAmount
                     * @property {number|null} [coinType] SigningInput coinType
                     * @property {TW.Bitcoin.Proto.ITransactionPlan|null} [plan] SigningInput plan
                     * @property {number|null} [lockTime] SigningInput lockTime
                     * @property {Uint8Array|null} [outputOpReturn] SigningInput outputOpReturn
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.privateKey = [];
                        this.scripts = {};
                        this.utxo = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput hashType.
                     * @member {number} hashType
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.hashType = 0;
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput byteFee.
                     * @member {Long} byteFee
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.byteFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput changeAddress.
                     * @member {string} changeAddress
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.changeAddress = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Array.<Uint8Array>} privateKey
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.emptyArray;
    
                    /**
                     * SigningInput scripts.
                     * @member {Object.<string,Uint8Array>} scripts
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.scripts = $util.emptyObject;
    
                    /**
                     * SigningInput utxo.
                     * @member {Array.<TW.Bitcoin.Proto.IUnspentTransaction>} utxo
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.utxo = $util.emptyArray;
    
                    /**
                     * SigningInput useMaxAmount.
                     * @member {boolean} useMaxAmount
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.useMaxAmount = false;
    
                    /**
                     * SigningInput coinType.
                     * @member {number} coinType
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.coinType = 0;
    
                    /**
                     * SigningInput plan.
                     * @member {TW.Bitcoin.Proto.ITransactionPlan|null|undefined} plan
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.plan = null;
    
                    /**
                     * SigningInput lockTime.
                     * @member {number} lockTime
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.lockTime = 0;
    
                    /**
                     * SigningInput outputOpReturn.
                     * @member {Uint8Array} outputOpReturn
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.outputOpReturn = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Bitcoin.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hashType != null && Object.hasOwnProperty.call(message, "hashType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.hashType);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        if (message.byteFee != null && Object.hasOwnProperty.call(message, "byteFee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.byteFee);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.changeAddress != null && Object.hasOwnProperty.call(message, "changeAddress"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.changeAddress);
                        if (message.privateKey != null && message.privateKey.length)
                            for (var i = 0; i < message.privateKey.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey[i]);
                        if (message.scripts != null && Object.hasOwnProperty.call(message, "scripts"))
                            for (var keys = Object.keys(message.scripts), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.scripts[keys[i]]).ldelim();
                        if (message.utxo != null && message.utxo.length)
                            for (var i = 0; i < message.utxo.length; ++i)
                                $root.TW.Bitcoin.Proto.UnspentTransaction.encode(message.utxo[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.useMaxAmount != null && Object.hasOwnProperty.call(message, "useMaxAmount"))
                            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.useMaxAmount);
                        if (message.coinType != null && Object.hasOwnProperty.call(message, "coinType"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.coinType);
                        if (message.plan != null && Object.hasOwnProperty.call(message, "plan"))
                            $root.TW.Bitcoin.Proto.TransactionPlan.encode(message.plan, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.lockTime != null && Object.hasOwnProperty.call(message, "lockTime"))
                            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.lockTime);
                        if (message.outputOpReturn != null && Object.hasOwnProperty.call(message, "outputOpReturn"))
                            writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.outputOpReturn);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.SigningInput(), key, value;
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hashType = reader.uint32();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            case 3:
                                message.byteFee = reader.int64();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.changeAddress = reader.string();
                                break;
                            case 6:
                                if (!(message.privateKey && message.privateKey.length))
                                    message.privateKey = [];
                                message.privateKey.push(reader.bytes());
                                break;
                            case 7:
                                if (message.scripts === $util.emptyObject)
                                    message.scripts = {};
                                var end2 = reader.uint32() + reader.pos;
                                key = "";
                                value = [];
                                while (reader.pos < end2) {
                                    var tag2 = reader.uint32();
                                    switch (tag2 >>> 3) {
                                    case 1:
                                        key = reader.string();
                                        break;
                                    case 2:
                                        value = reader.bytes();
                                        break;
                                    default:
                                        reader.skipType(tag2 & 7);
                                        break;
                                    }
                                }
                                message.scripts[key] = value;
                                break;
                            case 8:
                                if (!(message.utxo && message.utxo.length))
                                    message.utxo = [];
                                message.utxo.push($root.TW.Bitcoin.Proto.UnspentTransaction.decode(reader, reader.uint32()));
                                break;
                            case 9:
                                message.useMaxAmount = reader.bool();
                                break;
                            case 10:
                                message.coinType = reader.uint32();
                                break;
                            case 11:
                                message.plan = $root.TW.Bitcoin.Proto.TransactionPlan.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.lockTime = reader.uint32();
                                break;
                            case 13:
                                message.outputOpReturn = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hashType != null && message.hasOwnProperty("hashType"))
                            if (!$util.isInteger(message.hashType))
                                return "hashType: integer expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.byteFee != null && message.hasOwnProperty("byteFee"))
                            if (!$util.isInteger(message.byteFee) && !(message.byteFee && $util.isInteger(message.byteFee.low) && $util.isInteger(message.byteFee.high)))
                                return "byteFee: integer|Long expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            if (!$util.isString(message.changeAddress))
                                return "changeAddress: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey")) {
                            if (!Array.isArray(message.privateKey))
                                return "privateKey: array expected";
                            for (var i = 0; i < message.privateKey.length; ++i)
                                if (!(message.privateKey[i] && typeof message.privateKey[i].length === "number" || $util.isString(message.privateKey[i])))
                                    return "privateKey: buffer[] expected";
                        }
                        if (message.scripts != null && message.hasOwnProperty("scripts")) {
                            if (!$util.isObject(message.scripts))
                                return "scripts: object expected";
                            var key = Object.keys(message.scripts);
                            for (var i = 0; i < key.length; ++i)
                                if (!(message.scripts[key[i]] && typeof message.scripts[key[i]].length === "number" || $util.isString(message.scripts[key[i]])))
                                    return "scripts: buffer{k:string} expected";
                        }
                        if (message.utxo != null && message.hasOwnProperty("utxo")) {
                            if (!Array.isArray(message.utxo))
                                return "utxo: array expected";
                            for (var i = 0; i < message.utxo.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.UnspentTransaction.verify(message.utxo[i]);
                                if (error)
                                    return "utxo." + error;
                            }
                        }
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            if (typeof message.useMaxAmount !== "boolean")
                                return "useMaxAmount: boolean expected";
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            if (!$util.isInteger(message.coinType))
                                return "coinType: integer expected";
                        if (message.plan != null && message.hasOwnProperty("plan")) {
                            var error = $root.TW.Bitcoin.Proto.TransactionPlan.verify(message.plan);
                            if (error)
                                return "plan." + error;
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime))
                                return "lockTime: integer expected";
                        if (message.outputOpReturn != null && message.hasOwnProperty("outputOpReturn"))
                            if (!(message.outputOpReturn && typeof message.outputOpReturn.length === "number" || $util.isString(message.outputOpReturn)))
                                return "outputOpReturn: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.SigningInput();
                        if (object.hashType != null)
                            message.hashType = object.hashType >>> 0;
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.byteFee != null)
                            if ($util.Long)
                                (message.byteFee = $util.Long.fromValue(object.byteFee)).unsigned = false;
                            else if (typeof object.byteFee === "string")
                                message.byteFee = parseInt(object.byteFee, 10);
                            else if (typeof object.byteFee === "number")
                                message.byteFee = object.byteFee;
                            else if (typeof object.byteFee === "object")
                                message.byteFee = new $util.LongBits(object.byteFee.low >>> 0, object.byteFee.high >>> 0).toNumber();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.changeAddress != null)
                            message.changeAddress = String(object.changeAddress);
                        if (object.privateKey) {
                            if (!Array.isArray(object.privateKey))
                                throw TypeError(".TW.Bitcoin.Proto.SigningInput.privateKey: array expected");
                            message.privateKey = [];
                            for (var i = 0; i < object.privateKey.length; ++i)
                                if (typeof object.privateKey[i] === "string")
                                    $util.base64.decode(object.privateKey[i], message.privateKey[i] = $util.newBuffer($util.base64.length(object.privateKey[i])), 0);
                                else if (object.privateKey[i].length)
                                    message.privateKey[i] = object.privateKey[i];
                        }
                        if (object.scripts) {
                            if (typeof object.scripts !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.SigningInput.scripts: object expected");
                            message.scripts = {};
                            for (var keys = Object.keys(object.scripts), i = 0; i < keys.length; ++i)
                                if (typeof object.scripts[keys[i]] === "string")
                                    $util.base64.decode(object.scripts[keys[i]], message.scripts[keys[i]] = $util.newBuffer($util.base64.length(object.scripts[keys[i]])), 0);
                                else if (object.scripts[keys[i]].length)
                                    message.scripts[keys[i]] = object.scripts[keys[i]];
                        }
                        if (object.utxo) {
                            if (!Array.isArray(object.utxo))
                                throw TypeError(".TW.Bitcoin.Proto.SigningInput.utxo: array expected");
                            message.utxo = [];
                            for (var i = 0; i < object.utxo.length; ++i) {
                                if (typeof object.utxo[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.SigningInput.utxo: object expected");
                                message.utxo[i] = $root.TW.Bitcoin.Proto.UnspentTransaction.fromObject(object.utxo[i]);
                            }
                        }
                        if (object.useMaxAmount != null)
                            message.useMaxAmount = Boolean(object.useMaxAmount);
                        if (object.coinType != null)
                            message.coinType = object.coinType >>> 0;
                        if (object.plan != null) {
                            if (typeof object.plan !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.SigningInput.plan: object expected");
                            message.plan = $root.TW.Bitcoin.Proto.TransactionPlan.fromObject(object.plan);
                        }
                        if (object.lockTime != null)
                            message.lockTime = object.lockTime >>> 0;
                        if (object.outputOpReturn != null)
                            if (typeof object.outputOpReturn === "string")
                                $util.base64.decode(object.outputOpReturn, message.outputOpReturn = $util.newBuffer($util.base64.length(object.outputOpReturn)), 0);
                            else if (object.outputOpReturn.length)
                                message.outputOpReturn = object.outputOpReturn;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {TW.Bitcoin.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.privateKey = [];
                            object.utxo = [];
                        }
                        if (options.objects || options.defaults)
                            object.scripts = {};
                        if (options.defaults) {
                            object.hashType = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.byteFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.byteFee = options.longs === String ? "0" : 0;
                            object.toAddress = "";
                            object.changeAddress = "";
                            object.useMaxAmount = false;
                            object.coinType = 0;
                            object.plan = null;
                            object.lockTime = 0;
                            if (options.bytes === String)
                                object.outputOpReturn = "";
                            else {
                                object.outputOpReturn = [];
                                if (options.bytes !== Array)
                                    object.outputOpReturn = $util.newBuffer(object.outputOpReturn);
                            }
                        }
                        if (message.hashType != null && message.hasOwnProperty("hashType"))
                            object.hashType = message.hashType;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.byteFee != null && message.hasOwnProperty("byteFee"))
                            if (typeof message.byteFee === "number")
                                object.byteFee = options.longs === String ? String(message.byteFee) : message.byteFee;
                            else
                                object.byteFee = options.longs === String ? $util.Long.prototype.toString.call(message.byteFee) : options.longs === Number ? new $util.LongBits(message.byteFee.low >>> 0, message.byteFee.high >>> 0).toNumber() : message.byteFee;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            object.changeAddress = message.changeAddress;
                        if (message.privateKey && message.privateKey.length) {
                            object.privateKey = [];
                            for (var j = 0; j < message.privateKey.length; ++j)
                                object.privateKey[j] = options.bytes === String ? $util.base64.encode(message.privateKey[j], 0, message.privateKey[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey[j]) : message.privateKey[j];
                        }
                        var keys2;
                        if (message.scripts && (keys2 = Object.keys(message.scripts)).length) {
                            object.scripts = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.scripts[keys2[j]] = options.bytes === String ? $util.base64.encode(message.scripts[keys2[j]], 0, message.scripts[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.scripts[keys2[j]]) : message.scripts[keys2[j]];
                        }
                        if (message.utxo && message.utxo.length) {
                            object.utxo = [];
                            for (var j = 0; j < message.utxo.length; ++j)
                                object.utxo[j] = $root.TW.Bitcoin.Proto.UnspentTransaction.toObject(message.utxo[j], options);
                        }
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            object.useMaxAmount = message.useMaxAmount;
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            object.coinType = message.coinType;
                        if (message.plan != null && message.hasOwnProperty("plan"))
                            object.plan = $root.TW.Bitcoin.Proto.TransactionPlan.toObject(message.plan, options);
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            object.lockTime = message.lockTime;
                        if (message.outputOpReturn != null && message.hasOwnProperty("outputOpReturn"))
                            object.outputOpReturn = options.bytes === String ? $util.base64.encode(message.outputOpReturn, 0, message.outputOpReturn.length) : options.bytes === Array ? Array.prototype.slice.call(message.outputOpReturn) : message.outputOpReturn;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.TransactionPlan = (function() {
    
                    /**
                     * Properties of a TransactionPlan.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransactionPlan
                     * @property {Long|null} [amount] TransactionPlan amount
                     * @property {Long|null} [availableAmount] TransactionPlan availableAmount
                     * @property {Long|null} [fee] TransactionPlan fee
                     * @property {Long|null} [change] TransactionPlan change
                     * @property {Array.<TW.Bitcoin.Proto.IUnspentTransaction>|null} [utxos] TransactionPlan utxos
                     * @property {Uint8Array|null} [branchId] TransactionPlan branchId
                     * @property {TW.Common.Proto.SigningError|null} [error] TransactionPlan error
                     * @property {Uint8Array|null} [outputOpReturn] TransactionPlan outputOpReturn
                     */
    
                    /**
                     * Constructs a new TransactionPlan.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a TransactionPlan.
                     * @implements ITransactionPlan
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransactionPlan=} [properties] Properties to set
                     */
                    function TransactionPlan(properties) {
                        this.utxos = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionPlan amount.
                     * @member {Long} amount
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan availableAmount.
                     * @member {Long} availableAmount
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.availableAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan fee.
                     * @member {Long} fee
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan change.
                     * @member {Long} change
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.change = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan utxos.
                     * @member {Array.<TW.Bitcoin.Proto.IUnspentTransaction>} utxos
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.utxos = $util.emptyArray;
    
                    /**
                     * TransactionPlan branchId.
                     * @member {Uint8Array} branchId
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.branchId = $util.newBuffer([]);
    
                    /**
                     * TransactionPlan error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.error = 0;
    
                    /**
                     * TransactionPlan outputOpReturn.
                     * @member {Uint8Array} outputOpReturn
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.outputOpReturn = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionPlan instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionPlan=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.TransactionPlan} TransactionPlan instance
                     */
                    TransactionPlan.create = function create(properties) {
                        return new TransactionPlan(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionPlan.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionPlan} message TransactionPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPlan.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.availableAmount != null && Object.hasOwnProperty.call(message, "availableAmount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.availableAmount);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.change != null && Object.hasOwnProperty.call(message, "change"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.change);
                        if (message.utxos != null && message.utxos.length)
                            for (var i = 0; i < message.utxos.length; ++i)
                                $root.TW.Bitcoin.Proto.UnspentTransaction.encode(message.utxos[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.branchId != null && Object.hasOwnProperty.call(message, "branchId"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.branchId);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.error);
                        if (message.outputOpReturn != null && Object.hasOwnProperty.call(message, "outputOpReturn"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.outputOpReturn);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionPlan message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.TransactionPlan} TransactionPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPlan.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.TransactionPlan();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.availableAmount = reader.int64();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.change = reader.int64();
                                break;
                            case 5:
                                if (!(message.utxos && message.utxos.length))
                                    message.utxos = [];
                                message.utxos.push($root.TW.Bitcoin.Proto.UnspentTransaction.decode(reader, reader.uint32()));
                                break;
                            case 6:
                                message.branchId = reader.bytes();
                                break;
                            case 7:
                                message.error = reader.int32();
                                break;
                            case 8:
                                message.outputOpReturn = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionPlan message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionPlan.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (!$util.isInteger(message.availableAmount) && !(message.availableAmount && $util.isInteger(message.availableAmount.low) && $util.isInteger(message.availableAmount.high)))
                                return "availableAmount: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (!$util.isInteger(message.change) && !(message.change && $util.isInteger(message.change.low) && $util.isInteger(message.change.high)))
                                return "change: integer|Long expected";
                        if (message.utxos != null && message.hasOwnProperty("utxos")) {
                            if (!Array.isArray(message.utxos))
                                return "utxos: array expected";
                            for (var i = 0; i < message.utxos.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.UnspentTransaction.verify(message.utxos[i]);
                                if (error)
                                    return "utxos." + error;
                            }
                        }
                        if (message.branchId != null && message.hasOwnProperty("branchId"))
                            if (!(message.branchId && typeof message.branchId.length === "number" || $util.isString(message.branchId)))
                                return "branchId: buffer expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        if (message.outputOpReturn != null && message.hasOwnProperty("outputOpReturn"))
                            if (!(message.outputOpReturn && typeof message.outputOpReturn.length === "number" || $util.isString(message.outputOpReturn)))
                                return "outputOpReturn: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.TransactionPlan} TransactionPlan
                     */
                    TransactionPlan.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.TransactionPlan)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.TransactionPlan();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.availableAmount != null)
                            if ($util.Long)
                                (message.availableAmount = $util.Long.fromValue(object.availableAmount)).unsigned = false;
                            else if (typeof object.availableAmount === "string")
                                message.availableAmount = parseInt(object.availableAmount, 10);
                            else if (typeof object.availableAmount === "number")
                                message.availableAmount = object.availableAmount;
                            else if (typeof object.availableAmount === "object")
                                message.availableAmount = new $util.LongBits(object.availableAmount.low >>> 0, object.availableAmount.high >>> 0).toNumber();
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.change != null)
                            if ($util.Long)
                                (message.change = $util.Long.fromValue(object.change)).unsigned = false;
                            else if (typeof object.change === "string")
                                message.change = parseInt(object.change, 10);
                            else if (typeof object.change === "number")
                                message.change = object.change;
                            else if (typeof object.change === "object")
                                message.change = new $util.LongBits(object.change.low >>> 0, object.change.high >>> 0).toNumber();
                        if (object.utxos) {
                            if (!Array.isArray(object.utxos))
                                throw TypeError(".TW.Bitcoin.Proto.TransactionPlan.utxos: array expected");
                            message.utxos = [];
                            for (var i = 0; i < object.utxos.length; ++i) {
                                if (typeof object.utxos[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.TransactionPlan.utxos: object expected");
                                message.utxos[i] = $root.TW.Bitcoin.Proto.UnspentTransaction.fromObject(object.utxos[i]);
                            }
                        }
                        if (object.branchId != null)
                            if (typeof object.branchId === "string")
                                $util.base64.decode(object.branchId, message.branchId = $util.newBuffer($util.base64.length(object.branchId)), 0);
                            else if (object.branchId.length)
                                message.branchId = object.branchId;
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        if (object.outputOpReturn != null)
                            if (typeof object.outputOpReturn === "string")
                                $util.base64.decode(object.outputOpReturn, message.outputOpReturn = $util.newBuffer($util.base64.length(object.outputOpReturn)), 0);
                            else if (object.outputOpReturn.length)
                                message.outputOpReturn = object.outputOpReturn;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {TW.Bitcoin.Proto.TransactionPlan} message TransactionPlan
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionPlan.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.utxos = [];
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.availableAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.availableAmount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.change = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.change = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.branchId = "";
                            else {
                                object.branchId = [];
                                if (options.bytes !== Array)
                                    object.branchId = $util.newBuffer(object.branchId);
                            }
                            object.error = options.enums === String ? "OK" : 0;
                            if (options.bytes === String)
                                object.outputOpReturn = "";
                            else {
                                object.outputOpReturn = [];
                                if (options.bytes !== Array)
                                    object.outputOpReturn = $util.newBuffer(object.outputOpReturn);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (typeof message.availableAmount === "number")
                                object.availableAmount = options.longs === String ? String(message.availableAmount) : message.availableAmount;
                            else
                                object.availableAmount = options.longs === String ? $util.Long.prototype.toString.call(message.availableAmount) : options.longs === Number ? new $util.LongBits(message.availableAmount.low >>> 0, message.availableAmount.high >>> 0).toNumber() : message.availableAmount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (typeof message.change === "number")
                                object.change = options.longs === String ? String(message.change) : message.change;
                            else
                                object.change = options.longs === String ? $util.Long.prototype.toString.call(message.change) : options.longs === Number ? new $util.LongBits(message.change.low >>> 0, message.change.high >>> 0).toNumber() : message.change;
                        if (message.utxos && message.utxos.length) {
                            object.utxos = [];
                            for (var j = 0; j < message.utxos.length; ++j)
                                object.utxos[j] = $root.TW.Bitcoin.Proto.UnspentTransaction.toObject(message.utxos[j], options);
                        }
                        if (message.branchId != null && message.hasOwnProperty("branchId"))
                            object.branchId = options.bytes === String ? $util.base64.encode(message.branchId, 0, message.branchId.length) : options.bytes === Array ? Array.prototype.slice.call(message.branchId) : message.branchId;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        if (message.outputOpReturn != null && message.hasOwnProperty("outputOpReturn"))
                            object.outputOpReturn = options.bytes === String ? $util.base64.encode(message.outputOpReturn, 0, message.outputOpReturn.length) : options.bytes === Array ? Array.prototype.slice.call(message.outputOpReturn) : message.outputOpReturn;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionPlan to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionPlan.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionPlan;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ISigningOutput
                     * @property {TW.Bitcoin.Proto.ITransaction|null} [transaction] SigningOutput transaction
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {string|null} [transactionId] SigningOutput transactionId
                     * @property {TW.Common.Proto.SigningError|null} [error] SigningOutput error
                     * @property {string|null} [errorMessage] SigningOutput errorMessage
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput transaction.
                     * @member {TW.Bitcoin.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transaction = null;
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput transactionId.
                     * @member {string} transactionId
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transactionId = "";
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * SigningOutput errorMessage.
                     * @member {string} errorMessage
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.errorMessage = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Bitcoin.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                            $root.TW.Bitcoin.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encoded);
                        if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.transactionId);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.error);
                        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.errorMessage);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.TW.Bitcoin.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.encoded = reader.bytes();
                                break;
                            case 3:
                                message.transactionId = reader.string();
                                break;
                            case 4:
                                message.error = reader.int32();
                                break;
                            case 5:
                                message.errorMessage = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Bitcoin.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            if (!$util.isString(message.transactionId))
                                return "transactionId: string expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            if (!$util.isString(message.errorMessage))
                                return "errorMessage: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.SigningOutput();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.SigningOutput.transaction: object expected");
                            message.transaction = $root.TW.Bitcoin.Proto.Transaction.fromObject(object.transaction);
                        }
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.transactionId != null)
                            message.transactionId = String(object.transactionId);
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        if (object.errorMessage != null)
                            message.errorMessage = String(object.errorMessage);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            object.transactionId = "";
                            object.error = options.enums === String ? "OK" : 0;
                            object.errorMessage = "";
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Bitcoin.Proto.Transaction.toObject(message.transaction, options);
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            object.transactionId = message.transactionId;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            object.errorMessage = message.errorMessage;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.HashPublicKey = (function() {
    
                    /**
                     * Properties of a HashPublicKey.
                     * @memberof TW.Bitcoin.Proto
                     * @interface IHashPublicKey
                     * @property {Uint8Array|null} [dataHash] Pre-image data hash that will be used for signing
                     * @property {Uint8Array|null} [publicKeyHash] public key hash used for signing
                     */
    
                    /**
                     * Constructs a new HashPublicKey.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a HashPublicKey.
                     * @implements IHashPublicKey
                     * @constructor
                     * @param {TW.Bitcoin.Proto.IHashPublicKey=} [properties] Properties to set
                     */
                    function HashPublicKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Pre-image data hash that will be used for signing
                     * @member {Uint8Array} dataHash
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @instance
                     */
                    HashPublicKey.prototype.dataHash = $util.newBuffer([]);
    
                    /**
                     * public key hash used for signing
                     * @member {Uint8Array} publicKeyHash
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @instance
                     */
                    HashPublicKey.prototype.publicKeyHash = $util.newBuffer([]);
    
                    /**
                     * Creates a new HashPublicKey instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @static
                     * @param {TW.Bitcoin.Proto.IHashPublicKey=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.HashPublicKey} HashPublicKey instance
                     */
                    HashPublicKey.create = function create(properties) {
                        return new HashPublicKey(properties);
                    };
    
                    /**
                     * Encodes the specified HashPublicKey message. Does not implicitly {@link TW.Bitcoin.Proto.HashPublicKey.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @static
                     * @param {TW.Bitcoin.Proto.IHashPublicKey} message HashPublicKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HashPublicKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.dataHash != null && Object.hasOwnProperty.call(message, "dataHash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.dataHash);
                        if (message.publicKeyHash != null && Object.hasOwnProperty.call(message, "publicKeyHash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKeyHash);
                        return writer;
                    };
    
                    /**
                     * Decodes a HashPublicKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.HashPublicKey} HashPublicKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HashPublicKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.HashPublicKey();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.dataHash = reader.bytes();
                                break;
                            case 2:
                                message.publicKeyHash = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a HashPublicKey message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    HashPublicKey.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                            if (!(message.dataHash && typeof message.dataHash.length === "number" || $util.isString(message.dataHash)))
                                return "dataHash: buffer expected";
                        if (message.publicKeyHash != null && message.hasOwnProperty("publicKeyHash"))
                            if (!(message.publicKeyHash && typeof message.publicKeyHash.length === "number" || $util.isString(message.publicKeyHash)))
                                return "publicKeyHash: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a HashPublicKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.HashPublicKey} HashPublicKey
                     */
                    HashPublicKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.HashPublicKey)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.HashPublicKey();
                        if (object.dataHash != null)
                            if (typeof object.dataHash === "string")
                                $util.base64.decode(object.dataHash, message.dataHash = $util.newBuffer($util.base64.length(object.dataHash)), 0);
                            else if (object.dataHash.length)
                                message.dataHash = object.dataHash;
                        if (object.publicKeyHash != null)
                            if (typeof object.publicKeyHash === "string")
                                $util.base64.decode(object.publicKeyHash, message.publicKeyHash = $util.newBuffer($util.base64.length(object.publicKeyHash)), 0);
                            else if (object.publicKeyHash.length)
                                message.publicKeyHash = object.publicKeyHash;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a HashPublicKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @static
                     * @param {TW.Bitcoin.Proto.HashPublicKey} message HashPublicKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HashPublicKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.dataHash = "";
                            else {
                                object.dataHash = [];
                                if (options.bytes !== Array)
                                    object.dataHash = $util.newBuffer(object.dataHash);
                            }
                            if (options.bytes === String)
                                object.publicKeyHash = "";
                            else {
                                object.publicKeyHash = [];
                                if (options.bytes !== Array)
                                    object.publicKeyHash = $util.newBuffer(object.publicKeyHash);
                            }
                        }
                        if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                            object.dataHash = options.bytes === String ? $util.base64.encode(message.dataHash, 0, message.dataHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.dataHash) : message.dataHash;
                        if (message.publicKeyHash != null && message.hasOwnProperty("publicKeyHash"))
                            object.publicKeyHash = options.bytes === String ? $util.base64.encode(message.publicKeyHash, 0, message.publicKeyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKeyHash) : message.publicKeyHash;
                        return object;
                    };
    
                    /**
                     * Converts this HashPublicKey to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.HashPublicKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    HashPublicKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return HashPublicKey;
                })();
    
                Proto.PreSigningOutput = (function() {
    
                    /**
                     * Properties of a PreSigningOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface IPreSigningOutput
                     * @property {Array.<TW.Bitcoin.Proto.IHashPublicKey>|null} [hashPublicKeys] hash, public key list
                     * @property {TW.Common.Proto.SigningError|null} [error] error code, 0 is ok, other codes will be treated as errors
                     * @property {string|null} [errorMessage] error description
                     */
    
                    /**
                     * Constructs a new PreSigningOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Transaction pre-signing output
                     * @implements IPreSigningOutput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.IPreSigningOutput=} [properties] Properties to set
                     */
                    function PreSigningOutput(properties) {
                        this.hashPublicKeys = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * hash, public key list
                     * @member {Array.<TW.Bitcoin.Proto.IHashPublicKey>} hashPublicKeys
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @instance
                     */
                    PreSigningOutput.prototype.hashPublicKeys = $util.emptyArray;
    
                    /**
                     * error code, 0 is ok, other codes will be treated as errors
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @instance
                     */
                    PreSigningOutput.prototype.error = 0;
    
                    /**
                     * error description
                     * @member {string} errorMessage
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @instance
                     */
                    PreSigningOutput.prototype.errorMessage = "";
    
                    /**
                     * Creates a new PreSigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.IPreSigningOutput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.PreSigningOutput} PreSigningOutput instance
                     */
                    PreSigningOutput.create = function create(properties) {
                        return new PreSigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified PreSigningOutput message. Does not implicitly {@link TW.Bitcoin.Proto.PreSigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.IPreSigningOutput} message PreSigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PreSigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hashPublicKeys != null && message.hashPublicKeys.length)
                            for (var i = 0; i < message.hashPublicKeys.length; ++i)
                                $root.TW.Bitcoin.Proto.HashPublicKey.encode(message.hashPublicKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.error);
                        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMessage);
                        return writer;
                    };
    
                    /**
                     * Decodes a PreSigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.PreSigningOutput} PreSigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PreSigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.PreSigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.hashPublicKeys && message.hashPublicKeys.length))
                                    message.hashPublicKeys = [];
                                message.hashPublicKeys.push($root.TW.Bitcoin.Proto.HashPublicKey.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.error = reader.int32();
                                break;
                            case 3:
                                message.errorMessage = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a PreSigningOutput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PreSigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hashPublicKeys != null && message.hasOwnProperty("hashPublicKeys")) {
                            if (!Array.isArray(message.hashPublicKeys))
                                return "hashPublicKeys: array expected";
                            for (var i = 0; i < message.hashPublicKeys.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.HashPublicKey.verify(message.hashPublicKeys[i]);
                                if (error)
                                    return "hashPublicKeys." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            if (!$util.isString(message.errorMessage))
                                return "errorMessage: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a PreSigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.PreSigningOutput} PreSigningOutput
                     */
                    PreSigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.PreSigningOutput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.PreSigningOutput();
                        if (object.hashPublicKeys) {
                            if (!Array.isArray(object.hashPublicKeys))
                                throw TypeError(".TW.Bitcoin.Proto.PreSigningOutput.hashPublicKeys: array expected");
                            message.hashPublicKeys = [];
                            for (var i = 0; i < object.hashPublicKeys.length; ++i) {
                                if (typeof object.hashPublicKeys[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.PreSigningOutput.hashPublicKeys: object expected");
                                message.hashPublicKeys[i] = $root.TW.Bitcoin.Proto.HashPublicKey.fromObject(object.hashPublicKeys[i]);
                            }
                        }
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        if (object.errorMessage != null)
                            message.errorMessage = String(object.errorMessage);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a PreSigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.PreSigningOutput} message PreSigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PreSigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.hashPublicKeys = [];
                        if (options.defaults) {
                            object.error = options.enums === String ? "OK" : 0;
                            object.errorMessage = "";
                        }
                        if (message.hashPublicKeys && message.hashPublicKeys.length) {
                            object.hashPublicKeys = [];
                            for (var j = 0; j < message.hashPublicKeys.length; ++j)
                                object.hashPublicKeys[j] = $root.TW.Bitcoin.Proto.HashPublicKey.toObject(message.hashPublicKeys[j], options);
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            object.errorMessage = message.errorMessage;
                        return object;
                    };
    
                    /**
                     * Converts this PreSigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.PreSigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PreSigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PreSigningOutput;
                })();
    
                return Proto;
            })();
    
            return Bitcoin;
        })();
    
        TW.Cardano = (function() {
    
            /**
             * Namespace Cardano.
             * @memberof TW
             * @namespace
             */
            var Cardano = {};
    
            Cardano.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Cardano
                 * @namespace
                 */
                var Proto = {};
    
                Proto.OutPoint = (function() {
    
                    /**
                     * Properties of an OutPoint.
                     * @memberof TW.Cardano.Proto
                     * @interface IOutPoint
                     * @property {Uint8Array|null} [txHash] OutPoint txHash
                     * @property {Long|null} [outputIndex] OutPoint outputIndex
                     */
    
                    /**
                     * Constructs a new OutPoint.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents an OutPoint.
                     * @implements IOutPoint
                     * @constructor
                     * @param {TW.Cardano.Proto.IOutPoint=} [properties] Properties to set
                     */
                    function OutPoint(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OutPoint txHash.
                     * @member {Uint8Array} txHash
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.txHash = $util.newBuffer([]);
    
                    /**
                     * OutPoint outputIndex.
                     * @member {Long} outputIndex
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.outputIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new OutPoint instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @static
                     * @param {TW.Cardano.Proto.IOutPoint=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.OutPoint} OutPoint instance
                     */
                    OutPoint.create = function create(properties) {
                        return new OutPoint(properties);
                    };
    
                    /**
                     * Encodes the specified OutPoint message. Does not implicitly {@link TW.Cardano.Proto.OutPoint.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @static
                     * @param {TW.Cardano.Proto.IOutPoint} message OutPoint message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OutPoint.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.txHash != null && Object.hasOwnProperty.call(message, "txHash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txHash);
                        if (message.outputIndex != null && Object.hasOwnProperty.call(message, "outputIndex"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.outputIndex);
                        return writer;
                    };
    
                    /**
                     * Decodes an OutPoint message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.OutPoint} OutPoint
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OutPoint.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.OutPoint();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.txHash = reader.bytes();
                                break;
                            case 2:
                                message.outputIndex = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OutPoint message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OutPoint.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.txHash != null && message.hasOwnProperty("txHash"))
                            if (!(message.txHash && typeof message.txHash.length === "number" || $util.isString(message.txHash)))
                                return "txHash: buffer expected";
                        if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                            if (!$util.isInteger(message.outputIndex) && !(message.outputIndex && $util.isInteger(message.outputIndex.low) && $util.isInteger(message.outputIndex.high)))
                                return "outputIndex: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.OutPoint} OutPoint
                     */
                    OutPoint.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.OutPoint)
                            return object;
                        var message = new $root.TW.Cardano.Proto.OutPoint();
                        if (object.txHash != null)
                            if (typeof object.txHash === "string")
                                $util.base64.decode(object.txHash, message.txHash = $util.newBuffer($util.base64.length(object.txHash)), 0);
                            else if (object.txHash.length)
                                message.txHash = object.txHash;
                        if (object.outputIndex != null)
                            if ($util.Long)
                                (message.outputIndex = $util.Long.fromValue(object.outputIndex)).unsigned = true;
                            else if (typeof object.outputIndex === "string")
                                message.outputIndex = parseInt(object.outputIndex, 10);
                            else if (typeof object.outputIndex === "number")
                                message.outputIndex = object.outputIndex;
                            else if (typeof object.outputIndex === "object")
                                message.outputIndex = new $util.LongBits(object.outputIndex.low >>> 0, object.outputIndex.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @static
                     * @param {TW.Cardano.Proto.OutPoint} message OutPoint
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OutPoint.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.txHash = "";
                            else {
                                object.txHash = [];
                                if (options.bytes !== Array)
                                    object.txHash = $util.newBuffer(object.txHash);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.outputIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.outputIndex = options.longs === String ? "0" : 0;
                        }
                        if (message.txHash != null && message.hasOwnProperty("txHash"))
                            object.txHash = options.bytes === String ? $util.base64.encode(message.txHash, 0, message.txHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.txHash) : message.txHash;
                        if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                            if (typeof message.outputIndex === "number")
                                object.outputIndex = options.longs === String ? String(message.outputIndex) : message.outputIndex;
                            else
                                object.outputIndex = options.longs === String ? $util.Long.prototype.toString.call(message.outputIndex) : options.longs === Number ? new $util.LongBits(message.outputIndex.low >>> 0, message.outputIndex.high >>> 0).toNumber(true) : message.outputIndex;
                        return object;
                    };
    
                    /**
                     * Converts this OutPoint to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.OutPoint
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OutPoint.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OutPoint;
                })();
    
                Proto.TokenAmount = (function() {
    
                    /**
                     * Properties of a TokenAmount.
                     * @memberof TW.Cardano.Proto
                     * @interface ITokenAmount
                     * @property {string|null} [policyId] TokenAmount policyId
                     * @property {string|null} [assetName] TokenAmount assetName
                     * @property {Uint8Array|null} [amount] TokenAmount amount
                     */
    
                    /**
                     * Constructs a new TokenAmount.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a TokenAmount.
                     * @implements ITokenAmount
                     * @constructor
                     * @param {TW.Cardano.Proto.ITokenAmount=} [properties] Properties to set
                     */
                    function TokenAmount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenAmount policyId.
                     * @member {string} policyId
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @instance
                     */
                    TokenAmount.prototype.policyId = "";
    
                    /**
                     * TokenAmount assetName.
                     * @member {string} assetName
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @instance
                     */
                    TokenAmount.prototype.assetName = "";
    
                    /**
                     * TokenAmount amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @instance
                     */
                    TokenAmount.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * Creates a new TokenAmount instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @static
                     * @param {TW.Cardano.Proto.ITokenAmount=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.TokenAmount} TokenAmount instance
                     */
                    TokenAmount.create = function create(properties) {
                        return new TokenAmount(properties);
                    };
    
                    /**
                     * Encodes the specified TokenAmount message. Does not implicitly {@link TW.Cardano.Proto.TokenAmount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @static
                     * @param {TW.Cardano.Proto.ITokenAmount} message TokenAmount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenAmount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.policyId != null && Object.hasOwnProperty.call(message, "policyId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.policyId);
                        if (message.assetName != null && Object.hasOwnProperty.call(message, "assetName"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.assetName);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenAmount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.TokenAmount} TokenAmount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenAmount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.TokenAmount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.policyId = reader.string();
                                break;
                            case 2:
                                message.assetName = reader.string();
                                break;
                            case 3:
                                message.amount = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenAmount message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenAmount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.policyId != null && message.hasOwnProperty("policyId"))
                            if (!$util.isString(message.policyId))
                                return "policyId: string expected";
                        if (message.assetName != null && message.hasOwnProperty("assetName"))
                            if (!$util.isString(message.assetName))
                                return "assetName: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenAmount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.TokenAmount} TokenAmount
                     */
                    TokenAmount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.TokenAmount)
                            return object;
                        var message = new $root.TW.Cardano.Proto.TokenAmount();
                        if (object.policyId != null)
                            message.policyId = String(object.policyId);
                        if (object.assetName != null)
                            message.assetName = String(object.assetName);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenAmount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @static
                     * @param {TW.Cardano.Proto.TokenAmount} message TokenAmount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenAmount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.policyId = "";
                            object.assetName = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                        }
                        if (message.policyId != null && message.hasOwnProperty("policyId"))
                            object.policyId = message.policyId;
                        if (message.assetName != null && message.hasOwnProperty("assetName"))
                            object.assetName = message.assetName;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TokenAmount to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.TokenAmount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenAmount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenAmount;
                })();
    
                Proto.TxInput = (function() {
    
                    /**
                     * Properties of a TxInput.
                     * @memberof TW.Cardano.Proto
                     * @interface ITxInput
                     * @property {TW.Cardano.Proto.IOutPoint|null} [outPoint] TxInput outPoint
                     * @property {string|null} [address] TxInput address
                     * @property {Long|null} [amount] TxInput amount
                     * @property {Array.<TW.Cardano.Proto.ITokenAmount>|null} [tokenAmount] TxInput tokenAmount
                     */
    
                    /**
                     * Constructs a new TxInput.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a TxInput.
                     * @implements ITxInput
                     * @constructor
                     * @param {TW.Cardano.Proto.ITxInput=} [properties] Properties to set
                     */
                    function TxInput(properties) {
                        this.tokenAmount = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TxInput outPoint.
                     * @member {TW.Cardano.Proto.IOutPoint|null|undefined} outPoint
                     * @memberof TW.Cardano.Proto.TxInput
                     * @instance
                     */
                    TxInput.prototype.outPoint = null;
    
                    /**
                     * TxInput address.
                     * @member {string} address
                     * @memberof TW.Cardano.Proto.TxInput
                     * @instance
                     */
                    TxInput.prototype.address = "";
    
                    /**
                     * TxInput amount.
                     * @member {Long} amount
                     * @memberof TW.Cardano.Proto.TxInput
                     * @instance
                     */
                    TxInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TxInput tokenAmount.
                     * @member {Array.<TW.Cardano.Proto.ITokenAmount>} tokenAmount
                     * @memberof TW.Cardano.Proto.TxInput
                     * @instance
                     */
                    TxInput.prototype.tokenAmount = $util.emptyArray;
    
                    /**
                     * Creates a new TxInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.TxInput
                     * @static
                     * @param {TW.Cardano.Proto.ITxInput=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.TxInput} TxInput instance
                     */
                    TxInput.create = function create(properties) {
                        return new TxInput(properties);
                    };
    
                    /**
                     * Encodes the specified TxInput message. Does not implicitly {@link TW.Cardano.Proto.TxInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.TxInput
                     * @static
                     * @param {TW.Cardano.Proto.ITxInput} message TxInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TxInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.outPoint != null && Object.hasOwnProperty.call(message, "outPoint"))
                            $root.TW.Cardano.Proto.OutPoint.encode(message.outPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amount);
                        if (message.tokenAmount != null && message.tokenAmount.length)
                            for (var i = 0; i < message.tokenAmount.length; ++i)
                                $root.TW.Cardano.Proto.TokenAmount.encode(message.tokenAmount[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a TxInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.TxInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.TxInput} TxInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TxInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.TxInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.outPoint = $root.TW.Cardano.Proto.OutPoint.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.address = reader.string();
                                break;
                            case 3:
                                message.amount = reader.uint64();
                                break;
                            case 4:
                                if (!(message.tokenAmount && message.tokenAmount.length))
                                    message.tokenAmount = [];
                                message.tokenAmount.push($root.TW.Cardano.Proto.TokenAmount.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TxInput message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.TxInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TxInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.outPoint != null && message.hasOwnProperty("outPoint")) {
                            var error = $root.TW.Cardano.Proto.OutPoint.verify(message.outPoint);
                            if (error)
                                return "outPoint." + error;
                        }
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!$util.isString(message.address))
                                return "address: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.tokenAmount != null && message.hasOwnProperty("tokenAmount")) {
                            if (!Array.isArray(message.tokenAmount))
                                return "tokenAmount: array expected";
                            for (var i = 0; i < message.tokenAmount.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TokenAmount.verify(message.tokenAmount[i]);
                                if (error)
                                    return "tokenAmount." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a TxInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.TxInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.TxInput} TxInput
                     */
                    TxInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.TxInput)
                            return object;
                        var message = new $root.TW.Cardano.Proto.TxInput();
                        if (object.outPoint != null) {
                            if (typeof object.outPoint !== "object")
                                throw TypeError(".TW.Cardano.Proto.TxInput.outPoint: object expected");
                            message.outPoint = $root.TW.Cardano.Proto.OutPoint.fromObject(object.outPoint);
                        }
                        if (object.address != null)
                            message.address = String(object.address);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.tokenAmount) {
                            if (!Array.isArray(object.tokenAmount))
                                throw TypeError(".TW.Cardano.Proto.TxInput.tokenAmount: array expected");
                            message.tokenAmount = [];
                            for (var i = 0; i < object.tokenAmount.length; ++i) {
                                if (typeof object.tokenAmount[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.TxInput.tokenAmount: object expected");
                                message.tokenAmount[i] = $root.TW.Cardano.Proto.TokenAmount.fromObject(object.tokenAmount[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TxInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.TxInput
                     * @static
                     * @param {TW.Cardano.Proto.TxInput} message TxInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TxInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.tokenAmount = [];
                        if (options.defaults) {
                            object.outPoint = null;
                            object.address = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.outPoint != null && message.hasOwnProperty("outPoint"))
                            object.outPoint = $root.TW.Cardano.Proto.OutPoint.toObject(message.outPoint, options);
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = message.address;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.tokenAmount && message.tokenAmount.length) {
                            object.tokenAmount = [];
                            for (var j = 0; j < message.tokenAmount.length; ++j)
                                object.tokenAmount[j] = $root.TW.Cardano.Proto.TokenAmount.toObject(message.tokenAmount[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this TxInput to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.TxInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TxInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TxInput;
                })();
    
                Proto.TxOutput = (function() {
    
                    /**
                     * Properties of a TxOutput.
                     * @memberof TW.Cardano.Proto
                     * @interface ITxOutput
                     * @property {string|null} [address] TxOutput address
                     * @property {Long|null} [amount] TxOutput amount
                     * @property {Array.<TW.Cardano.Proto.ITokenAmount>|null} [tokenAmount] TxOutput tokenAmount
                     */
    
                    /**
                     * Constructs a new TxOutput.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a TxOutput.
                     * @implements ITxOutput
                     * @constructor
                     * @param {TW.Cardano.Proto.ITxOutput=} [properties] Properties to set
                     */
                    function TxOutput(properties) {
                        this.tokenAmount = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TxOutput address.
                     * @member {string} address
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @instance
                     */
                    TxOutput.prototype.address = "";
    
                    /**
                     * TxOutput amount.
                     * @member {Long} amount
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @instance
                     */
                    TxOutput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TxOutput tokenAmount.
                     * @member {Array.<TW.Cardano.Proto.ITokenAmount>} tokenAmount
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @instance
                     */
                    TxOutput.prototype.tokenAmount = $util.emptyArray;
    
                    /**
                     * Creates a new TxOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @static
                     * @param {TW.Cardano.Proto.ITxOutput=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.TxOutput} TxOutput instance
                     */
                    TxOutput.create = function create(properties) {
                        return new TxOutput(properties);
                    };
    
                    /**
                     * Encodes the specified TxOutput message. Does not implicitly {@link TW.Cardano.Proto.TxOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @static
                     * @param {TW.Cardano.Proto.ITxOutput} message TxOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TxOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
                        if (message.tokenAmount != null && message.tokenAmount.length)
                            for (var i = 0; i < message.tokenAmount.length; ++i)
                                $root.TW.Cardano.Proto.TokenAmount.encode(message.tokenAmount[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a TxOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.TxOutput} TxOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TxOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.TxOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.address = reader.string();
                                break;
                            case 2:
                                message.amount = reader.uint64();
                                break;
                            case 3:
                                if (!(message.tokenAmount && message.tokenAmount.length))
                                    message.tokenAmount = [];
                                message.tokenAmount.push($root.TW.Cardano.Proto.TokenAmount.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TxOutput message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TxOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!$util.isString(message.address))
                                return "address: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.tokenAmount != null && message.hasOwnProperty("tokenAmount")) {
                            if (!Array.isArray(message.tokenAmount))
                                return "tokenAmount: array expected";
                            for (var i = 0; i < message.tokenAmount.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TokenAmount.verify(message.tokenAmount[i]);
                                if (error)
                                    return "tokenAmount." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a TxOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.TxOutput} TxOutput
                     */
                    TxOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.TxOutput)
                            return object;
                        var message = new $root.TW.Cardano.Proto.TxOutput();
                        if (object.address != null)
                            message.address = String(object.address);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.tokenAmount) {
                            if (!Array.isArray(object.tokenAmount))
                                throw TypeError(".TW.Cardano.Proto.TxOutput.tokenAmount: array expected");
                            message.tokenAmount = [];
                            for (var i = 0; i < object.tokenAmount.length; ++i) {
                                if (typeof object.tokenAmount[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.TxOutput.tokenAmount: object expected");
                                message.tokenAmount[i] = $root.TW.Cardano.Proto.TokenAmount.fromObject(object.tokenAmount[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TxOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @static
                     * @param {TW.Cardano.Proto.TxOutput} message TxOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TxOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.tokenAmount = [];
                        if (options.defaults) {
                            object.address = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = message.address;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.tokenAmount && message.tokenAmount.length) {
                            object.tokenAmount = [];
                            for (var j = 0; j < message.tokenAmount.length; ++j)
                                object.tokenAmount[j] = $root.TW.Cardano.Proto.TokenAmount.toObject(message.tokenAmount[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this TxOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.TxOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TxOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TxOutput;
                })();
    
                Proto.TokenBundle = (function() {
    
                    /**
                     * Properties of a TokenBundle.
                     * @memberof TW.Cardano.Proto
                     * @interface ITokenBundle
                     * @property {Array.<TW.Cardano.Proto.ITokenAmount>|null} [token] TokenBundle token
                     */
    
                    /**
                     * Constructs a new TokenBundle.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a TokenBundle.
                     * @implements ITokenBundle
                     * @constructor
                     * @param {TW.Cardano.Proto.ITokenBundle=} [properties] Properties to set
                     */
                    function TokenBundle(properties) {
                        this.token = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenBundle token.
                     * @member {Array.<TW.Cardano.Proto.ITokenAmount>} token
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @instance
                     */
                    TokenBundle.prototype.token = $util.emptyArray;
    
                    /**
                     * Creates a new TokenBundle instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @static
                     * @param {TW.Cardano.Proto.ITokenBundle=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.TokenBundle} TokenBundle instance
                     */
                    TokenBundle.create = function create(properties) {
                        return new TokenBundle(properties);
                    };
    
                    /**
                     * Encodes the specified TokenBundle message. Does not implicitly {@link TW.Cardano.Proto.TokenBundle.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @static
                     * @param {TW.Cardano.Proto.ITokenBundle} message TokenBundle message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenBundle.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.token != null && message.token.length)
                            for (var i = 0; i < message.token.length; ++i)
                                $root.TW.Cardano.Proto.TokenAmount.encode(message.token[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenBundle message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.TokenBundle} TokenBundle
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenBundle.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.TokenBundle();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.token && message.token.length))
                                    message.token = [];
                                message.token.push($root.TW.Cardano.Proto.TokenAmount.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenBundle message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenBundle.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.token != null && message.hasOwnProperty("token")) {
                            if (!Array.isArray(message.token))
                                return "token: array expected";
                            for (var i = 0; i < message.token.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TokenAmount.verify(message.token[i]);
                                if (error)
                                    return "token." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a TokenBundle message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.TokenBundle} TokenBundle
                     */
                    TokenBundle.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.TokenBundle)
                            return object;
                        var message = new $root.TW.Cardano.Proto.TokenBundle();
                        if (object.token) {
                            if (!Array.isArray(object.token))
                                throw TypeError(".TW.Cardano.Proto.TokenBundle.token: array expected");
                            message.token = [];
                            for (var i = 0; i < object.token.length; ++i) {
                                if (typeof object.token[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.TokenBundle.token: object expected");
                                message.token[i] = $root.TW.Cardano.Proto.TokenAmount.fromObject(object.token[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenBundle message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @static
                     * @param {TW.Cardano.Proto.TokenBundle} message TokenBundle
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenBundle.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.token = [];
                        if (message.token && message.token.length) {
                            object.token = [];
                            for (var j = 0; j < message.token.length; ++j)
                                object.token[j] = $root.TW.Cardano.Proto.TokenAmount.toObject(message.token[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this TokenBundle to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.TokenBundle
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenBundle.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenBundle;
                })();
    
                Proto.Transfer = (function() {
    
                    /**
                     * Properties of a Transfer.
                     * @memberof TW.Cardano.Proto
                     * @interface ITransfer
                     * @property {string|null} [toAddress] Transfer toAddress
                     * @property {string|null} [changeAddress] Transfer changeAddress
                     * @property {Long|null} [amount] Transfer amount
                     * @property {TW.Cardano.Proto.ITokenBundle|null} [tokenAmount] Transfer tokenAmount
                     * @property {boolean|null} [useMaxAmount] Transfer useMaxAmount
                     * @property {Long|null} [forceFee] Transfer forceFee
                     */
    
                    /**
                     * Constructs a new Transfer.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a Transfer.
                     * @implements ITransfer
                     * @constructor
                     * @param {TW.Cardano.Proto.ITransfer=} [properties] Properties to set
                     */
                    function Transfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transfer toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Cardano.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.toAddress = "";
    
                    /**
                     * Transfer changeAddress.
                     * @member {string} changeAddress
                     * @memberof TW.Cardano.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.changeAddress = "";
    
                    /**
                     * Transfer amount.
                     * @member {Long} amount
                     * @memberof TW.Cardano.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Transfer tokenAmount.
                     * @member {TW.Cardano.Proto.ITokenBundle|null|undefined} tokenAmount
                     * @memberof TW.Cardano.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.tokenAmount = null;
    
                    /**
                     * Transfer useMaxAmount.
                     * @member {boolean} useMaxAmount
                     * @memberof TW.Cardano.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.useMaxAmount = false;
    
                    /**
                     * Transfer forceFee.
                     * @member {Long} forceFee
                     * @memberof TW.Cardano.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.forceFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.Transfer
                     * @static
                     * @param {TW.Cardano.Proto.ITransfer=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.Transfer} Transfer instance
                     */
                    Transfer.create = function create(properties) {
                        return new Transfer(properties);
                    };
    
                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.Cardano.Proto.Transfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.Transfer
                     * @static
                     * @param {TW.Cardano.Proto.ITransfer} message Transfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.toAddress);
                        if (message.changeAddress != null && Object.hasOwnProperty.call(message, "changeAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.changeAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amount);
                        if (message.tokenAmount != null && Object.hasOwnProperty.call(message, "tokenAmount"))
                            $root.TW.Cardano.Proto.TokenBundle.encode(message.tokenAmount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.useMaxAmount != null && Object.hasOwnProperty.call(message, "useMaxAmount"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.useMaxAmount);
                        if (message.forceFee != null && Object.hasOwnProperty.call(message, "forceFee"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.forceFee);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.Transfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.Transfer} Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.Transfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.toAddress = reader.string();
                                break;
                            case 2:
                                message.changeAddress = reader.string();
                                break;
                            case 3:
                                message.amount = reader.uint64();
                                break;
                            case 4:
                                message.tokenAmount = $root.TW.Cardano.Proto.TokenBundle.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.useMaxAmount = reader.bool();
                                break;
                            case 6:
                                message.forceFee = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transfer message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            if (!$util.isString(message.changeAddress))
                                return "changeAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.tokenAmount != null && message.hasOwnProperty("tokenAmount")) {
                            var error = $root.TW.Cardano.Proto.TokenBundle.verify(message.tokenAmount);
                            if (error)
                                return "tokenAmount." + error;
                        }
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            if (typeof message.useMaxAmount !== "boolean")
                                return "useMaxAmount: boolean expected";
                        if (message.forceFee != null && message.hasOwnProperty("forceFee"))
                            if (!$util.isInteger(message.forceFee) && !(message.forceFee && $util.isInteger(message.forceFee.low) && $util.isInteger(message.forceFee.high)))
                                return "forceFee: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.Transfer} Transfer
                     */
                    Transfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.Transfer)
                            return object;
                        var message = new $root.TW.Cardano.Proto.Transfer();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.changeAddress != null)
                            message.changeAddress = String(object.changeAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.tokenAmount != null) {
                            if (typeof object.tokenAmount !== "object")
                                throw TypeError(".TW.Cardano.Proto.Transfer.tokenAmount: object expected");
                            message.tokenAmount = $root.TW.Cardano.Proto.TokenBundle.fromObject(object.tokenAmount);
                        }
                        if (object.useMaxAmount != null)
                            message.useMaxAmount = Boolean(object.useMaxAmount);
                        if (object.forceFee != null)
                            if ($util.Long)
                                (message.forceFee = $util.Long.fromValue(object.forceFee)).unsigned = true;
                            else if (typeof object.forceFee === "string")
                                message.forceFee = parseInt(object.forceFee, 10);
                            else if (typeof object.forceFee === "number")
                                message.forceFee = object.forceFee;
                            else if (typeof object.forceFee === "object")
                                message.forceFee = new $util.LongBits(object.forceFee.low >>> 0, object.forceFee.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.Transfer
                     * @static
                     * @param {TW.Cardano.Proto.Transfer} message Transfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.toAddress = "";
                            object.changeAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.tokenAmount = null;
                            object.useMaxAmount = false;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.forceFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.forceFee = options.longs === String ? "0" : 0;
                        }
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            object.changeAddress = message.changeAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.tokenAmount != null && message.hasOwnProperty("tokenAmount"))
                            object.tokenAmount = $root.TW.Cardano.Proto.TokenBundle.toObject(message.tokenAmount, options);
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            object.useMaxAmount = message.useMaxAmount;
                        if (message.forceFee != null && message.hasOwnProperty("forceFee"))
                            if (typeof message.forceFee === "number")
                                object.forceFee = options.longs === String ? String(message.forceFee) : message.forceFee;
                            else
                                object.forceFee = options.longs === String ? $util.Long.prototype.toString.call(message.forceFee) : options.longs === Number ? new $util.LongBits(message.forceFee.low >>> 0, message.forceFee.high >>> 0).toNumber(true) : message.forceFee;
                        return object;
                    };
    
                    /**
                     * Converts this Transfer to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.Transfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transfer;
                })();
    
                Proto.TransactionPlan = (function() {
    
                    /**
                     * Properties of a TransactionPlan.
                     * @memberof TW.Cardano.Proto
                     * @interface ITransactionPlan
                     * @property {Long|null} [availableAmount] TransactionPlan availableAmount
                     * @property {Long|null} [amount] TransactionPlan amount
                     * @property {Long|null} [fee] TransactionPlan fee
                     * @property {Long|null} [change] TransactionPlan change
                     * @property {Array.<TW.Cardano.Proto.ITokenAmount>|null} [availableTokens] TransactionPlan availableTokens
                     * @property {Array.<TW.Cardano.Proto.ITokenAmount>|null} [outputTokens] TransactionPlan outputTokens
                     * @property {Array.<TW.Cardano.Proto.ITokenAmount>|null} [changeTokens] TransactionPlan changeTokens
                     * @property {Array.<TW.Cardano.Proto.ITxInput>|null} [utxos] TransactionPlan utxos
                     * @property {TW.Common.Proto.SigningError|null} [error] TransactionPlan error
                     */
    
                    /**
                     * Constructs a new TransactionPlan.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a TransactionPlan.
                     * @implements ITransactionPlan
                     * @constructor
                     * @param {TW.Cardano.Proto.ITransactionPlan=} [properties] Properties to set
                     */
                    function TransactionPlan(properties) {
                        this.availableTokens = [];
                        this.outputTokens = [];
                        this.changeTokens = [];
                        this.utxos = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionPlan availableAmount.
                     * @member {Long} availableAmount
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.availableAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TransactionPlan amount.
                     * @member {Long} amount
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TransactionPlan fee.
                     * @member {Long} fee
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TransactionPlan change.
                     * @member {Long} change
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.change = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TransactionPlan availableTokens.
                     * @member {Array.<TW.Cardano.Proto.ITokenAmount>} availableTokens
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.availableTokens = $util.emptyArray;
    
                    /**
                     * TransactionPlan outputTokens.
                     * @member {Array.<TW.Cardano.Proto.ITokenAmount>} outputTokens
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.outputTokens = $util.emptyArray;
    
                    /**
                     * TransactionPlan changeTokens.
                     * @member {Array.<TW.Cardano.Proto.ITokenAmount>} changeTokens
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.changeTokens = $util.emptyArray;
    
                    /**
                     * TransactionPlan utxos.
                     * @member {Array.<TW.Cardano.Proto.ITxInput>} utxos
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.utxos = $util.emptyArray;
    
                    /**
                     * TransactionPlan error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.error = 0;
    
                    /**
                     * Creates a new TransactionPlan instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @static
                     * @param {TW.Cardano.Proto.ITransactionPlan=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.TransactionPlan} TransactionPlan instance
                     */
                    TransactionPlan.create = function create(properties) {
                        return new TransactionPlan(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.Cardano.Proto.TransactionPlan.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @static
                     * @param {TW.Cardano.Proto.ITransactionPlan} message TransactionPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPlan.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.availableAmount != null && Object.hasOwnProperty.call(message, "availableAmount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.availableAmount);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
                        if (message.change != null && Object.hasOwnProperty.call(message, "change"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.change);
                        if (message.availableTokens != null && message.availableTokens.length)
                            for (var i = 0; i < message.availableTokens.length; ++i)
                                $root.TW.Cardano.Proto.TokenAmount.encode(message.availableTokens[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.outputTokens != null && message.outputTokens.length)
                            for (var i = 0; i < message.outputTokens.length; ++i)
                                $root.TW.Cardano.Proto.TokenAmount.encode(message.outputTokens[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.changeTokens != null && message.changeTokens.length)
                            for (var i = 0; i < message.changeTokens.length; ++i)
                                $root.TW.Cardano.Proto.TokenAmount.encode(message.changeTokens[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.utxos != null && message.utxos.length)
                            for (var i = 0; i < message.utxos.length; ++i)
                                $root.TW.Cardano.Proto.TxInput.encode(message.utxos[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionPlan message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.TransactionPlan} TransactionPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPlan.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.TransactionPlan();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.availableAmount = reader.uint64();
                                break;
                            case 2:
                                message.amount = reader.uint64();
                                break;
                            case 3:
                                message.fee = reader.uint64();
                                break;
                            case 4:
                                message.change = reader.uint64();
                                break;
                            case 5:
                                if (!(message.availableTokens && message.availableTokens.length))
                                    message.availableTokens = [];
                                message.availableTokens.push($root.TW.Cardano.Proto.TokenAmount.decode(reader, reader.uint32()));
                                break;
                            case 6:
                                if (!(message.outputTokens && message.outputTokens.length))
                                    message.outputTokens = [];
                                message.outputTokens.push($root.TW.Cardano.Proto.TokenAmount.decode(reader, reader.uint32()));
                                break;
                            case 7:
                                if (!(message.changeTokens && message.changeTokens.length))
                                    message.changeTokens = [];
                                message.changeTokens.push($root.TW.Cardano.Proto.TokenAmount.decode(reader, reader.uint32()));
                                break;
                            case 8:
                                if (!(message.utxos && message.utxos.length))
                                    message.utxos = [];
                                message.utxos.push($root.TW.Cardano.Proto.TxInput.decode(reader, reader.uint32()));
                                break;
                            case 9:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionPlan message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionPlan.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (!$util.isInteger(message.availableAmount) && !(message.availableAmount && $util.isInteger(message.availableAmount.low) && $util.isInteger(message.availableAmount.high)))
                                return "availableAmount: integer|Long expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (!$util.isInteger(message.change) && !(message.change && $util.isInteger(message.change.low) && $util.isInteger(message.change.high)))
                                return "change: integer|Long expected";
                        if (message.availableTokens != null && message.hasOwnProperty("availableTokens")) {
                            if (!Array.isArray(message.availableTokens))
                                return "availableTokens: array expected";
                            for (var i = 0; i < message.availableTokens.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TokenAmount.verify(message.availableTokens[i]);
                                if (error)
                                    return "availableTokens." + error;
                            }
                        }
                        if (message.outputTokens != null && message.hasOwnProperty("outputTokens")) {
                            if (!Array.isArray(message.outputTokens))
                                return "outputTokens: array expected";
                            for (var i = 0; i < message.outputTokens.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TokenAmount.verify(message.outputTokens[i]);
                                if (error)
                                    return "outputTokens." + error;
                            }
                        }
                        if (message.changeTokens != null && message.hasOwnProperty("changeTokens")) {
                            if (!Array.isArray(message.changeTokens))
                                return "changeTokens: array expected";
                            for (var i = 0; i < message.changeTokens.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TokenAmount.verify(message.changeTokens[i]);
                                if (error)
                                    return "changeTokens." + error;
                            }
                        }
                        if (message.utxos != null && message.hasOwnProperty("utxos")) {
                            if (!Array.isArray(message.utxos))
                                return "utxos: array expected";
                            for (var i = 0; i < message.utxos.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TxInput.verify(message.utxos[i]);
                                if (error)
                                    return "utxos." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.TransactionPlan} TransactionPlan
                     */
                    TransactionPlan.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.TransactionPlan)
                            return object;
                        var message = new $root.TW.Cardano.Proto.TransactionPlan();
                        if (object.availableAmount != null)
                            if ($util.Long)
                                (message.availableAmount = $util.Long.fromValue(object.availableAmount)).unsigned = true;
                            else if (typeof object.availableAmount === "string")
                                message.availableAmount = parseInt(object.availableAmount, 10);
                            else if (typeof object.availableAmount === "number")
                                message.availableAmount = object.availableAmount;
                            else if (typeof object.availableAmount === "object")
                                message.availableAmount = new $util.LongBits(object.availableAmount.low >>> 0, object.availableAmount.high >>> 0).toNumber(true);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        if (object.change != null)
                            if ($util.Long)
                                (message.change = $util.Long.fromValue(object.change)).unsigned = true;
                            else if (typeof object.change === "string")
                                message.change = parseInt(object.change, 10);
                            else if (typeof object.change === "number")
                                message.change = object.change;
                            else if (typeof object.change === "object")
                                message.change = new $util.LongBits(object.change.low >>> 0, object.change.high >>> 0).toNumber(true);
                        if (object.availableTokens) {
                            if (!Array.isArray(object.availableTokens))
                                throw TypeError(".TW.Cardano.Proto.TransactionPlan.availableTokens: array expected");
                            message.availableTokens = [];
                            for (var i = 0; i < object.availableTokens.length; ++i) {
                                if (typeof object.availableTokens[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.TransactionPlan.availableTokens: object expected");
                                message.availableTokens[i] = $root.TW.Cardano.Proto.TokenAmount.fromObject(object.availableTokens[i]);
                            }
                        }
                        if (object.outputTokens) {
                            if (!Array.isArray(object.outputTokens))
                                throw TypeError(".TW.Cardano.Proto.TransactionPlan.outputTokens: array expected");
                            message.outputTokens = [];
                            for (var i = 0; i < object.outputTokens.length; ++i) {
                                if (typeof object.outputTokens[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.TransactionPlan.outputTokens: object expected");
                                message.outputTokens[i] = $root.TW.Cardano.Proto.TokenAmount.fromObject(object.outputTokens[i]);
                            }
                        }
                        if (object.changeTokens) {
                            if (!Array.isArray(object.changeTokens))
                                throw TypeError(".TW.Cardano.Proto.TransactionPlan.changeTokens: array expected");
                            message.changeTokens = [];
                            for (var i = 0; i < object.changeTokens.length; ++i) {
                                if (typeof object.changeTokens[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.TransactionPlan.changeTokens: object expected");
                                message.changeTokens[i] = $root.TW.Cardano.Proto.TokenAmount.fromObject(object.changeTokens[i]);
                            }
                        }
                        if (object.utxos) {
                            if (!Array.isArray(object.utxos))
                                throw TypeError(".TW.Cardano.Proto.TransactionPlan.utxos: array expected");
                            message.utxos = [];
                            for (var i = 0; i < object.utxos.length; ++i) {
                                if (typeof object.utxos[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.TransactionPlan.utxos: object expected");
                                message.utxos[i] = $root.TW.Cardano.Proto.TxInput.fromObject(object.utxos[i]);
                            }
                        }
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @static
                     * @param {TW.Cardano.Proto.TransactionPlan} message TransactionPlan
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionPlan.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.availableTokens = [];
                            object.outputTokens = [];
                            object.changeTokens = [];
                            object.utxos = [];
                        }
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.availableAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.availableAmount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.change = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.change = options.longs === String ? "0" : 0;
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (typeof message.availableAmount === "number")
                                object.availableAmount = options.longs === String ? String(message.availableAmount) : message.availableAmount;
                            else
                                object.availableAmount = options.longs === String ? $util.Long.prototype.toString.call(message.availableAmount) : options.longs === Number ? new $util.LongBits(message.availableAmount.low >>> 0, message.availableAmount.high >>> 0).toNumber(true) : message.availableAmount;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (typeof message.change === "number")
                                object.change = options.longs === String ? String(message.change) : message.change;
                            else
                                object.change = options.longs === String ? $util.Long.prototype.toString.call(message.change) : options.longs === Number ? new $util.LongBits(message.change.low >>> 0, message.change.high >>> 0).toNumber(true) : message.change;
                        if (message.availableTokens && message.availableTokens.length) {
                            object.availableTokens = [];
                            for (var j = 0; j < message.availableTokens.length; ++j)
                                object.availableTokens[j] = $root.TW.Cardano.Proto.TokenAmount.toObject(message.availableTokens[j], options);
                        }
                        if (message.outputTokens && message.outputTokens.length) {
                            object.outputTokens = [];
                            for (var j = 0; j < message.outputTokens.length; ++j)
                                object.outputTokens[j] = $root.TW.Cardano.Proto.TokenAmount.toObject(message.outputTokens[j], options);
                        }
                        if (message.changeTokens && message.changeTokens.length) {
                            object.changeTokens = [];
                            for (var j = 0; j < message.changeTokens.length; ++j)
                                object.changeTokens[j] = $root.TW.Cardano.Proto.TokenAmount.toObject(message.changeTokens[j], options);
                        }
                        if (message.utxos && message.utxos.length) {
                            object.utxos = [];
                            for (var j = 0; j < message.utxos.length; ++j)
                                object.utxos[j] = $root.TW.Cardano.Proto.TxInput.toObject(message.utxos[j], options);
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionPlan to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.TransactionPlan
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionPlan.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionPlan;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Cardano.Proto
                     * @interface ISigningInput
                     * @property {Array.<TW.Cardano.Proto.ITxInput>|null} [utxos] SigningInput utxos
                     * @property {Array.<Uint8Array>|null} [privateKey] SigningInput privateKey
                     * @property {TW.Cardano.Proto.ITransfer|null} [transferMessage] SigningInput transferMessage
                     * @property {Long|null} [ttl] SigningInput ttl
                     * @property {TW.Cardano.Proto.ITransactionPlan|null} [plan] SigningInput plan
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Cardano.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.utxos = [];
                        this.privateKey = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput utxos.
                     * @member {Array.<TW.Cardano.Proto.ITxInput>} utxos
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.utxos = $util.emptyArray;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Array.<Uint8Array>} privateKey
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.emptyArray;
    
                    /**
                     * SigningInput transferMessage.
                     * @member {TW.Cardano.Proto.ITransfer|null|undefined} transferMessage
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transferMessage = null;
    
                    /**
                     * SigningInput ttl.
                     * @member {Long} ttl
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput plan.
                     * @member {TW.Cardano.Proto.ITransactionPlan|null|undefined} plan
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.plan = null;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @static
                     * @param {TW.Cardano.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Cardano.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @static
                     * @param {TW.Cardano.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.utxos != null && message.utxos.length)
                            for (var i = 0; i < message.utxos.length; ++i)
                                $root.TW.Cardano.Proto.TxInput.encode(message.utxos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.privateKey != null && message.privateKey.length)
                            for (var i = 0; i < message.privateKey.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey[i]);
                        if (message.transferMessage != null && Object.hasOwnProperty.call(message, "transferMessage"))
                            $root.TW.Cardano.Proto.Transfer.encode(message.transferMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.ttl);
                        if (message.plan != null && Object.hasOwnProperty.call(message, "plan"))
                            $root.TW.Cardano.Proto.TransactionPlan.encode(message.plan, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.utxos && message.utxos.length))
                                    message.utxos = [];
                                message.utxos.push($root.TW.Cardano.Proto.TxInput.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                if (!(message.privateKey && message.privateKey.length))
                                    message.privateKey = [];
                                message.privateKey.push(reader.bytes());
                                break;
                            case 3:
                                message.transferMessage = $root.TW.Cardano.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.ttl = reader.uint64();
                                break;
                            case 5:
                                message.plan = $root.TW.Cardano.Proto.TransactionPlan.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.utxos != null && message.hasOwnProperty("utxos")) {
                            if (!Array.isArray(message.utxos))
                                return "utxos: array expected";
                            for (var i = 0; i < message.utxos.length; ++i) {
                                var error = $root.TW.Cardano.Proto.TxInput.verify(message.utxos[i]);
                                if (error)
                                    return "utxos." + error;
                            }
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey")) {
                            if (!Array.isArray(message.privateKey))
                                return "privateKey: array expected";
                            for (var i = 0; i < message.privateKey.length; ++i)
                                if (!(message.privateKey[i] && typeof message.privateKey[i].length === "number" || $util.isString(message.privateKey[i])))
                                    return "privateKey: buffer[] expected";
                        }
                        if (message.transferMessage != null && message.hasOwnProperty("transferMessage")) {
                            var error = $root.TW.Cardano.Proto.Transfer.verify(message.transferMessage);
                            if (error)
                                return "transferMessage." + error;
                        }
                        if (message.ttl != null && message.hasOwnProperty("ttl"))
                            if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                                return "ttl: integer|Long expected";
                        if (message.plan != null && message.hasOwnProperty("plan")) {
                            var error = $root.TW.Cardano.Proto.TransactionPlan.verify(message.plan);
                            if (error)
                                return "plan." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Cardano.Proto.SigningInput();
                        if (object.utxos) {
                            if (!Array.isArray(object.utxos))
                                throw TypeError(".TW.Cardano.Proto.SigningInput.utxos: array expected");
                            message.utxos = [];
                            for (var i = 0; i < object.utxos.length; ++i) {
                                if (typeof object.utxos[i] !== "object")
                                    throw TypeError(".TW.Cardano.Proto.SigningInput.utxos: object expected");
                                message.utxos[i] = $root.TW.Cardano.Proto.TxInput.fromObject(object.utxos[i]);
                            }
                        }
                        if (object.privateKey) {
                            if (!Array.isArray(object.privateKey))
                                throw TypeError(".TW.Cardano.Proto.SigningInput.privateKey: array expected");
                            message.privateKey = [];
                            for (var i = 0; i < object.privateKey.length; ++i)
                                if (typeof object.privateKey[i] === "string")
                                    $util.base64.decode(object.privateKey[i], message.privateKey[i] = $util.newBuffer($util.base64.length(object.privateKey[i])), 0);
                                else if (object.privateKey[i].length)
                                    message.privateKey[i] = object.privateKey[i];
                        }
                        if (object.transferMessage != null) {
                            if (typeof object.transferMessage !== "object")
                                throw TypeError(".TW.Cardano.Proto.SigningInput.transferMessage: object expected");
                            message.transferMessage = $root.TW.Cardano.Proto.Transfer.fromObject(object.transferMessage);
                        }
                        if (object.ttl != null)
                            if ($util.Long)
                                (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = true;
                            else if (typeof object.ttl === "string")
                                message.ttl = parseInt(object.ttl, 10);
                            else if (typeof object.ttl === "number")
                                message.ttl = object.ttl;
                            else if (typeof object.ttl === "object")
                                message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber(true);
                        if (object.plan != null) {
                            if (typeof object.plan !== "object")
                                throw TypeError(".TW.Cardano.Proto.SigningInput.plan: object expected");
                            message.plan = $root.TW.Cardano.Proto.TransactionPlan.fromObject(object.plan);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @static
                     * @param {TW.Cardano.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.utxos = [];
                            object.privateKey = [];
                        }
                        if (options.defaults) {
                            object.transferMessage = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.ttl = options.longs === String ? "0" : 0;
                            object.plan = null;
                        }
                        if (message.utxos && message.utxos.length) {
                            object.utxos = [];
                            for (var j = 0; j < message.utxos.length; ++j)
                                object.utxos[j] = $root.TW.Cardano.Proto.TxInput.toObject(message.utxos[j], options);
                        }
                        if (message.privateKey && message.privateKey.length) {
                            object.privateKey = [];
                            for (var j = 0; j < message.privateKey.length; ++j)
                                object.privateKey[j] = options.bytes === String ? $util.base64.encode(message.privateKey[j], 0, message.privateKey[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey[j]) : message.privateKey[j];
                        }
                        if (message.transferMessage != null && message.hasOwnProperty("transferMessage"))
                            object.transferMessage = $root.TW.Cardano.Proto.Transfer.toObject(message.transferMessage, options);
                        if (message.ttl != null && message.hasOwnProperty("ttl"))
                            if (typeof message.ttl === "number")
                                object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                            else
                                object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber(true) : message.ttl;
                        if (message.plan != null && message.hasOwnProperty("plan"))
                            object.plan = $root.TW.Cardano.Proto.TransactionPlan.toObject(message.plan, options);
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Cardano.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [txId] SigningOutput txId
                     * @property {TW.Common.Proto.SigningError|null} [error] SigningOutput error
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Cardano.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Cardano.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput txId.
                     * @member {Uint8Array} txId
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.txId = $util.newBuffer([]);
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @static
                     * @param {TW.Cardano.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Cardano.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Cardano.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @static
                     * @param {TW.Cardano.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.txId);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cardano.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cardano.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.txId = reader.bytes();
                                break;
                            case 3:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.txId != null && message.hasOwnProperty("txId"))
                            if (!(message.txId && typeof message.txId.length === "number" || $util.isString(message.txId)))
                                return "txId: buffer expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cardano.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cardano.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Cardano.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.txId != null)
                            if (typeof object.txId === "string")
                                $util.base64.decode(object.txId, message.txId = $util.newBuffer($util.base64.length(object.txId)), 0);
                            else if (object.txId.length)
                                message.txId = object.txId;
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @static
                     * @param {TW.Cardano.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.txId = "";
                            else {
                                object.txId = [];
                                if (options.bytes !== Array)
                                    object.txId = $util.newBuffer(object.txId);
                            }
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.txId != null && message.hasOwnProperty("txId"))
                            object.txId = options.bytes === String ? $util.base64.encode(message.txId, 0, message.txId.length) : options.bytes === Array ? Array.prototype.slice.call(message.txId) : message.txId;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Cardano.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Cardano;
        })();
    
        TW.Cosmos = (function() {
    
            /**
             * Namespace Cosmos.
             * @memberof TW
             * @namespace
             */
            var Cosmos = {};
    
            Cosmos.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Cosmos
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Amount = (function() {
    
                    /**
                     * Properties of an Amount.
                     * @memberof TW.Cosmos.Proto
                     * @interface IAmount
                     * @property {string|null} [denom] Amount denom
                     * @property {string|null} [amount] Amount amount
                     */
    
                    /**
                     * Constructs a new Amount.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents an Amount.
                     * @implements IAmount
                     * @constructor
                     * @param {TW.Cosmos.Proto.IAmount=} [properties] Properties to set
                     */
                    function Amount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Amount denom.
                     * @member {string} denom
                     * @memberof TW.Cosmos.Proto.Amount
                     * @instance
                     */
                    Amount.prototype.denom = "";
    
                    /**
                     * Amount amount.
                     * @member {string} amount
                     * @memberof TW.Cosmos.Proto.Amount
                     * @instance
                     */
                    Amount.prototype.amount = "";
    
                    /**
                     * Creates a new Amount instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {TW.Cosmos.Proto.IAmount=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Amount} Amount instance
                     */
                    Amount.create = function create(properties) {
                        return new Amount(properties);
                    };
    
                    /**
                     * Encodes the specified Amount message. Does not implicitly {@link TW.Cosmos.Proto.Amount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {TW.Cosmos.Proto.IAmount} message Amount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Amount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes an Amount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Amount} Amount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Amount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Amount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.denom = reader.string();
                                break;
                            case 2:
                                message.amount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Amount message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Amount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            if (!$util.isString(message.denom))
                                return "denom: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Amount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Amount} Amount
                     */
                    Amount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Amount)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Amount();
                        if (object.denom != null)
                            message.denom = String(object.denom);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Amount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {TW.Cosmos.Proto.Amount} message Amount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Amount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.denom = "";
                            object.amount = "";
                        }
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            object.denom = message.denom;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this Amount to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Amount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Amount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Amount;
                })();
    
                Proto.Fee = (function() {
    
                    /**
                     * Properties of a Fee.
                     * @memberof TW.Cosmos.Proto
                     * @interface IFee
                     * @property {Array.<TW.Cosmos.Proto.IAmount>|null} [amounts] Fee amounts
                     * @property {Long|null} [gas] Fee gas
                     */
    
                    /**
                     * Constructs a new Fee.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a Fee.
                     * @implements IFee
                     * @constructor
                     * @param {TW.Cosmos.Proto.IFee=} [properties] Properties to set
                     */
                    function Fee(properties) {
                        this.amounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Fee amounts.
                     * @member {Array.<TW.Cosmos.Proto.IAmount>} amounts
                     * @memberof TW.Cosmos.Proto.Fee
                     * @instance
                     */
                    Fee.prototype.amounts = $util.emptyArray;
    
                    /**
                     * Fee gas.
                     * @member {Long} gas
                     * @memberof TW.Cosmos.Proto.Fee
                     * @instance
                     */
                    Fee.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new Fee instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {TW.Cosmos.Proto.IFee=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Fee} Fee instance
                     */
                    Fee.create = function create(properties) {
                        return new Fee(properties);
                    };
    
                    /**
                     * Encodes the specified Fee message. Does not implicitly {@link TW.Cosmos.Proto.Fee.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {TW.Cosmos.Proto.IFee} message Fee message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fee.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amounts != null && message.amounts.length)
                            for (var i = 0; i < message.amounts.length; ++i)
                                $root.TW.Cosmos.Proto.Amount.encode(message.amounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.gas);
                        return writer;
                    };
    
                    /**
                     * Decodes a Fee message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Fee} Fee
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fee.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Fee();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.amounts && message.amounts.length))
                                    message.amounts = [];
                                message.amounts.push($root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.gas = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Fee message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fee.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amounts != null && message.hasOwnProperty("amounts")) {
                            if (!Array.isArray(message.amounts))
                                return "amounts: array expected";
                            for (var i = 0; i < message.amounts.length; ++i) {
                                var error = $root.TW.Cosmos.Proto.Amount.verify(message.amounts[i]);
                                if (error)
                                    return "amounts." + error;
                            }
                        }
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
                                return "gas: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a Fee message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Fee} Fee
                     */
                    Fee.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Fee)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Fee();
                        if (object.amounts) {
                            if (!Array.isArray(object.amounts))
                                throw TypeError(".TW.Cosmos.Proto.Fee.amounts: array expected");
                            message.amounts = [];
                            for (var i = 0; i < object.amounts.length; ++i) {
                                if (typeof object.amounts[i] !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.Fee.amounts: object expected");
                                message.amounts[i] = $root.TW.Cosmos.Proto.Amount.fromObject(object.amounts[i]);
                            }
                        }
                        if (object.gas != null)
                            if ($util.Long)
                                (message.gas = $util.Long.fromValue(object.gas)).unsigned = true;
                            else if (typeof object.gas === "string")
                                message.gas = parseInt(object.gas, 10);
                            else if (typeof object.gas === "number")
                                message.gas = object.gas;
                            else if (typeof object.gas === "object")
                                message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Fee message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {TW.Cosmos.Proto.Fee} message Fee
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fee.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amounts = [];
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gas = options.longs === String ? "0" : 0;
                        if (message.amounts && message.amounts.length) {
                            object.amounts = [];
                            for (var j = 0; j < message.amounts.length; ++j)
                                object.amounts[j] = $root.TW.Cosmos.Proto.Amount.toObject(message.amounts[j], options);
                        }
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (typeof message.gas === "number")
                                object.gas = options.longs === String ? String(message.gas) : message.gas;
                            else
                                object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber(true) : message.gas;
                        return object;
                    };
    
                    /**
                     * Converts this Fee to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Fee
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fee.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Fee;
                })();
    
                Proto.Height = (function() {
    
                    /**
                     * Properties of an Height.
                     * @memberof TW.Cosmos.Proto
                     * @interface IHeight
                     * @property {Long|null} [revisionNumber] Height revisionNumber
                     * @property {Long|null} [revisionHeight] Height revisionHeight
                     */
    
                    /**
                     * Constructs a new Height.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents an Height.
                     * @implements IHeight
                     * @constructor
                     * @param {TW.Cosmos.Proto.IHeight=} [properties] Properties to set
                     */
                    function Height(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Height revisionNumber.
                     * @member {Long} revisionNumber
                     * @memberof TW.Cosmos.Proto.Height
                     * @instance
                     */
                    Height.prototype.revisionNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Height revisionHeight.
                     * @member {Long} revisionHeight
                     * @memberof TW.Cosmos.Proto.Height
                     * @instance
                     */
                    Height.prototype.revisionHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new Height instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Height
                     * @static
                     * @param {TW.Cosmos.Proto.IHeight=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Height} Height instance
                     */
                    Height.create = function create(properties) {
                        return new Height(properties);
                    };
    
                    /**
                     * Encodes the specified Height message. Does not implicitly {@link TW.Cosmos.Proto.Height.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Height
                     * @static
                     * @param {TW.Cosmos.Proto.IHeight} message Height message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Height.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.revisionNumber != null && Object.hasOwnProperty.call(message, "revisionNumber"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.revisionNumber);
                        if (message.revisionHeight != null && Object.hasOwnProperty.call(message, "revisionHeight"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.revisionHeight);
                        return writer;
                    };
    
                    /**
                     * Decodes an Height message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Height
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Height} Height
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Height.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Height();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.revisionNumber = reader.uint64();
                                break;
                            case 2:
                                message.revisionHeight = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Height message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Height
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Height.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.revisionNumber != null && message.hasOwnProperty("revisionNumber"))
                            if (!$util.isInteger(message.revisionNumber) && !(message.revisionNumber && $util.isInteger(message.revisionNumber.low) && $util.isInteger(message.revisionNumber.high)))
                                return "revisionNumber: integer|Long expected";
                        if (message.revisionHeight != null && message.hasOwnProperty("revisionHeight"))
                            if (!$util.isInteger(message.revisionHeight) && !(message.revisionHeight && $util.isInteger(message.revisionHeight.low) && $util.isInteger(message.revisionHeight.high)))
                                return "revisionHeight: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an Height message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Height
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Height} Height
                     */
                    Height.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Height)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Height();
                        if (object.revisionNumber != null)
                            if ($util.Long)
                                (message.revisionNumber = $util.Long.fromValue(object.revisionNumber)).unsigned = true;
                            else if (typeof object.revisionNumber === "string")
                                message.revisionNumber = parseInt(object.revisionNumber, 10);
                            else if (typeof object.revisionNumber === "number")
                                message.revisionNumber = object.revisionNumber;
                            else if (typeof object.revisionNumber === "object")
                                message.revisionNumber = new $util.LongBits(object.revisionNumber.low >>> 0, object.revisionNumber.high >>> 0).toNumber(true);
                        if (object.revisionHeight != null)
                            if ($util.Long)
                                (message.revisionHeight = $util.Long.fromValue(object.revisionHeight)).unsigned = true;
                            else if (typeof object.revisionHeight === "string")
                                message.revisionHeight = parseInt(object.revisionHeight, 10);
                            else if (typeof object.revisionHeight === "number")
                                message.revisionHeight = object.revisionHeight;
                            else if (typeof object.revisionHeight === "object")
                                message.revisionHeight = new $util.LongBits(object.revisionHeight.low >>> 0, object.revisionHeight.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Height message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Height
                     * @static
                     * @param {TW.Cosmos.Proto.Height} message Height
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Height.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.revisionNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.revisionNumber = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.revisionHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.revisionHeight = options.longs === String ? "0" : 0;
                        }
                        if (message.revisionNumber != null && message.hasOwnProperty("revisionNumber"))
                            if (typeof message.revisionNumber === "number")
                                object.revisionNumber = options.longs === String ? String(message.revisionNumber) : message.revisionNumber;
                            else
                                object.revisionNumber = options.longs === String ? $util.Long.prototype.toString.call(message.revisionNumber) : options.longs === Number ? new $util.LongBits(message.revisionNumber.low >>> 0, message.revisionNumber.high >>> 0).toNumber(true) : message.revisionNumber;
                        if (message.revisionHeight != null && message.hasOwnProperty("revisionHeight"))
                            if (typeof message.revisionHeight === "number")
                                object.revisionHeight = options.longs === String ? String(message.revisionHeight) : message.revisionHeight;
                            else
                                object.revisionHeight = options.longs === String ? $util.Long.prototype.toString.call(message.revisionHeight) : options.longs === Number ? new $util.LongBits(message.revisionHeight.low >>> 0, message.revisionHeight.high >>> 0).toNumber(true) : message.revisionHeight;
                        return object;
                    };
    
                    /**
                     * Converts this Height to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Height
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Height.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Height;
                })();
    
                /**
                 * BroadcastMode enum.
                 * @name TW.Cosmos.Proto.BroadcastMode
                 * @enum {number}
                 * @property {number} BLOCK=0 BLOCK value
                 * @property {number} SYNC=1 SYNC value
                 * @property {number} ASYNC=2 ASYNC value
                 */
                Proto.BroadcastMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BLOCK"] = 0;
                    values[valuesById[1] = "SYNC"] = 1;
                    values[valuesById[2] = "ASYNC"] = 2;
                    return values;
                })();
    
                Proto.Message = (function() {
    
                    /**
                     * Properties of a Message.
                     * @memberof TW.Cosmos.Proto
                     * @interface IMessage
                     * @property {TW.Cosmos.Proto.Message.ISend|null} [sendCoinsMessage] Message sendCoinsMessage
                     * @property {TW.Cosmos.Proto.Message.ITransfer|null} [transferTokensMessage] Message transferTokensMessage
                     * @property {TW.Cosmos.Proto.Message.IDelegate|null} [stakeMessage] Message stakeMessage
                     * @property {TW.Cosmos.Proto.Message.IUndelegate|null} [unstakeMessage] Message unstakeMessage
                     * @property {TW.Cosmos.Proto.Message.IBeginRedelegate|null} [restakeMessage] Message restakeMessage
                     * @property {TW.Cosmos.Proto.Message.IWithdrawDelegationReward|null} [withdrawStakeRewardMessage] Message withdrawStakeRewardMessage
                     * @property {TW.Cosmos.Proto.Message.IRawJSON|null} [rawJsonMessage] Message rawJsonMessage
                     * @property {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer|null} [wasmTerraExecuteContractTransferMessage] Message wasmTerraExecuteContractTransferMessage
                     * @property {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend|null} [wasmTerraExecuteContractSendMessage] Message wasmTerraExecuteContractSendMessage
                     * @property {TW.Cosmos.Proto.Message.ITHORChainSend|null} [thorchainSendMessage] Message thorchainSendMessage
                     * @property {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric|null} [wasmTerraExecuteContractGeneric] Message wasmTerraExecuteContractGeneric
                     */
    
                    /**
                     * Constructs a new Message.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a Message.
                     * @implements IMessage
                     * @constructor
                     * @param {TW.Cosmos.Proto.IMessage=} [properties] Properties to set
                     */
                    function Message(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Message sendCoinsMessage.
                     * @member {TW.Cosmos.Proto.Message.ISend|null|undefined} sendCoinsMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.sendCoinsMessage = null;
    
                    /**
                     * Message transferTokensMessage.
                     * @member {TW.Cosmos.Proto.Message.ITransfer|null|undefined} transferTokensMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.transferTokensMessage = null;
    
                    /**
                     * Message stakeMessage.
                     * @member {TW.Cosmos.Proto.Message.IDelegate|null|undefined} stakeMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.stakeMessage = null;
    
                    /**
                     * Message unstakeMessage.
                     * @member {TW.Cosmos.Proto.Message.IUndelegate|null|undefined} unstakeMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.unstakeMessage = null;
    
                    /**
                     * Message restakeMessage.
                     * @member {TW.Cosmos.Proto.Message.IBeginRedelegate|null|undefined} restakeMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.restakeMessage = null;
    
                    /**
                     * Message withdrawStakeRewardMessage.
                     * @member {TW.Cosmos.Proto.Message.IWithdrawDelegationReward|null|undefined} withdrawStakeRewardMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.withdrawStakeRewardMessage = null;
    
                    /**
                     * Message rawJsonMessage.
                     * @member {TW.Cosmos.Proto.Message.IRawJSON|null|undefined} rawJsonMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.rawJsonMessage = null;
    
                    /**
                     * Message wasmTerraExecuteContractTransferMessage.
                     * @member {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer|null|undefined} wasmTerraExecuteContractTransferMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.wasmTerraExecuteContractTransferMessage = null;
    
                    /**
                     * Message wasmTerraExecuteContractSendMessage.
                     * @member {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend|null|undefined} wasmTerraExecuteContractSendMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.wasmTerraExecuteContractSendMessage = null;
    
                    /**
                     * Message thorchainSendMessage.
                     * @member {TW.Cosmos.Proto.Message.ITHORChainSend|null|undefined} thorchainSendMessage
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.thorchainSendMessage = null;
    
                    /**
                     * Message wasmTerraExecuteContractGeneric.
                     * @member {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric|null|undefined} wasmTerraExecuteContractGeneric
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Message.prototype.wasmTerraExecuteContractGeneric = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Message messageOneof.
                     * @member {"sendCoinsMessage"|"transferTokensMessage"|"stakeMessage"|"unstakeMessage"|"restakeMessage"|"withdrawStakeRewardMessage"|"rawJsonMessage"|"wasmTerraExecuteContractTransferMessage"|"wasmTerraExecuteContractSendMessage"|"thorchainSendMessage"|"wasmTerraExecuteContractGeneric"|undefined} messageOneof
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     */
                    Object.defineProperty(Message.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["sendCoinsMessage", "transferTokensMessage", "stakeMessage", "unstakeMessage", "restakeMessage", "withdrawStakeRewardMessage", "rawJsonMessage", "wasmTerraExecuteContractTransferMessage", "wasmTerraExecuteContractSendMessage", "thorchainSendMessage", "wasmTerraExecuteContractGeneric"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Message instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Message
                     * @static
                     * @param {TW.Cosmos.Proto.IMessage=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Message} Message instance
                     */
                    Message.create = function create(properties) {
                        return new Message(properties);
                    };
    
                    /**
                     * Encodes the specified Message message. Does not implicitly {@link TW.Cosmos.Proto.Message.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Message
                     * @static
                     * @param {TW.Cosmos.Proto.IMessage} message Message message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Message.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.sendCoinsMessage != null && Object.hasOwnProperty.call(message, "sendCoinsMessage"))
                            $root.TW.Cosmos.Proto.Message.Send.encode(message.sendCoinsMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.transferTokensMessage != null && Object.hasOwnProperty.call(message, "transferTokensMessage"))
                            $root.TW.Cosmos.Proto.Message.Transfer.encode(message.transferTokensMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.stakeMessage != null && Object.hasOwnProperty.call(message, "stakeMessage"))
                            $root.TW.Cosmos.Proto.Message.Delegate.encode(message.stakeMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.unstakeMessage != null && Object.hasOwnProperty.call(message, "unstakeMessage"))
                            $root.TW.Cosmos.Proto.Message.Undelegate.encode(message.unstakeMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.restakeMessage != null && Object.hasOwnProperty.call(message, "restakeMessage"))
                            $root.TW.Cosmos.Proto.Message.BeginRedelegate.encode(message.restakeMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.withdrawStakeRewardMessage != null && Object.hasOwnProperty.call(message, "withdrawStakeRewardMessage"))
                            $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward.encode(message.withdrawStakeRewardMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.rawJsonMessage != null && Object.hasOwnProperty.call(message, "rawJsonMessage"))
                            $root.TW.Cosmos.Proto.Message.RawJSON.encode(message.rawJsonMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.wasmTerraExecuteContractTransferMessage != null && Object.hasOwnProperty.call(message, "wasmTerraExecuteContractTransferMessage"))
                            $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer.encode(message.wasmTerraExecuteContractTransferMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.wasmTerraExecuteContractSendMessage != null && Object.hasOwnProperty.call(message, "wasmTerraExecuteContractSendMessage"))
                            $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.encode(message.wasmTerraExecuteContractSendMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.thorchainSendMessage != null && Object.hasOwnProperty.call(message, "thorchainSendMessage"))
                            $root.TW.Cosmos.Proto.Message.THORChainSend.encode(message.thorchainSendMessage, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.wasmTerraExecuteContractGeneric != null && Object.hasOwnProperty.call(message, "wasmTerraExecuteContractGeneric"))
                            $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.encode(message.wasmTerraExecuteContractGeneric, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Message message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Message
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Message} Message
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Message.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.sendCoinsMessage = $root.TW.Cosmos.Proto.Message.Send.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.transferTokensMessage = $root.TW.Cosmos.Proto.Message.Transfer.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.stakeMessage = $root.TW.Cosmos.Proto.Message.Delegate.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.unstakeMessage = $root.TW.Cosmos.Proto.Message.Undelegate.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.restakeMessage = $root.TW.Cosmos.Proto.Message.BeginRedelegate.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.rawJsonMessage = $root.TW.Cosmos.Proto.Message.RawJSON.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.wasmTerraExecuteContractTransferMessage = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.wasmTerraExecuteContractSendMessage = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.thorchainSendMessage = $root.TW.Cosmos.Proto.Message.THORChainSend.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.wasmTerraExecuteContractGeneric = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Message message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Message
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Message.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.Send.verify(message.sendCoinsMessage);
                                if (error)
                                    return "sendCoinsMessage." + error;
                            }
                        }
                        if (message.transferTokensMessage != null && message.hasOwnProperty("transferTokensMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.Transfer.verify(message.transferTokensMessage);
                                if (error)
                                    return "transferTokensMessage." + error;
                            }
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.Delegate.verify(message.stakeMessage);
                                if (error)
                                    return "stakeMessage." + error;
                            }
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.Undelegate.verify(message.unstakeMessage);
                                if (error)
                                    return "unstakeMessage." + error;
                            }
                        }
                        if (message.restakeMessage != null && message.hasOwnProperty("restakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.BeginRedelegate.verify(message.restakeMessage);
                                if (error)
                                    return "restakeMessage." + error;
                            }
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward.verify(message.withdrawStakeRewardMessage);
                                if (error)
                                    return "withdrawStakeRewardMessage." + error;
                            }
                        }
                        if (message.rawJsonMessage != null && message.hasOwnProperty("rawJsonMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.RawJSON.verify(message.rawJsonMessage);
                                if (error)
                                    return "rawJsonMessage." + error;
                            }
                        }
                        if (message.wasmTerraExecuteContractTransferMessage != null && message.hasOwnProperty("wasmTerraExecuteContractTransferMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer.verify(message.wasmTerraExecuteContractTransferMessage);
                                if (error)
                                    return "wasmTerraExecuteContractTransferMessage." + error;
                            }
                        }
                        if (message.wasmTerraExecuteContractSendMessage != null && message.hasOwnProperty("wasmTerraExecuteContractSendMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.verify(message.wasmTerraExecuteContractSendMessage);
                                if (error)
                                    return "wasmTerraExecuteContractSendMessage." + error;
                            }
                        }
                        if (message.thorchainSendMessage != null && message.hasOwnProperty("thorchainSendMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.THORChainSend.verify(message.thorchainSendMessage);
                                if (error)
                                    return "thorchainSendMessage." + error;
                            }
                        }
                        if (message.wasmTerraExecuteContractGeneric != null && message.hasOwnProperty("wasmTerraExecuteContractGeneric")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.verify(message.wasmTerraExecuteContractGeneric);
                                if (error)
                                    return "wasmTerraExecuteContractGeneric." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Message message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Message
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Message} Message
                     */
                    Message.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Message)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Message();
                        if (object.sendCoinsMessage != null) {
                            if (typeof object.sendCoinsMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.sendCoinsMessage: object expected");
                            message.sendCoinsMessage = $root.TW.Cosmos.Proto.Message.Send.fromObject(object.sendCoinsMessage);
                        }
                        if (object.transferTokensMessage != null) {
                            if (typeof object.transferTokensMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.transferTokensMessage: object expected");
                            message.transferTokensMessage = $root.TW.Cosmos.Proto.Message.Transfer.fromObject(object.transferTokensMessage);
                        }
                        if (object.stakeMessage != null) {
                            if (typeof object.stakeMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.stakeMessage: object expected");
                            message.stakeMessage = $root.TW.Cosmos.Proto.Message.Delegate.fromObject(object.stakeMessage);
                        }
                        if (object.unstakeMessage != null) {
                            if (typeof object.unstakeMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.unstakeMessage: object expected");
                            message.unstakeMessage = $root.TW.Cosmos.Proto.Message.Undelegate.fromObject(object.unstakeMessage);
                        }
                        if (object.restakeMessage != null) {
                            if (typeof object.restakeMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.restakeMessage: object expected");
                            message.restakeMessage = $root.TW.Cosmos.Proto.Message.BeginRedelegate.fromObject(object.restakeMessage);
                        }
                        if (object.withdrawStakeRewardMessage != null) {
                            if (typeof object.withdrawStakeRewardMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.withdrawStakeRewardMessage: object expected");
                            message.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward.fromObject(object.withdrawStakeRewardMessage);
                        }
                        if (object.rawJsonMessage != null) {
                            if (typeof object.rawJsonMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.rawJsonMessage: object expected");
                            message.rawJsonMessage = $root.TW.Cosmos.Proto.Message.RawJSON.fromObject(object.rawJsonMessage);
                        }
                        if (object.wasmTerraExecuteContractTransferMessage != null) {
                            if (typeof object.wasmTerraExecuteContractTransferMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.wasmTerraExecuteContractTransferMessage: object expected");
                            message.wasmTerraExecuteContractTransferMessage = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer.fromObject(object.wasmTerraExecuteContractTransferMessage);
                        }
                        if (object.wasmTerraExecuteContractSendMessage != null) {
                            if (typeof object.wasmTerraExecuteContractSendMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.wasmTerraExecuteContractSendMessage: object expected");
                            message.wasmTerraExecuteContractSendMessage = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.fromObject(object.wasmTerraExecuteContractSendMessage);
                        }
                        if (object.thorchainSendMessage != null) {
                            if (typeof object.thorchainSendMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.thorchainSendMessage: object expected");
                            message.thorchainSendMessage = $root.TW.Cosmos.Proto.Message.THORChainSend.fromObject(object.thorchainSendMessage);
                        }
                        if (object.wasmTerraExecuteContractGeneric != null) {
                            if (typeof object.wasmTerraExecuteContractGeneric !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Message.wasmTerraExecuteContractGeneric: object expected");
                            message.wasmTerraExecuteContractGeneric = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.fromObject(object.wasmTerraExecuteContractGeneric);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Message message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Message
                     * @static
                     * @param {TW.Cosmos.Proto.Message} message Message
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Message.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            object.sendCoinsMessage = $root.TW.Cosmos.Proto.Message.Send.toObject(message.sendCoinsMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "sendCoinsMessage";
                        }
                        if (message.transferTokensMessage != null && message.hasOwnProperty("transferTokensMessage")) {
                            object.transferTokensMessage = $root.TW.Cosmos.Proto.Message.Transfer.toObject(message.transferTokensMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "transferTokensMessage";
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            object.stakeMessage = $root.TW.Cosmos.Proto.Message.Delegate.toObject(message.stakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "stakeMessage";
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            object.unstakeMessage = $root.TW.Cosmos.Proto.Message.Undelegate.toObject(message.unstakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "unstakeMessage";
                        }
                        if (message.restakeMessage != null && message.hasOwnProperty("restakeMessage")) {
                            object.restakeMessage = $root.TW.Cosmos.Proto.Message.BeginRedelegate.toObject(message.restakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "restakeMessage";
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            object.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward.toObject(message.withdrawStakeRewardMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "withdrawStakeRewardMessage";
                        }
                        if (message.rawJsonMessage != null && message.hasOwnProperty("rawJsonMessage")) {
                            object.rawJsonMessage = $root.TW.Cosmos.Proto.Message.RawJSON.toObject(message.rawJsonMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "rawJsonMessage";
                        }
                        if (message.wasmTerraExecuteContractTransferMessage != null && message.hasOwnProperty("wasmTerraExecuteContractTransferMessage")) {
                            object.wasmTerraExecuteContractTransferMessage = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer.toObject(message.wasmTerraExecuteContractTransferMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "wasmTerraExecuteContractTransferMessage";
                        }
                        if (message.wasmTerraExecuteContractSendMessage != null && message.hasOwnProperty("wasmTerraExecuteContractSendMessage")) {
                            object.wasmTerraExecuteContractSendMessage = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.toObject(message.wasmTerraExecuteContractSendMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "wasmTerraExecuteContractSendMessage";
                        }
                        if (message.thorchainSendMessage != null && message.hasOwnProperty("thorchainSendMessage")) {
                            object.thorchainSendMessage = $root.TW.Cosmos.Proto.Message.THORChainSend.toObject(message.thorchainSendMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "thorchainSendMessage";
                        }
                        if (message.wasmTerraExecuteContractGeneric != null && message.hasOwnProperty("wasmTerraExecuteContractGeneric")) {
                            object.wasmTerraExecuteContractGeneric = $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.toObject(message.wasmTerraExecuteContractGeneric, options);
                            if (options.oneofs)
                                object.messageOneof = "wasmTerraExecuteContractGeneric";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Message to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Message
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Message.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Message.Send = (function() {
    
                        /**
                         * Properties of a Send.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface ISend
                         * @property {string|null} [fromAddress] Send fromAddress
                         * @property {string|null} [toAddress] Send toAddress
                         * @property {Array.<TW.Cosmos.Proto.IAmount>|null} [amounts] Send amounts
                         * @property {string|null} [typePrefix] Send typePrefix
                         */
    
                        /**
                         * Constructs a new Send.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a Send.
                         * @implements ISend
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.ISend=} [properties] Properties to set
                         */
                        function Send(properties) {
                            this.amounts = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Send fromAddress.
                         * @member {string} fromAddress
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @instance
                         */
                        Send.prototype.fromAddress = "";
    
                        /**
                         * Send toAddress.
                         * @member {string} toAddress
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @instance
                         */
                        Send.prototype.toAddress = "";
    
                        /**
                         * Send amounts.
                         * @member {Array.<TW.Cosmos.Proto.IAmount>} amounts
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @instance
                         */
                        Send.prototype.amounts = $util.emptyArray;
    
                        /**
                         * Send typePrefix.
                         * @member {string} typePrefix
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @instance
                         */
                        Send.prototype.typePrefix = "";
    
                        /**
                         * Creates a new Send instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @static
                         * @param {TW.Cosmos.Proto.Message.ISend=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.Send} Send instance
                         */
                        Send.create = function create(properties) {
                            return new Send(properties);
                        };
    
                        /**
                         * Encodes the specified Send message. Does not implicitly {@link TW.Cosmos.Proto.Message.Send.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @static
                         * @param {TW.Cosmos.Proto.Message.ISend} message Send message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Send.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                            if (message.amounts != null && message.amounts.length)
                                for (var i = 0; i < message.amounts.length; ++i)
                                    $root.TW.Cosmos.Proto.Amount.encode(message.amounts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.typePrefix != null && Object.hasOwnProperty.call(message, "typePrefix"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.typePrefix);
                            return writer;
                        };
    
                        /**
                         * Decodes a Send message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.Send} Send
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Send.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.Send();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.fromAddress = reader.string();
                                    break;
                                case 2:
                                    message.toAddress = reader.string();
                                    break;
                                case 3:
                                    if (!(message.amounts && message.amounts.length))
                                        message.amounts = [];
                                    message.amounts.push($root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32()));
                                    break;
                                case 4:
                                    message.typePrefix = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Send message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Send.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                                if (!$util.isString(message.fromAddress))
                                    return "fromAddress: string expected";
                            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                                if (!$util.isString(message.toAddress))
                                    return "toAddress: string expected";
                            if (message.amounts != null && message.hasOwnProperty("amounts")) {
                                if (!Array.isArray(message.amounts))
                                    return "amounts: array expected";
                                for (var i = 0; i < message.amounts.length; ++i) {
                                    var error = $root.TW.Cosmos.Proto.Amount.verify(message.amounts[i]);
                                    if (error)
                                        return "amounts." + error;
                                }
                            }
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                if (!$util.isString(message.typePrefix))
                                    return "typePrefix: string expected";
                            return null;
                        };
    
                        /**
                         * Creates a Send message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.Send} Send
                         */
                        Send.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.Send)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.Send();
                            if (object.fromAddress != null)
                                message.fromAddress = String(object.fromAddress);
                            if (object.toAddress != null)
                                message.toAddress = String(object.toAddress);
                            if (object.amounts) {
                                if (!Array.isArray(object.amounts))
                                    throw TypeError(".TW.Cosmos.Proto.Message.Send.amounts: array expected");
                                message.amounts = [];
                                for (var i = 0; i < object.amounts.length; ++i) {
                                    if (typeof object.amounts[i] !== "object")
                                        throw TypeError(".TW.Cosmos.Proto.Message.Send.amounts: object expected");
                                    message.amounts[i] = $root.TW.Cosmos.Proto.Amount.fromObject(object.amounts[i]);
                                }
                            }
                            if (object.typePrefix != null)
                                message.typePrefix = String(object.typePrefix);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Send message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @static
                         * @param {TW.Cosmos.Proto.Message.Send} message Send
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Send.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.amounts = [];
                            if (options.defaults) {
                                object.fromAddress = "";
                                object.toAddress = "";
                                object.typePrefix = "";
                            }
                            if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                                object.fromAddress = message.fromAddress;
                            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                                object.toAddress = message.toAddress;
                            if (message.amounts && message.amounts.length) {
                                object.amounts = [];
                                for (var j = 0; j < message.amounts.length; ++j)
                                    object.amounts[j] = $root.TW.Cosmos.Proto.Amount.toObject(message.amounts[j], options);
                            }
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                object.typePrefix = message.typePrefix;
                            return object;
                        };
    
                        /**
                         * Converts this Send to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.Send
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Send.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Send;
                    })();
    
                    Message.Transfer = (function() {
    
                        /**
                         * Properties of a Transfer.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface ITransfer
                         * @property {string|null} [sourcePort] Transfer sourcePort
                         * @property {string|null} [sourceChannel] Transfer sourceChannel
                         * @property {TW.Cosmos.Proto.IAmount|null} [token] Transfer token
                         * @property {string|null} [sender] Transfer sender
                         * @property {string|null} [receiver] Transfer receiver
                         * @property {TW.Cosmos.Proto.IHeight|null} [timeoutHeight] Transfer timeoutHeight
                         * @property {Long|null} [timeoutTimestamp] Transfer timeoutTimestamp
                         */
    
                        /**
                         * Constructs a new Transfer.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a Transfer.
                         * @implements ITransfer
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.ITransfer=} [properties] Properties to set
                         */
                        function Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Transfer sourcePort.
                         * @member {string} sourcePort
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         */
                        Transfer.prototype.sourcePort = "";
    
                        /**
                         * Transfer sourceChannel.
                         * @member {string} sourceChannel
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         */
                        Transfer.prototype.sourceChannel = "";
    
                        /**
                         * Transfer token.
                         * @member {TW.Cosmos.Proto.IAmount|null|undefined} token
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         */
                        Transfer.prototype.token = null;
    
                        /**
                         * Transfer sender.
                         * @member {string} sender
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         */
                        Transfer.prototype.sender = "";
    
                        /**
                         * Transfer receiver.
                         * @member {string} receiver
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         */
                        Transfer.prototype.receiver = "";
    
                        /**
                         * Transfer timeoutHeight.
                         * @member {TW.Cosmos.Proto.IHeight|null|undefined} timeoutHeight
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         */
                        Transfer.prototype.timeoutHeight = null;
    
                        /**
                         * Transfer timeoutTimestamp.
                         * @member {Long} timeoutTimestamp
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         */
                        Transfer.prototype.timeoutTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Creates a new Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @static
                         * @param {TW.Cosmos.Proto.Message.ITransfer=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.Transfer} Transfer instance
                         */
                        Transfer.create = function create(properties) {
                            return new Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified Transfer message. Does not implicitly {@link TW.Cosmos.Proto.Message.Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @static
                         * @param {TW.Cosmos.Proto.Message.ITransfer} message Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.sourcePort != null && Object.hasOwnProperty.call(message, "sourcePort"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourcePort);
                            if (message.sourceChannel != null && Object.hasOwnProperty.call(message, "sourceChannel"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceChannel);
                            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                                $root.TW.Cosmos.Proto.Amount.encode(message.token, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sender);
                            if (message.receiver != null && Object.hasOwnProperty.call(message, "receiver"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.receiver);
                            if (message.timeoutHeight != null && Object.hasOwnProperty.call(message, "timeoutHeight"))
                                $root.TW.Cosmos.Proto.Height.encode(message.timeoutHeight, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.timeoutTimestamp != null && Object.hasOwnProperty.call(message, "timeoutTimestamp"))
                                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.timeoutTimestamp);
                            return writer;
                        };
    
                        /**
                         * Decodes a Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.Transfer} Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.sourcePort = reader.string();
                                    break;
                                case 2:
                                    message.sourceChannel = reader.string();
                                    break;
                                case 3:
                                    message.token = $root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32());
                                    break;
                                case 4:
                                    message.sender = reader.string();
                                    break;
                                case 5:
                                    message.receiver = reader.string();
                                    break;
                                case 6:
                                    message.timeoutHeight = $root.TW.Cosmos.Proto.Height.decode(reader, reader.uint32());
                                    break;
                                case 7:
                                    message.timeoutTimestamp = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Transfer message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.sourcePort != null && message.hasOwnProperty("sourcePort"))
                                if (!$util.isString(message.sourcePort))
                                    return "sourcePort: string expected";
                            if (message.sourceChannel != null && message.hasOwnProperty("sourceChannel"))
                                if (!$util.isString(message.sourceChannel))
                                    return "sourceChannel: string expected";
                            if (message.token != null && message.hasOwnProperty("token")) {
                                var error = $root.TW.Cosmos.Proto.Amount.verify(message.token);
                                if (error)
                                    return "token." + error;
                            }
                            if (message.sender != null && message.hasOwnProperty("sender"))
                                if (!$util.isString(message.sender))
                                    return "sender: string expected";
                            if (message.receiver != null && message.hasOwnProperty("receiver"))
                                if (!$util.isString(message.receiver))
                                    return "receiver: string expected";
                            if (message.timeoutHeight != null && message.hasOwnProperty("timeoutHeight")) {
                                var error = $root.TW.Cosmos.Proto.Height.verify(message.timeoutHeight);
                                if (error)
                                    return "timeoutHeight." + error;
                            }
                            if (message.timeoutTimestamp != null && message.hasOwnProperty("timeoutTimestamp"))
                                if (!$util.isInteger(message.timeoutTimestamp) && !(message.timeoutTimestamp && $util.isInteger(message.timeoutTimestamp.low) && $util.isInteger(message.timeoutTimestamp.high)))
                                    return "timeoutTimestamp: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.Transfer} Transfer
                         */
                        Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.Transfer)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.Transfer();
                            if (object.sourcePort != null)
                                message.sourcePort = String(object.sourcePort);
                            if (object.sourceChannel != null)
                                message.sourceChannel = String(object.sourceChannel);
                            if (object.token != null) {
                                if (typeof object.token !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.Message.Transfer.token: object expected");
                                message.token = $root.TW.Cosmos.Proto.Amount.fromObject(object.token);
                            }
                            if (object.sender != null)
                                message.sender = String(object.sender);
                            if (object.receiver != null)
                                message.receiver = String(object.receiver);
                            if (object.timeoutHeight != null) {
                                if (typeof object.timeoutHeight !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.Message.Transfer.timeoutHeight: object expected");
                                message.timeoutHeight = $root.TW.Cosmos.Proto.Height.fromObject(object.timeoutHeight);
                            }
                            if (object.timeoutTimestamp != null)
                                if ($util.Long)
                                    (message.timeoutTimestamp = $util.Long.fromValue(object.timeoutTimestamp)).unsigned = true;
                                else if (typeof object.timeoutTimestamp === "string")
                                    message.timeoutTimestamp = parseInt(object.timeoutTimestamp, 10);
                                else if (typeof object.timeoutTimestamp === "number")
                                    message.timeoutTimestamp = object.timeoutTimestamp;
                                else if (typeof object.timeoutTimestamp === "object")
                                    message.timeoutTimestamp = new $util.LongBits(object.timeoutTimestamp.low >>> 0, object.timeoutTimestamp.high >>> 0).toNumber(true);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @static
                         * @param {TW.Cosmos.Proto.Message.Transfer} message Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.sourcePort = "";
                                object.sourceChannel = "";
                                object.token = null;
                                object.sender = "";
                                object.receiver = "";
                                object.timeoutHeight = null;
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.timeoutTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.timeoutTimestamp = options.longs === String ? "0" : 0;
                            }
                            if (message.sourcePort != null && message.hasOwnProperty("sourcePort"))
                                object.sourcePort = message.sourcePort;
                            if (message.sourceChannel != null && message.hasOwnProperty("sourceChannel"))
                                object.sourceChannel = message.sourceChannel;
                            if (message.token != null && message.hasOwnProperty("token"))
                                object.token = $root.TW.Cosmos.Proto.Amount.toObject(message.token, options);
                            if (message.sender != null && message.hasOwnProperty("sender"))
                                object.sender = message.sender;
                            if (message.receiver != null && message.hasOwnProperty("receiver"))
                                object.receiver = message.receiver;
                            if (message.timeoutHeight != null && message.hasOwnProperty("timeoutHeight"))
                                object.timeoutHeight = $root.TW.Cosmos.Proto.Height.toObject(message.timeoutHeight, options);
                            if (message.timeoutTimestamp != null && message.hasOwnProperty("timeoutTimestamp"))
                                if (typeof message.timeoutTimestamp === "number")
                                    object.timeoutTimestamp = options.longs === String ? String(message.timeoutTimestamp) : message.timeoutTimestamp;
                                else
                                    object.timeoutTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutTimestamp) : options.longs === Number ? new $util.LongBits(message.timeoutTimestamp.low >>> 0, message.timeoutTimestamp.high >>> 0).toNumber(true) : message.timeoutTimestamp;
                            return object;
                        };
    
                        /**
                         * Converts this Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Transfer;
                    })();
    
                    Message.Delegate = (function() {
    
                        /**
                         * Properties of a Delegate.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IDelegate
                         * @property {string|null} [delegatorAddress] Delegate delegatorAddress
                         * @property {string|null} [validatorAddress] Delegate validatorAddress
                         * @property {TW.Cosmos.Proto.IAmount|null} [amount] Delegate amount
                         * @property {string|null} [typePrefix] Delegate typePrefix
                         */
    
                        /**
                         * Constructs a new Delegate.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a Delegate.
                         * @implements IDelegate
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IDelegate=} [properties] Properties to set
                         */
                        function Delegate(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Delegate delegatorAddress.
                         * @member {string} delegatorAddress
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @instance
                         */
                        Delegate.prototype.delegatorAddress = "";
    
                        /**
                         * Delegate validatorAddress.
                         * @member {string} validatorAddress
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @instance
                         */
                        Delegate.prototype.validatorAddress = "";
    
                        /**
                         * Delegate amount.
                         * @member {TW.Cosmos.Proto.IAmount|null|undefined} amount
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @instance
                         */
                        Delegate.prototype.amount = null;
    
                        /**
                         * Delegate typePrefix.
                         * @member {string} typePrefix
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @instance
                         */
                        Delegate.prototype.typePrefix = "";
    
                        /**
                         * Creates a new Delegate instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IDelegate=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.Delegate} Delegate instance
                         */
                        Delegate.create = function create(properties) {
                            return new Delegate(properties);
                        };
    
                        /**
                         * Encodes the specified Delegate message. Does not implicitly {@link TW.Cosmos.Proto.Message.Delegate.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IDelegate} message Delegate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Delegate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.delegatorAddress != null && Object.hasOwnProperty.call(message, "delegatorAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                            if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                $root.TW.Cosmos.Proto.Amount.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.typePrefix != null && Object.hasOwnProperty.call(message, "typePrefix"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.typePrefix);
                            return writer;
                        };
    
                        /**
                         * Decodes a Delegate message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.Delegate} Delegate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Delegate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.Delegate();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.delegatorAddress = reader.string();
                                    break;
                                case 2:
                                    message.validatorAddress = reader.string();
                                    break;
                                case 3:
                                    message.amount = $root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32());
                                    break;
                                case 4:
                                    message.typePrefix = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Delegate message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Delegate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                if (!$util.isString(message.delegatorAddress))
                                    return "delegatorAddress: string expected";
                            if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                                if (!$util.isString(message.validatorAddress))
                                    return "validatorAddress: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount")) {
                                var error = $root.TW.Cosmos.Proto.Amount.verify(message.amount);
                                if (error)
                                    return "amount." + error;
                            }
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                if (!$util.isString(message.typePrefix))
                                    return "typePrefix: string expected";
                            return null;
                        };
    
                        /**
                         * Creates a Delegate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.Delegate} Delegate
                         */
                        Delegate.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.Delegate)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.Delegate();
                            if (object.delegatorAddress != null)
                                message.delegatorAddress = String(object.delegatorAddress);
                            if (object.validatorAddress != null)
                                message.validatorAddress = String(object.validatorAddress);
                            if (object.amount != null) {
                                if (typeof object.amount !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.Message.Delegate.amount: object expected");
                                message.amount = $root.TW.Cosmos.Proto.Amount.fromObject(object.amount);
                            }
                            if (object.typePrefix != null)
                                message.typePrefix = String(object.typePrefix);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Delegate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.Delegate} message Delegate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Delegate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.delegatorAddress = "";
                                object.validatorAddress = "";
                                object.amount = null;
                                object.typePrefix = "";
                            }
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                object.delegatorAddress = message.delegatorAddress;
                            if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                                object.validatorAddress = message.validatorAddress;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = $root.TW.Cosmos.Proto.Amount.toObject(message.amount, options);
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                object.typePrefix = message.typePrefix;
                            return object;
                        };
    
                        /**
                         * Converts this Delegate to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.Delegate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Delegate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Delegate;
                    })();
    
                    Message.Undelegate = (function() {
    
                        /**
                         * Properties of an Undelegate.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IUndelegate
                         * @property {string|null} [delegatorAddress] Undelegate delegatorAddress
                         * @property {string|null} [validatorAddress] Undelegate validatorAddress
                         * @property {TW.Cosmos.Proto.IAmount|null} [amount] Undelegate amount
                         * @property {string|null} [typePrefix] Undelegate typePrefix
                         */
    
                        /**
                         * Constructs a new Undelegate.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents an Undelegate.
                         * @implements IUndelegate
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IUndelegate=} [properties] Properties to set
                         */
                        function Undelegate(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Undelegate delegatorAddress.
                         * @member {string} delegatorAddress
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @instance
                         */
                        Undelegate.prototype.delegatorAddress = "";
    
                        /**
                         * Undelegate validatorAddress.
                         * @member {string} validatorAddress
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @instance
                         */
                        Undelegate.prototype.validatorAddress = "";
    
                        /**
                         * Undelegate amount.
                         * @member {TW.Cosmos.Proto.IAmount|null|undefined} amount
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @instance
                         */
                        Undelegate.prototype.amount = null;
    
                        /**
                         * Undelegate typePrefix.
                         * @member {string} typePrefix
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @instance
                         */
                        Undelegate.prototype.typePrefix = "";
    
                        /**
                         * Creates a new Undelegate instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IUndelegate=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.Undelegate} Undelegate instance
                         */
                        Undelegate.create = function create(properties) {
                            return new Undelegate(properties);
                        };
    
                        /**
                         * Encodes the specified Undelegate message. Does not implicitly {@link TW.Cosmos.Proto.Message.Undelegate.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IUndelegate} message Undelegate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Undelegate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.delegatorAddress != null && Object.hasOwnProperty.call(message, "delegatorAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                            if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                $root.TW.Cosmos.Proto.Amount.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.typePrefix != null && Object.hasOwnProperty.call(message, "typePrefix"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.typePrefix);
                            return writer;
                        };
    
                        /**
                         * Decodes an Undelegate message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.Undelegate} Undelegate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Undelegate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.Undelegate();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.delegatorAddress = reader.string();
                                    break;
                                case 2:
                                    message.validatorAddress = reader.string();
                                    break;
                                case 3:
                                    message.amount = $root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32());
                                    break;
                                case 4:
                                    message.typePrefix = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies an Undelegate message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Undelegate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                if (!$util.isString(message.delegatorAddress))
                                    return "delegatorAddress: string expected";
                            if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                                if (!$util.isString(message.validatorAddress))
                                    return "validatorAddress: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount")) {
                                var error = $root.TW.Cosmos.Proto.Amount.verify(message.amount);
                                if (error)
                                    return "amount." + error;
                            }
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                if (!$util.isString(message.typePrefix))
                                    return "typePrefix: string expected";
                            return null;
                        };
    
                        /**
                         * Creates an Undelegate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.Undelegate} Undelegate
                         */
                        Undelegate.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.Undelegate)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.Undelegate();
                            if (object.delegatorAddress != null)
                                message.delegatorAddress = String(object.delegatorAddress);
                            if (object.validatorAddress != null)
                                message.validatorAddress = String(object.validatorAddress);
                            if (object.amount != null) {
                                if (typeof object.amount !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.Message.Undelegate.amount: object expected");
                                message.amount = $root.TW.Cosmos.Proto.Amount.fromObject(object.amount);
                            }
                            if (object.typePrefix != null)
                                message.typePrefix = String(object.typePrefix);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an Undelegate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.Undelegate} message Undelegate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Undelegate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.delegatorAddress = "";
                                object.validatorAddress = "";
                                object.amount = null;
                                object.typePrefix = "";
                            }
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                object.delegatorAddress = message.delegatorAddress;
                            if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                                object.validatorAddress = message.validatorAddress;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = $root.TW.Cosmos.Proto.Amount.toObject(message.amount, options);
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                object.typePrefix = message.typePrefix;
                            return object;
                        };
    
                        /**
                         * Converts this Undelegate to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.Undelegate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Undelegate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Undelegate;
                    })();
    
                    Message.BeginRedelegate = (function() {
    
                        /**
                         * Properties of a BeginRedelegate.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IBeginRedelegate
                         * @property {string|null} [delegatorAddress] BeginRedelegate delegatorAddress
                         * @property {string|null} [validatorSrcAddress] BeginRedelegate validatorSrcAddress
                         * @property {string|null} [validatorDstAddress] BeginRedelegate validatorDstAddress
                         * @property {TW.Cosmos.Proto.IAmount|null} [amount] BeginRedelegate amount
                         * @property {string|null} [typePrefix] BeginRedelegate typePrefix
                         */
    
                        /**
                         * Constructs a new BeginRedelegate.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a BeginRedelegate.
                         * @implements IBeginRedelegate
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IBeginRedelegate=} [properties] Properties to set
                         */
                        function BeginRedelegate(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * BeginRedelegate delegatorAddress.
                         * @member {string} delegatorAddress
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @instance
                         */
                        BeginRedelegate.prototype.delegatorAddress = "";
    
                        /**
                         * BeginRedelegate validatorSrcAddress.
                         * @member {string} validatorSrcAddress
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @instance
                         */
                        BeginRedelegate.prototype.validatorSrcAddress = "";
    
                        /**
                         * BeginRedelegate validatorDstAddress.
                         * @member {string} validatorDstAddress
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @instance
                         */
                        BeginRedelegate.prototype.validatorDstAddress = "";
    
                        /**
                         * BeginRedelegate amount.
                         * @member {TW.Cosmos.Proto.IAmount|null|undefined} amount
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @instance
                         */
                        BeginRedelegate.prototype.amount = null;
    
                        /**
                         * BeginRedelegate typePrefix.
                         * @member {string} typePrefix
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @instance
                         */
                        BeginRedelegate.prototype.typePrefix = "";
    
                        /**
                         * Creates a new BeginRedelegate instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IBeginRedelegate=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.BeginRedelegate} BeginRedelegate instance
                         */
                        BeginRedelegate.create = function create(properties) {
                            return new BeginRedelegate(properties);
                        };
    
                        /**
                         * Encodes the specified BeginRedelegate message. Does not implicitly {@link TW.Cosmos.Proto.Message.BeginRedelegate.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IBeginRedelegate} message BeginRedelegate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BeginRedelegate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.delegatorAddress != null && Object.hasOwnProperty.call(message, "delegatorAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                            if (message.validatorSrcAddress != null && Object.hasOwnProperty.call(message, "validatorSrcAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorSrcAddress);
                            if (message.validatorDstAddress != null && Object.hasOwnProperty.call(message, "validatorDstAddress"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.validatorDstAddress);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                $root.TW.Cosmos.Proto.Amount.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.typePrefix != null && Object.hasOwnProperty.call(message, "typePrefix"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.typePrefix);
                            return writer;
                        };
    
                        /**
                         * Decodes a BeginRedelegate message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.BeginRedelegate} BeginRedelegate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BeginRedelegate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.BeginRedelegate();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.delegatorAddress = reader.string();
                                    break;
                                case 2:
                                    message.validatorSrcAddress = reader.string();
                                    break;
                                case 3:
                                    message.validatorDstAddress = reader.string();
                                    break;
                                case 4:
                                    message.amount = $root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32());
                                    break;
                                case 5:
                                    message.typePrefix = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a BeginRedelegate message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BeginRedelegate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                if (!$util.isString(message.delegatorAddress))
                                    return "delegatorAddress: string expected";
                            if (message.validatorSrcAddress != null && message.hasOwnProperty("validatorSrcAddress"))
                                if (!$util.isString(message.validatorSrcAddress))
                                    return "validatorSrcAddress: string expected";
                            if (message.validatorDstAddress != null && message.hasOwnProperty("validatorDstAddress"))
                                if (!$util.isString(message.validatorDstAddress))
                                    return "validatorDstAddress: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount")) {
                                var error = $root.TW.Cosmos.Proto.Amount.verify(message.amount);
                                if (error)
                                    return "amount." + error;
                            }
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                if (!$util.isString(message.typePrefix))
                                    return "typePrefix: string expected";
                            return null;
                        };
    
                        /**
                         * Creates a BeginRedelegate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.BeginRedelegate} BeginRedelegate
                         */
                        BeginRedelegate.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.BeginRedelegate)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.BeginRedelegate();
                            if (object.delegatorAddress != null)
                                message.delegatorAddress = String(object.delegatorAddress);
                            if (object.validatorSrcAddress != null)
                                message.validatorSrcAddress = String(object.validatorSrcAddress);
                            if (object.validatorDstAddress != null)
                                message.validatorDstAddress = String(object.validatorDstAddress);
                            if (object.amount != null) {
                                if (typeof object.amount !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.Message.BeginRedelegate.amount: object expected");
                                message.amount = $root.TW.Cosmos.Proto.Amount.fromObject(object.amount);
                            }
                            if (object.typePrefix != null)
                                message.typePrefix = String(object.typePrefix);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a BeginRedelegate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @static
                         * @param {TW.Cosmos.Proto.Message.BeginRedelegate} message BeginRedelegate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BeginRedelegate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.delegatorAddress = "";
                                object.validatorSrcAddress = "";
                                object.validatorDstAddress = "";
                                object.amount = null;
                                object.typePrefix = "";
                            }
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                object.delegatorAddress = message.delegatorAddress;
                            if (message.validatorSrcAddress != null && message.hasOwnProperty("validatorSrcAddress"))
                                object.validatorSrcAddress = message.validatorSrcAddress;
                            if (message.validatorDstAddress != null && message.hasOwnProperty("validatorDstAddress"))
                                object.validatorDstAddress = message.validatorDstAddress;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = $root.TW.Cosmos.Proto.Amount.toObject(message.amount, options);
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                object.typePrefix = message.typePrefix;
                            return object;
                        };
    
                        /**
                         * Converts this BeginRedelegate to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.BeginRedelegate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BeginRedelegate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return BeginRedelegate;
                    })();
    
                    Message.WithdrawDelegationReward = (function() {
    
                        /**
                         * Properties of a WithdrawDelegationReward.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IWithdrawDelegationReward
                         * @property {string|null} [delegatorAddress] WithdrawDelegationReward delegatorAddress
                         * @property {string|null} [validatorAddress] WithdrawDelegationReward validatorAddress
                         * @property {string|null} [typePrefix] WithdrawDelegationReward typePrefix
                         */
    
                        /**
                         * Constructs a new WithdrawDelegationReward.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a WithdrawDelegationReward.
                         * @implements IWithdrawDelegationReward
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IWithdrawDelegationReward=} [properties] Properties to set
                         */
                        function WithdrawDelegationReward(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * WithdrawDelegationReward delegatorAddress.
                         * @member {string} delegatorAddress
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @instance
                         */
                        WithdrawDelegationReward.prototype.delegatorAddress = "";
    
                        /**
                         * WithdrawDelegationReward validatorAddress.
                         * @member {string} validatorAddress
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @instance
                         */
                        WithdrawDelegationReward.prototype.validatorAddress = "";
    
                        /**
                         * WithdrawDelegationReward typePrefix.
                         * @member {string} typePrefix
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @instance
                         */
                        WithdrawDelegationReward.prototype.typePrefix = "";
    
                        /**
                         * Creates a new WithdrawDelegationReward instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWithdrawDelegationReward=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.WithdrawDelegationReward} WithdrawDelegationReward instance
                         */
                        WithdrawDelegationReward.create = function create(properties) {
                            return new WithdrawDelegationReward(properties);
                        };
    
                        /**
                         * Encodes the specified WithdrawDelegationReward message. Does not implicitly {@link TW.Cosmos.Proto.Message.WithdrawDelegationReward.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWithdrawDelegationReward} message WithdrawDelegationReward message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        WithdrawDelegationReward.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.delegatorAddress != null && Object.hasOwnProperty.call(message, "delegatorAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                            if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                            if (message.typePrefix != null && Object.hasOwnProperty.call(message, "typePrefix"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.typePrefix);
                            return writer;
                        };
    
                        /**
                         * Decodes a WithdrawDelegationReward message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.WithdrawDelegationReward} WithdrawDelegationReward
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        WithdrawDelegationReward.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.delegatorAddress = reader.string();
                                    break;
                                case 2:
                                    message.validatorAddress = reader.string();
                                    break;
                                case 3:
                                    message.typePrefix = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a WithdrawDelegationReward message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        WithdrawDelegationReward.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                if (!$util.isString(message.delegatorAddress))
                                    return "delegatorAddress: string expected";
                            if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                                if (!$util.isString(message.validatorAddress))
                                    return "validatorAddress: string expected";
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                if (!$util.isString(message.typePrefix))
                                    return "typePrefix: string expected";
                            return null;
                        };
    
                        /**
                         * Creates a WithdrawDelegationReward message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.WithdrawDelegationReward} WithdrawDelegationReward
                         */
                        WithdrawDelegationReward.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.WithdrawDelegationReward();
                            if (object.delegatorAddress != null)
                                message.delegatorAddress = String(object.delegatorAddress);
                            if (object.validatorAddress != null)
                                message.validatorAddress = String(object.validatorAddress);
                            if (object.typePrefix != null)
                                message.typePrefix = String(object.typePrefix);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a WithdrawDelegationReward message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @static
                         * @param {TW.Cosmos.Proto.Message.WithdrawDelegationReward} message WithdrawDelegationReward
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        WithdrawDelegationReward.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.delegatorAddress = "";
                                object.validatorAddress = "";
                                object.typePrefix = "";
                            }
                            if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                                object.delegatorAddress = message.delegatorAddress;
                            if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                                object.validatorAddress = message.validatorAddress;
                            if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                                object.typePrefix = message.typePrefix;
                            return object;
                        };
    
                        /**
                         * Converts this WithdrawDelegationReward to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.WithdrawDelegationReward
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        WithdrawDelegationReward.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return WithdrawDelegationReward;
                    })();
    
                    Message.WasmTerraExecuteContractTransfer = (function() {
    
                        /**
                         * Properties of a WasmTerraExecuteContractTransfer.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IWasmTerraExecuteContractTransfer
                         * @property {string|null} [senderAddress] WasmTerraExecuteContractTransfer senderAddress
                         * @property {string|null} [contractAddress] WasmTerraExecuteContractTransfer contractAddress
                         * @property {Uint8Array|null} [amount] WasmTerraExecuteContractTransfer amount
                         * @property {string|null} [recipientAddress] WasmTerraExecuteContractTransfer recipientAddress
                         */
    
                        /**
                         * Constructs a new WasmTerraExecuteContractTransfer.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a WasmTerraExecuteContractTransfer.
                         * @implements IWasmTerraExecuteContractTransfer
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer=} [properties] Properties to set
                         */
                        function WasmTerraExecuteContractTransfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * WasmTerraExecuteContractTransfer senderAddress.
                         * @member {string} senderAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @instance
                         */
                        WasmTerraExecuteContractTransfer.prototype.senderAddress = "";
    
                        /**
                         * WasmTerraExecuteContractTransfer contractAddress.
                         * @member {string} contractAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @instance
                         */
                        WasmTerraExecuteContractTransfer.prototype.contractAddress = "";
    
                        /**
                         * WasmTerraExecuteContractTransfer amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @instance
                         */
                        WasmTerraExecuteContractTransfer.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * WasmTerraExecuteContractTransfer recipientAddress.
                         * @member {string} recipientAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @instance
                         */
                        WasmTerraExecuteContractTransfer.prototype.recipientAddress = "";
    
                        /**
                         * Creates a new WasmTerraExecuteContractTransfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer} WasmTerraExecuteContractTransfer instance
                         */
                        WasmTerraExecuteContractTransfer.create = function create(properties) {
                            return new WasmTerraExecuteContractTransfer(properties);
                        };
    
                        /**
                         * Encodes the specified WasmTerraExecuteContractTransfer message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer} message WasmTerraExecuteContractTransfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        WasmTerraExecuteContractTransfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.senderAddress != null && Object.hasOwnProperty.call(message, "senderAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderAddress);
                            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractAddress);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.amount);
                            if (message.recipientAddress != null && Object.hasOwnProperty.call(message, "recipientAddress"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.recipientAddress);
                            return writer;
                        };
    
                        /**
                         * Decodes a WasmTerraExecuteContractTransfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer} WasmTerraExecuteContractTransfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        WasmTerraExecuteContractTransfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.senderAddress = reader.string();
                                    break;
                                case 2:
                                    message.contractAddress = reader.string();
                                    break;
                                case 3:
                                    message.amount = reader.bytes();
                                    break;
                                case 4:
                                    message.recipientAddress = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a WasmTerraExecuteContractTransfer message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        WasmTerraExecuteContractTransfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
                                if (!$util.isString(message.senderAddress))
                                    return "senderAddress: string expected";
                            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                                if (!$util.isString(message.contractAddress))
                                    return "contractAddress: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            if (message.recipientAddress != null && message.hasOwnProperty("recipientAddress"))
                                if (!$util.isString(message.recipientAddress))
                                    return "recipientAddress: string expected";
                            return null;
                        };
    
                        /**
                         * Creates a WasmTerraExecuteContractTransfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer} WasmTerraExecuteContractTransfer
                         */
                        WasmTerraExecuteContractTransfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer();
                            if (object.senderAddress != null)
                                message.senderAddress = String(object.senderAddress);
                            if (object.contractAddress != null)
                                message.contractAddress = String(object.contractAddress);
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            if (object.recipientAddress != null)
                                message.recipientAddress = String(object.recipientAddress);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a WasmTerraExecuteContractTransfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @static
                         * @param {TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer} message WasmTerraExecuteContractTransfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        WasmTerraExecuteContractTransfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.senderAddress = "";
                                object.contractAddress = "";
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                                object.recipientAddress = "";
                            }
                            if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
                                object.senderAddress = message.senderAddress;
                            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                                object.contractAddress = message.contractAddress;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            if (message.recipientAddress != null && message.hasOwnProperty("recipientAddress"))
                                object.recipientAddress = message.recipientAddress;
                            return object;
                        };
    
                        /**
                         * Converts this WasmTerraExecuteContractTransfer to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        WasmTerraExecuteContractTransfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return WasmTerraExecuteContractTransfer;
                    })();
    
                    Message.WasmTerraExecuteContractSend = (function() {
    
                        /**
                         * Properties of a WasmTerraExecuteContractSend.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IWasmTerraExecuteContractSend
                         * @property {string|null} [senderAddress] WasmTerraExecuteContractSend senderAddress
                         * @property {string|null} [contractAddress] WasmTerraExecuteContractSend contractAddress
                         * @property {Uint8Array|null} [amount] WasmTerraExecuteContractSend amount
                         * @property {string|null} [recipientContractAddress] WasmTerraExecuteContractSend recipientContractAddress
                         * @property {string|null} [msg] WasmTerraExecuteContractSend msg
                         * @property {Array.<string>|null} [coin] WasmTerraExecuteContractSend coin
                         */
    
                        /**
                         * Constructs a new WasmTerraExecuteContractSend.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a WasmTerraExecuteContractSend.
                         * @implements IWasmTerraExecuteContractSend
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend=} [properties] Properties to set
                         */
                        function WasmTerraExecuteContractSend(properties) {
                            this.coin = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * WasmTerraExecuteContractSend senderAddress.
                         * @member {string} senderAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @instance
                         */
                        WasmTerraExecuteContractSend.prototype.senderAddress = "";
    
                        /**
                         * WasmTerraExecuteContractSend contractAddress.
                         * @member {string} contractAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @instance
                         */
                        WasmTerraExecuteContractSend.prototype.contractAddress = "";
    
                        /**
                         * WasmTerraExecuteContractSend amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @instance
                         */
                        WasmTerraExecuteContractSend.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * WasmTerraExecuteContractSend recipientContractAddress.
                         * @member {string} recipientContractAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @instance
                         */
                        WasmTerraExecuteContractSend.prototype.recipientContractAddress = "";
    
                        /**
                         * WasmTerraExecuteContractSend msg.
                         * @member {string} msg
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @instance
                         */
                        WasmTerraExecuteContractSend.prototype.msg = "";
    
                        /**
                         * WasmTerraExecuteContractSend coin.
                         * @member {Array.<string>} coin
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @instance
                         */
                        WasmTerraExecuteContractSend.prototype.coin = $util.emptyArray;
    
                        /**
                         * Creates a new WasmTerraExecuteContractSend instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend} WasmTerraExecuteContractSend instance
                         */
                        WasmTerraExecuteContractSend.create = function create(properties) {
                            return new WasmTerraExecuteContractSend(properties);
                        };
    
                        /**
                         * Encodes the specified WasmTerraExecuteContractSend message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend} message WasmTerraExecuteContractSend message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        WasmTerraExecuteContractSend.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.senderAddress != null && Object.hasOwnProperty.call(message, "senderAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderAddress);
                            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractAddress);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.amount);
                            if (message.recipientContractAddress != null && Object.hasOwnProperty.call(message, "recipientContractAddress"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.recipientContractAddress);
                            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.msg);
                            if (message.coin != null && message.coin.length)
                                for (var i = 0; i < message.coin.length; ++i)
                                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.coin[i]);
                            return writer;
                        };
    
                        /**
                         * Decodes a WasmTerraExecuteContractSend message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend} WasmTerraExecuteContractSend
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        WasmTerraExecuteContractSend.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.senderAddress = reader.string();
                                    break;
                                case 2:
                                    message.contractAddress = reader.string();
                                    break;
                                case 3:
                                    message.amount = reader.bytes();
                                    break;
                                case 4:
                                    message.recipientContractAddress = reader.string();
                                    break;
                                case 5:
                                    message.msg = reader.string();
                                    break;
                                case 6:
                                    if (!(message.coin && message.coin.length))
                                        message.coin = [];
                                    message.coin.push(reader.string());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a WasmTerraExecuteContractSend message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        WasmTerraExecuteContractSend.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
                                if (!$util.isString(message.senderAddress))
                                    return "senderAddress: string expected";
                            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                                if (!$util.isString(message.contractAddress))
                                    return "contractAddress: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            if (message.recipientContractAddress != null && message.hasOwnProperty("recipientContractAddress"))
                                if (!$util.isString(message.recipientContractAddress))
                                    return "recipientContractAddress: string expected";
                            if (message.msg != null && message.hasOwnProperty("msg"))
                                if (!$util.isString(message.msg))
                                    return "msg: string expected";
                            if (message.coin != null && message.hasOwnProperty("coin")) {
                                if (!Array.isArray(message.coin))
                                    return "coin: array expected";
                                for (var i = 0; i < message.coin.length; ++i)
                                    if (!$util.isString(message.coin[i]))
                                        return "coin: string[] expected";
                            }
                            return null;
                        };
    
                        /**
                         * Creates a WasmTerraExecuteContractSend message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend} WasmTerraExecuteContractSend
                         */
                        WasmTerraExecuteContractSend.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend();
                            if (object.senderAddress != null)
                                message.senderAddress = String(object.senderAddress);
                            if (object.contractAddress != null)
                                message.contractAddress = String(object.contractAddress);
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            if (object.recipientContractAddress != null)
                                message.recipientContractAddress = String(object.recipientContractAddress);
                            if (object.msg != null)
                                message.msg = String(object.msg);
                            if (object.coin) {
                                if (!Array.isArray(object.coin))
                                    throw TypeError(".TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.coin: array expected");
                                message.coin = [];
                                for (var i = 0; i < object.coin.length; ++i)
                                    message.coin[i] = String(object.coin[i]);
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a WasmTerraExecuteContractSend message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @static
                         * @param {TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend} message WasmTerraExecuteContractSend
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        WasmTerraExecuteContractSend.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.coin = [];
                            if (options.defaults) {
                                object.senderAddress = "";
                                object.contractAddress = "";
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                                object.recipientContractAddress = "";
                                object.msg = "";
                            }
                            if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
                                object.senderAddress = message.senderAddress;
                            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                                object.contractAddress = message.contractAddress;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            if (message.recipientContractAddress != null && message.hasOwnProperty("recipientContractAddress"))
                                object.recipientContractAddress = message.recipientContractAddress;
                            if (message.msg != null && message.hasOwnProperty("msg"))
                                object.msg = message.msg;
                            if (message.coin && message.coin.length) {
                                object.coin = [];
                                for (var j = 0; j < message.coin.length; ++j)
                                    object.coin[j] = message.coin[j];
                            }
                            return object;
                        };
    
                        /**
                         * Converts this WasmTerraExecuteContractSend to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        WasmTerraExecuteContractSend.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return WasmTerraExecuteContractSend;
                    })();
    
                    Message.THORChainSend = (function() {
    
                        /**
                         * Properties of a THORChainSend.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface ITHORChainSend
                         * @property {Uint8Array|null} [fromAddress] THORChainSend fromAddress
                         * @property {Uint8Array|null} [toAddress] THORChainSend toAddress
                         * @property {Array.<TW.Cosmos.Proto.IAmount>|null} [amounts] THORChainSend amounts
                         */
    
                        /**
                         * Constructs a new THORChainSend.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a THORChainSend.
                         * @implements ITHORChainSend
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.ITHORChainSend=} [properties] Properties to set
                         */
                        function THORChainSend(properties) {
                            this.amounts = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * THORChainSend fromAddress.
                         * @member {Uint8Array} fromAddress
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @instance
                         */
                        THORChainSend.prototype.fromAddress = $util.newBuffer([]);
    
                        /**
                         * THORChainSend toAddress.
                         * @member {Uint8Array} toAddress
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @instance
                         */
                        THORChainSend.prototype.toAddress = $util.newBuffer([]);
    
                        /**
                         * THORChainSend amounts.
                         * @member {Array.<TW.Cosmos.Proto.IAmount>} amounts
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @instance
                         */
                        THORChainSend.prototype.amounts = $util.emptyArray;
    
                        /**
                         * Creates a new THORChainSend instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @static
                         * @param {TW.Cosmos.Proto.Message.ITHORChainSend=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.THORChainSend} THORChainSend instance
                         */
                        THORChainSend.create = function create(properties) {
                            return new THORChainSend(properties);
                        };
    
                        /**
                         * Encodes the specified THORChainSend message. Does not implicitly {@link TW.Cosmos.Proto.Message.THORChainSend.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @static
                         * @param {TW.Cosmos.Proto.Message.ITHORChainSend} message THORChainSend message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        THORChainSend.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fromAddress);
                            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.toAddress);
                            if (message.amounts != null && message.amounts.length)
                                for (var i = 0; i < message.amounts.length; ++i)
                                    $root.TW.Cosmos.Proto.Amount.encode(message.amounts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Decodes a THORChainSend message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.THORChainSend} THORChainSend
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        THORChainSend.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.THORChainSend();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.fromAddress = reader.bytes();
                                    break;
                                case 2:
                                    message.toAddress = reader.bytes();
                                    break;
                                case 3:
                                    if (!(message.amounts && message.amounts.length))
                                        message.amounts = [];
                                    message.amounts.push($root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a THORChainSend message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        THORChainSend.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                                if (!(message.fromAddress && typeof message.fromAddress.length === "number" || $util.isString(message.fromAddress)))
                                    return "fromAddress: buffer expected";
                            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                                if (!(message.toAddress && typeof message.toAddress.length === "number" || $util.isString(message.toAddress)))
                                    return "toAddress: buffer expected";
                            if (message.amounts != null && message.hasOwnProperty("amounts")) {
                                if (!Array.isArray(message.amounts))
                                    return "amounts: array expected";
                                for (var i = 0; i < message.amounts.length; ++i) {
                                    var error = $root.TW.Cosmos.Proto.Amount.verify(message.amounts[i]);
                                    if (error)
                                        return "amounts." + error;
                                }
                            }
                            return null;
                        };
    
                        /**
                         * Creates a THORChainSend message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.THORChainSend} THORChainSend
                         */
                        THORChainSend.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.THORChainSend)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.THORChainSend();
                            if (object.fromAddress != null)
                                if (typeof object.fromAddress === "string")
                                    $util.base64.decode(object.fromAddress, message.fromAddress = $util.newBuffer($util.base64.length(object.fromAddress)), 0);
                                else if (object.fromAddress.length)
                                    message.fromAddress = object.fromAddress;
                            if (object.toAddress != null)
                                if (typeof object.toAddress === "string")
                                    $util.base64.decode(object.toAddress, message.toAddress = $util.newBuffer($util.base64.length(object.toAddress)), 0);
                                else if (object.toAddress.length)
                                    message.toAddress = object.toAddress;
                            if (object.amounts) {
                                if (!Array.isArray(object.amounts))
                                    throw TypeError(".TW.Cosmos.Proto.Message.THORChainSend.amounts: array expected");
                                message.amounts = [];
                                for (var i = 0; i < object.amounts.length; ++i) {
                                    if (typeof object.amounts[i] !== "object")
                                        throw TypeError(".TW.Cosmos.Proto.Message.THORChainSend.amounts: object expected");
                                    message.amounts[i] = $root.TW.Cosmos.Proto.Amount.fromObject(object.amounts[i]);
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a THORChainSend message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @static
                         * @param {TW.Cosmos.Proto.Message.THORChainSend} message THORChainSend
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        THORChainSend.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.amounts = [];
                            if (options.defaults) {
                                if (options.bytes === String)
                                    object.fromAddress = "";
                                else {
                                    object.fromAddress = [];
                                    if (options.bytes !== Array)
                                        object.fromAddress = $util.newBuffer(object.fromAddress);
                                }
                                if (options.bytes === String)
                                    object.toAddress = "";
                                else {
                                    object.toAddress = [];
                                    if (options.bytes !== Array)
                                        object.toAddress = $util.newBuffer(object.toAddress);
                                }
                            }
                            if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                                object.fromAddress = options.bytes === String ? $util.base64.encode(message.fromAddress, 0, message.fromAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAddress) : message.fromAddress;
                            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                                object.toAddress = options.bytes === String ? $util.base64.encode(message.toAddress, 0, message.toAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAddress) : message.toAddress;
                            if (message.amounts && message.amounts.length) {
                                object.amounts = [];
                                for (var j = 0; j < message.amounts.length; ++j)
                                    object.amounts[j] = $root.TW.Cosmos.Proto.Amount.toObject(message.amounts[j], options);
                            }
                            return object;
                        };
    
                        /**
                         * Converts this THORChainSend to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.THORChainSend
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        THORChainSend.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return THORChainSend;
                    })();
    
                    Message.WasmTerraExecuteContractGeneric = (function() {
    
                        /**
                         * Properties of a WasmTerraExecuteContractGeneric.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IWasmTerraExecuteContractGeneric
                         * @property {string|null} [senderAddress] WasmTerraExecuteContractGeneric senderAddress
                         * @property {string|null} [contractAddress] WasmTerraExecuteContractGeneric contractAddress
                         * @property {string|null} [executeMsg] WasmTerraExecuteContractGeneric executeMsg
                         * @property {Array.<TW.Cosmos.Proto.IAmount>|null} [coins] WasmTerraExecuteContractGeneric coins
                         */
    
                        /**
                         * Constructs a new WasmTerraExecuteContractGeneric.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a WasmTerraExecuteContractGeneric.
                         * @implements IWasmTerraExecuteContractGeneric
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric=} [properties] Properties to set
                         */
                        function WasmTerraExecuteContractGeneric(properties) {
                            this.coins = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * WasmTerraExecuteContractGeneric senderAddress.
                         * @member {string} senderAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @instance
                         */
                        WasmTerraExecuteContractGeneric.prototype.senderAddress = "";
    
                        /**
                         * WasmTerraExecuteContractGeneric contractAddress.
                         * @member {string} contractAddress
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @instance
                         */
                        WasmTerraExecuteContractGeneric.prototype.contractAddress = "";
    
                        /**
                         * WasmTerraExecuteContractGeneric executeMsg.
                         * @member {string} executeMsg
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @instance
                         */
                        WasmTerraExecuteContractGeneric.prototype.executeMsg = "";
    
                        /**
                         * WasmTerraExecuteContractGeneric coins.
                         * @member {Array.<TW.Cosmos.Proto.IAmount>} coins
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @instance
                         */
                        WasmTerraExecuteContractGeneric.prototype.coins = $util.emptyArray;
    
                        /**
                         * Creates a new WasmTerraExecuteContractGeneric instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric} WasmTerraExecuteContractGeneric instance
                         */
                        WasmTerraExecuteContractGeneric.create = function create(properties) {
                            return new WasmTerraExecuteContractGeneric(properties);
                        };
    
                        /**
                         * Encodes the specified WasmTerraExecuteContractGeneric message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric} message WasmTerraExecuteContractGeneric message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        WasmTerraExecuteContractGeneric.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.senderAddress != null && Object.hasOwnProperty.call(message, "senderAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderAddress);
                            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractAddress);
                            if (message.executeMsg != null && Object.hasOwnProperty.call(message, "executeMsg"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.executeMsg);
                            if (message.coins != null && message.coins.length)
                                for (var i = 0; i < message.coins.length; ++i)
                                    $root.TW.Cosmos.Proto.Amount.encode(message.coins[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Decodes a WasmTerraExecuteContractGeneric message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric} WasmTerraExecuteContractGeneric
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        WasmTerraExecuteContractGeneric.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.senderAddress = reader.string();
                                    break;
                                case 2:
                                    message.contractAddress = reader.string();
                                    break;
                                case 3:
                                    message.executeMsg = reader.string();
                                    break;
                                case 5:
                                    if (!(message.coins && message.coins.length))
                                        message.coins = [];
                                    message.coins.push($root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a WasmTerraExecuteContractGeneric message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        WasmTerraExecuteContractGeneric.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
                                if (!$util.isString(message.senderAddress))
                                    return "senderAddress: string expected";
                            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                                if (!$util.isString(message.contractAddress))
                                    return "contractAddress: string expected";
                            if (message.executeMsg != null && message.hasOwnProperty("executeMsg"))
                                if (!$util.isString(message.executeMsg))
                                    return "executeMsg: string expected";
                            if (message.coins != null && message.hasOwnProperty("coins")) {
                                if (!Array.isArray(message.coins))
                                    return "coins: array expected";
                                for (var i = 0; i < message.coins.length; ++i) {
                                    var error = $root.TW.Cosmos.Proto.Amount.verify(message.coins[i]);
                                    if (error)
                                        return "coins." + error;
                                }
                            }
                            return null;
                        };
    
                        /**
                         * Creates a WasmTerraExecuteContractGeneric message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric} WasmTerraExecuteContractGeneric
                         */
                        WasmTerraExecuteContractGeneric.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric();
                            if (object.senderAddress != null)
                                message.senderAddress = String(object.senderAddress);
                            if (object.contractAddress != null)
                                message.contractAddress = String(object.contractAddress);
                            if (object.executeMsg != null)
                                message.executeMsg = String(object.executeMsg);
                            if (object.coins) {
                                if (!Array.isArray(object.coins))
                                    throw TypeError(".TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.coins: array expected");
                                message.coins = [];
                                for (var i = 0; i < object.coins.length; ++i) {
                                    if (typeof object.coins[i] !== "object")
                                        throw TypeError(".TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.coins: object expected");
                                    message.coins[i] = $root.TW.Cosmos.Proto.Amount.fromObject(object.coins[i]);
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a WasmTerraExecuteContractGeneric message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @static
                         * @param {TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric} message WasmTerraExecuteContractGeneric
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        WasmTerraExecuteContractGeneric.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.coins = [];
                            if (options.defaults) {
                                object.senderAddress = "";
                                object.contractAddress = "";
                                object.executeMsg = "";
                            }
                            if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
                                object.senderAddress = message.senderAddress;
                            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                                object.contractAddress = message.contractAddress;
                            if (message.executeMsg != null && message.hasOwnProperty("executeMsg"))
                                object.executeMsg = message.executeMsg;
                            if (message.coins && message.coins.length) {
                                object.coins = [];
                                for (var j = 0; j < message.coins.length; ++j)
                                    object.coins[j] = $root.TW.Cosmos.Proto.Amount.toObject(message.coins[j], options);
                            }
                            return object;
                        };
    
                        /**
                         * Converts this WasmTerraExecuteContractGeneric to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        WasmTerraExecuteContractGeneric.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return WasmTerraExecuteContractGeneric;
                    })();
    
                    Message.RawJSON = (function() {
    
                        /**
                         * Properties of a RawJSON.
                         * @memberof TW.Cosmos.Proto.Message
                         * @interface IRawJSON
                         * @property {string|null} [type] RawJSON type
                         * @property {string|null} [value] RawJSON value
                         */
    
                        /**
                         * Constructs a new RawJSON.
                         * @memberof TW.Cosmos.Proto.Message
                         * @classdesc Represents a RawJSON.
                         * @implements IRawJSON
                         * @constructor
                         * @param {TW.Cosmos.Proto.Message.IRawJSON=} [properties] Properties to set
                         */
                        function RawJSON(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * RawJSON type.
                         * @member {string} type
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @instance
                         */
                        RawJSON.prototype.type = "";
    
                        /**
                         * RawJSON value.
                         * @member {string} value
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @instance
                         */
                        RawJSON.prototype.value = "";
    
                        /**
                         * Creates a new RawJSON instance using the specified properties.
                         * @function create
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IRawJSON=} [properties] Properties to set
                         * @returns {TW.Cosmos.Proto.Message.RawJSON} RawJSON instance
                         */
                        RawJSON.create = function create(properties) {
                            return new RawJSON(properties);
                        };
    
                        /**
                         * Encodes the specified RawJSON message. Does not implicitly {@link TW.Cosmos.Proto.Message.RawJSON.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @static
                         * @param {TW.Cosmos.Proto.Message.IRawJSON} message RawJSON message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RawJSON.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                            return writer;
                        };
    
                        /**
                         * Decodes a RawJSON message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Cosmos.Proto.Message.RawJSON} RawJSON
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RawJSON.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Message.RawJSON();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.type = reader.string();
                                    break;
                                case 2:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a RawJSON message.
                         * @function verify
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RawJSON.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.type != null && message.hasOwnProperty("type"))
                                if (!$util.isString(message.type))
                                    return "type: string expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };
    
                        /**
                         * Creates a RawJSON message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Cosmos.Proto.Message.RawJSON} RawJSON
                         */
                        RawJSON.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Cosmos.Proto.Message.RawJSON)
                                return object;
                            var message = new $root.TW.Cosmos.Proto.Message.RawJSON();
                            if (object.type != null)
                                message.type = String(object.type);
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a RawJSON message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @static
                         * @param {TW.Cosmos.Proto.Message.RawJSON} message RawJSON
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RawJSON.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.type = "";
                                object.value = "";
                            }
                            if (message.type != null && message.hasOwnProperty("type"))
                                object.type = message.type;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };
    
                        /**
                         * Converts this RawJSON to JSON.
                         * @function toJSON
                         * @memberof TW.Cosmos.Proto.Message.RawJSON
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RawJSON.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return RawJSON;
                    })();
    
                    return Message;
                })();
    
                /**
                 * SigningMode enum.
                 * @name TW.Cosmos.Proto.SigningMode
                 * @enum {number}
                 * @property {number} JSON=0 JSON value
                 * @property {number} Protobuf=1 Protobuf value
                 */
                Proto.SigningMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JSON"] = 0;
                    values[valuesById[1] = "Protobuf"] = 1;
                    return values;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Cosmos.Proto
                     * @interface ISigningInput
                     * @property {TW.Cosmos.Proto.SigningMode|null} [signingMode] SigningInput signingMode
                     * @property {Long|null} [accountNumber] SigningInput accountNumber
                     * @property {string|null} [chainId] SigningInput chainId
                     * @property {TW.Cosmos.Proto.IFee|null} [fee] SigningInput fee
                     * @property {string|null} [memo] SigningInput memo
                     * @property {Long|null} [sequence] SigningInput sequence
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {Array.<TW.Cosmos.Proto.IMessage>|null} [messages] SigningInput messages
                     * @property {TW.Cosmos.Proto.BroadcastMode|null} [mode] SigningInput mode
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Cosmos.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.messages = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput signingMode.
                     * @member {TW.Cosmos.Proto.SigningMode} signingMode
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.signingMode = 0;
    
                    /**
                     * SigningInput accountNumber.
                     * @member {Long} accountNumber
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput chainId.
                     * @member {string} chainId
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * SigningInput fee.
                     * @member {TW.Cosmos.Proto.IFee|null|undefined} fee
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = null;
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput sequence.
                     * @member {Long} sequence
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput messages.
                     * @member {Array.<TW.Cosmos.Proto.IMessage>} messages
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.messages = $util.emptyArray;
    
                    /**
                     * SigningInput mode.
                     * @member {TW.Cosmos.Proto.BroadcastMode} mode
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.mode = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Cosmos.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signingMode != null && Object.hasOwnProperty.call(message, "signingMode"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signingMode);
                        if (message.accountNumber != null && Object.hasOwnProperty.call(message, "accountNumber"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accountNumber);
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.chainId);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            $root.TW.Cosmos.Proto.Fee.encode(message.fee, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.sequence);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.privateKey);
                        if (message.messages != null && message.messages.length)
                            for (var i = 0; i < message.messages.length; ++i)
                                $root.TW.Cosmos.Proto.Message.encode(message.messages[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.mode);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signingMode = reader.int32();
                                break;
                            case 2:
                                message.accountNumber = reader.uint64();
                                break;
                            case 3:
                                message.chainId = reader.string();
                                break;
                            case 4:
                                message.fee = $root.TW.Cosmos.Proto.Fee.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.memo = reader.string();
                                break;
                            case 6:
                                message.sequence = reader.uint64();
                                break;
                            case 7:
                                message.privateKey = reader.bytes();
                                break;
                            case 8:
                                if (!(message.messages && message.messages.length))
                                    message.messages = [];
                                message.messages.push($root.TW.Cosmos.Proto.Message.decode(reader, reader.uint32()));
                                break;
                            case 9:
                                message.mode = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signingMode != null && message.hasOwnProperty("signingMode"))
                            switch (message.signingMode) {
                            default:
                                return "signingMode: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                                return "accountNumber: integer|Long expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee")) {
                            var error = $root.TW.Cosmos.Proto.Fee.verify(message.fee);
                            if (error)
                                return "fee." + error;
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.messages != null && message.hasOwnProperty("messages")) {
                            if (!Array.isArray(message.messages))
                                return "messages: array expected";
                            for (var i = 0; i < message.messages.length; ++i) {
                                var error = $root.TW.Cosmos.Proto.Message.verify(message.messages[i]);
                                if (error)
                                    return "messages." + error;
                            }
                        }
                        if (message.mode != null && message.hasOwnProperty("mode"))
                            switch (message.mode) {
                            default:
                                return "mode: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.SigningInput();
                        switch (object.signingMode) {
                        case "JSON":
                        case 0:
                            message.signingMode = 0;
                            break;
                        case "Protobuf":
                        case 1:
                            message.signingMode = 1;
                            break;
                        }
                        if (object.accountNumber != null)
                            if ($util.Long)
                                (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = true;
                            else if (typeof object.accountNumber === "string")
                                message.accountNumber = parseInt(object.accountNumber, 10);
                            else if (typeof object.accountNumber === "number")
                                message.accountNumber = object.accountNumber;
                            else if (typeof object.accountNumber === "object")
                                message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber(true);
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.fee != null) {
                            if (typeof object.fee !== "object")
                                throw TypeError(".TW.Cosmos.Proto.SigningInput.fee: object expected");
                            message.fee = $root.TW.Cosmos.Proto.Fee.fromObject(object.fee);
                        }
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.messages) {
                            if (!Array.isArray(object.messages))
                                throw TypeError(".TW.Cosmos.Proto.SigningInput.messages: array expected");
                            message.messages = [];
                            for (var i = 0; i < object.messages.length; ++i) {
                                if (typeof object.messages[i] !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.SigningInput.messages: object expected");
                                message.messages[i] = $root.TW.Cosmos.Proto.Message.fromObject(object.messages[i]);
                            }
                        }
                        switch (object.mode) {
                        case "BLOCK":
                        case 0:
                            message.mode = 0;
                            break;
                        case "SYNC":
                        case 1:
                            message.mode = 1;
                            break;
                        case "ASYNC":
                        case 2:
                            message.mode = 2;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {TW.Cosmos.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.messages = [];
                        if (options.defaults) {
                            object.signingMode = options.enums === String ? "JSON" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.accountNumber = options.longs === String ? "0" : 0;
                            object.chainId = "";
                            object.fee = null;
                            object.memo = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.mode = options.enums === String ? "BLOCK" : 0;
                        }
                        if (message.signingMode != null && message.hasOwnProperty("signingMode"))
                            object.signingMode = options.enums === String ? $root.TW.Cosmos.Proto.SigningMode[message.signingMode] : message.signingMode;
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (typeof message.accountNumber === "number")
                                object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                            else
                                object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber(true) : message.accountNumber;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = $root.TW.Cosmos.Proto.Fee.toObject(message.fee, options);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.messages && message.messages.length) {
                            object.messages = [];
                            for (var j = 0; j < message.messages.length; ++j)
                                object.messages[j] = $root.TW.Cosmos.Proto.Message.toObject(message.messages[j], options);
                        }
                        if (message.mode != null && message.hasOwnProperty("mode"))
                            object.mode = options.enums === String ? $root.TW.Cosmos.Proto.BroadcastMode[message.mode] : message.mode;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Cosmos.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [json] SigningOutput json
                     * @property {string|null} [serialized] SigningOutput serialized
                     * @property {string|null} [error] SigningOutput error
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Cosmos.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * SigningOutput serialized.
                     * @member {string} serialized
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.serialized = "";
    
                    /**
                     * SigningOutput error.
                     * @member {string} error
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Cosmos.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.json);
                        if (message.serialized != null && Object.hasOwnProperty.call(message, "serialized"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.serialized);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.json = reader.string();
                                break;
                            case 3:
                                message.serialized = reader.string();
                                break;
                            case 4:
                                message.error = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        if (message.serialized != null && message.hasOwnProperty("serialized"))
                            if (!$util.isString(message.serialized))
                                return "serialized: string expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            if (!$util.isString(message.error))
                                return "error: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.json != null)
                            message.json = String(object.json);
                        if (object.serialized != null)
                            message.serialized = String(object.serialized);
                        if (object.error != null)
                            message.error = String(object.error);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {TW.Cosmos.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.json = "";
                            object.serialized = "";
                            object.error = "";
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        if (message.serialized != null && message.hasOwnProperty("serialized"))
                            object.serialized = message.serialized;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = message.error;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Cosmos;
        })();
    
        TW.Decred = (function() {
    
            /**
             * Namespace Decred.
             * @memberof TW
             * @namespace
             */
            var Decred = {};
    
            Decred.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Decred
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Decred.Proto
                     * @interface ITransaction
                     * @property {number|null} [serializeType] Serialization format
                     * @property {number|null} [version] Transaction data format version
                     * @property {Array.<TW.Decred.Proto.ITransactionInput>|null} [inputs] Transaction inputs
                     * @property {Array.<TW.Decred.Proto.ITransactionOutput>|null} [outputs] Transaction outputs
                     * @property {number|null} [lockTime] The time when a transaction can be spent (usually zero, in which case it has no effect).
                     * @property {number|null} [expiry] The block height at which the transaction expires and is no longer valid.
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Decred.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Serialization format
                     * @member {number} serializeType
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.serializeType = 0;
    
                    /**
                     * Transaction data format version
                     * @member {number} version
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.version = 0;
    
                    /**
                     * Transaction inputs.
                     * @member {Array.<TW.Decred.Proto.ITransactionInput>} inputs
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.inputs = $util.emptyArray;
    
                    /**
                     * Transaction outputs.
                     * @member {Array.<TW.Decred.Proto.ITransactionOutput>} outputs
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.outputs = $util.emptyArray;
    
                    /**
                     * The time when a transaction can be spent (usually zero, in which case it has no effect).
                     * @member {number} lockTime
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.lockTime = 0;
    
                    /**
                     * The block height at which the transaction expires and is no longer valid.
                     * @member {number} expiry
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.expiry = 0;
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {TW.Decred.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Decred.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {TW.Decred.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.serializeType != null && Object.hasOwnProperty.call(message, "serializeType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.serializeType);
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.Decred.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.Decred.Proto.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.lockTime != null && Object.hasOwnProperty.call(message, "lockTime"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.lockTime);
                        if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.expiry);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.serializeType = reader.uint32();
                                break;
                            case 2:
                                message.version = reader.uint32();
                                break;
                            case 3:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.Decred.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.Decred.Proto.TransactionOutput.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.lockTime = reader.uint32();
                                break;
                            case 6:
                                message.expiry = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.serializeType != null && message.hasOwnProperty("serializeType"))
                            if (!$util.isInteger(message.serializeType))
                                return "serializeType: integer expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.Decred.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.Decred.Proto.TransactionOutput.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime))
                                return "lockTime: integer expected";
                        if (message.expiry != null && message.hasOwnProperty("expiry"))
                            if (!$util.isInteger(message.expiry))
                                return "expiry: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Decred.Proto.Transaction();
                        if (object.serializeType != null)
                            message.serializeType = object.serializeType >>> 0;
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.Decred.Proto.Transaction.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.Decred.Proto.Transaction.inputs: object expected");
                                message.inputs[i] = $root.TW.Decred.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.Decred.Proto.Transaction.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.Decred.Proto.Transaction.outputs: object expected");
                                message.outputs[i] = $root.TW.Decred.Proto.TransactionOutput.fromObject(object.outputs[i]);
                            }
                        }
                        if (object.lockTime != null)
                            message.lockTime = object.lockTime >>> 0;
                        if (object.expiry != null)
                            message.expiry = object.expiry >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {TW.Decred.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (options.defaults) {
                            object.serializeType = 0;
                            object.version = 0;
                            object.lockTime = 0;
                            object.expiry = 0;
                        }
                        if (message.serializeType != null && message.hasOwnProperty("serializeType"))
                            object.serializeType = message.serializeType;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.Decred.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.Decred.Proto.TransactionOutput.toObject(message.outputs[j], options);
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            object.lockTime = message.lockTime;
                        if (message.expiry != null && message.hasOwnProperty("expiry"))
                            object.expiry = message.expiry;
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.TransactionInput = (function() {
    
                    /**
                     * Properties of a TransactionInput.
                     * @memberof TW.Decred.Proto
                     * @interface ITransactionInput
                     * @property {TW.Bitcoin.Proto.IOutPoint|null} [previousOutput] TransactionInput previousOutput
                     * @property {number|null} [sequence] TransactionInput sequence
                     * @property {Long|null} [valueIn] TransactionInput valueIn
                     * @property {number|null} [blockHeight] TransactionInput blockHeight
                     * @property {number|null} [blockIndex] TransactionInput blockIndex
                     * @property {Uint8Array|null} [script] TransactionInput script
                     */
    
                    /**
                     * Constructs a new TransactionInput.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a TransactionInput.
                     * @implements ITransactionInput
                     * @constructor
                     * @param {TW.Decred.Proto.ITransactionInput=} [properties] Properties to set
                     */
                    function TransactionInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionInput previousOutput.
                     * @member {TW.Bitcoin.Proto.IOutPoint|null|undefined} previousOutput
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.previousOutput = null;
    
                    /**
                     * TransactionInput sequence.
                     * @member {number} sequence
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.sequence = 0;
    
                    /**
                     * TransactionInput valueIn.
                     * @member {Long} valueIn
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.valueIn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionInput blockHeight.
                     * @member {number} blockHeight
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.blockHeight = 0;
    
                    /**
                     * TransactionInput blockIndex.
                     * @member {number} blockIndex
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.blockIndex = 0;
    
                    /**
                     * TransactionInput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionInput=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.TransactionInput} TransactionInput instance
                     */
                    TransactionInput.create = function create(properties) {
                        return new TransactionInput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionInput message. Does not implicitly {@link TW.Decred.Proto.TransactionInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.previousOutput != null && Object.hasOwnProperty.call(message, "previousOutput"))
                            $root.TW.Bitcoin.Proto.OutPoint.encode(message.previousOutput, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sequence);
                        if (message.valueIn != null && Object.hasOwnProperty.call(message, "valueIn"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.valueIn);
                        if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockHeight);
                        if (message.blockIndex != null && Object.hasOwnProperty.call(message, "blockIndex"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blockIndex);
                        if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.TransactionInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.sequence = reader.uint32();
                                break;
                            case 3:
                                message.valueIn = reader.int64();
                                break;
                            case 4:
                                message.blockHeight = reader.uint32();
                                break;
                            case 5:
                                message.blockIndex = reader.uint32();
                                break;
                            case 6:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionInput message.
                     * @function verify
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput")) {
                            var error = $root.TW.Bitcoin.Proto.OutPoint.verify(message.previousOutput);
                            if (error)
                                return "previousOutput." + error;
                        }
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        if (message.valueIn != null && message.hasOwnProperty("valueIn"))
                            if (!$util.isInteger(message.valueIn) && !(message.valueIn && $util.isInteger(message.valueIn.low) && $util.isInteger(message.valueIn.high)))
                                return "valueIn: integer|Long expected";
                        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                            if (!$util.isInteger(message.blockHeight))
                                return "blockHeight: integer expected";
                        if (message.blockIndex != null && message.hasOwnProperty("blockIndex"))
                            if (!$util.isInteger(message.blockIndex))
                                return "blockIndex: integer expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.TransactionInput} TransactionInput
                     */
                    TransactionInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.TransactionInput)
                            return object;
                        var message = new $root.TW.Decred.Proto.TransactionInput();
                        if (object.previousOutput != null) {
                            if (typeof object.previousOutput !== "object")
                                throw TypeError(".TW.Decred.Proto.TransactionInput.previousOutput: object expected");
                            message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.fromObject(object.previousOutput);
                        }
                        if (object.sequence != null)
                            message.sequence = object.sequence >>> 0;
                        if (object.valueIn != null)
                            if ($util.Long)
                                (message.valueIn = $util.Long.fromValue(object.valueIn)).unsigned = false;
                            else if (typeof object.valueIn === "string")
                                message.valueIn = parseInt(object.valueIn, 10);
                            else if (typeof object.valueIn === "number")
                                message.valueIn = object.valueIn;
                            else if (typeof object.valueIn === "object")
                                message.valueIn = new $util.LongBits(object.valueIn.low >>> 0, object.valueIn.high >>> 0).toNumber();
                        if (object.blockHeight != null)
                            message.blockHeight = object.blockHeight >>> 0;
                        if (object.blockIndex != null)
                            message.blockIndex = object.blockIndex >>> 0;
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {TW.Decred.Proto.TransactionInput} message TransactionInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.previousOutput = null;
                            object.sequence = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.valueIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.valueIn = options.longs === String ? "0" : 0;
                            object.blockHeight = 0;
                            object.blockIndex = 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput"))
                            object.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.toObject(message.previousOutput, options);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.valueIn != null && message.hasOwnProperty("valueIn"))
                            if (typeof message.valueIn === "number")
                                object.valueIn = options.longs === String ? String(message.valueIn) : message.valueIn;
                            else
                                object.valueIn = options.longs === String ? $util.Long.prototype.toString.call(message.valueIn) : options.longs === Number ? new $util.LongBits(message.valueIn.low >>> 0, message.valueIn.high >>> 0).toNumber() : message.valueIn;
                        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                            object.blockHeight = message.blockHeight;
                        if (message.blockIndex != null && message.hasOwnProperty("blockIndex"))
                            object.blockIndex = message.blockIndex;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionInput to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionInput;
                })();
    
                Proto.TransactionOutput = (function() {
    
                    /**
                     * Properties of a TransactionOutput.
                     * @memberof TW.Decred.Proto
                     * @interface ITransactionOutput
                     * @property {Long|null} [value] TransactionOutput value
                     * @property {number|null} [version] Transaction output version.
                     * @property {Uint8Array|null} [script] TransactionOutput script
                     */
    
                    /**
                     * Constructs a new TransactionOutput.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a TransactionOutput.
                     * @implements ITransactionOutput
                     * @constructor
                     * @param {TW.Decred.Proto.ITransactionOutput=} [properties] Properties to set
                     */
                    function TransactionOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOutput value.
                     * @member {Long} value
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction output version.
                     * @member {number} version
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.version = 0;
    
                    /**
                     * TransactionOutput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionOutput=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.TransactionOutput} TransactionOutput instance
                     */
                    TransactionOutput.create = function create(properties) {
                        return new TransactionOutput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.Decred.Proto.TransactionOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
                        if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.TransactionOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.int64();
                                break;
                            case 2:
                                message.version = reader.uint32();
                                break;
                            case 3:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionOutput message.
                     * @function verify
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.TransactionOutput} TransactionOutput
                     */
                    TransactionOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.TransactionOutput)
                            return object;
                        var message = new $root.TW.Decred.Proto.TransactionOutput();
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {TW.Decred.Proto.TransactionOutput} message TransactionOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            object.version = 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOutput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Decred.Proto
                     * @interface ISigningOutput
                     * @property {TW.Decred.Proto.ITransaction|null} [transaction] SigningOutput transaction
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {string|null} [transactionId] SigningOutput transactionId
                     * @property {TW.Common.Proto.SigningError|null} [error] SigningOutput error
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Decred.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput transaction.
                     * @member {TW.Decred.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transaction = null;
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput transactionId.
                     * @member {string} transactionId
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transactionId = "";
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {TW.Decred.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Decred.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {TW.Decred.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                            $root.TW.Decred.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encoded);
                        if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.transactionId);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.TW.Decred.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.encoded = reader.bytes();
                                break;
                            case 3:
                                message.transactionId = reader.string();
                                break;
                            case 4:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Decred.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            if (!$util.isString(message.transactionId))
                                return "transactionId: string expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Decred.Proto.SigningOutput();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Decred.Proto.SigningOutput.transaction: object expected");
                            message.transaction = $root.TW.Decred.Proto.Transaction.fromObject(object.transaction);
                        }
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.transactionId != null)
                            message.transactionId = String(object.transactionId);
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {TW.Decred.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            object.transactionId = "";
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Decred.Proto.Transaction.toObject(message.transaction, options);
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            object.transactionId = message.transactionId;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Decred;
        })();
    
        TW.Elrond = (function() {
    
            /**
             * Namespace Elrond.
             * @memberof TW
             * @namespace
             */
            var Elrond = {};
    
            Elrond.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Elrond
                 * @namespace
                 */
                var Proto = {};
    
                Proto.GenericAction = (function() {
    
                    /**
                     * Properties of a GenericAction.
                     * @memberof TW.Elrond.Proto
                     * @interface IGenericAction
                     * @property {TW.Elrond.Proto.IAccounts|null} [accounts] GenericAction accounts
                     * @property {string|null} [value] GenericAction value
                     * @property {string|null} [data] GenericAction data
                     * @property {number|null} [version] GenericAction version
                     * @property {number|null} [options] GenericAction options
                     */
    
                    /**
                     * Constructs a new GenericAction.
                     * @memberof TW.Elrond.Proto
                     * @classdesc Represents a GenericAction.
                     * @implements IGenericAction
                     * @constructor
                     * @param {TW.Elrond.Proto.IGenericAction=} [properties] Properties to set
                     */
                    function GenericAction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GenericAction accounts.
                     * @member {TW.Elrond.Proto.IAccounts|null|undefined} accounts
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @instance
                     */
                    GenericAction.prototype.accounts = null;
    
                    /**
                     * GenericAction value.
                     * @member {string} value
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @instance
                     */
                    GenericAction.prototype.value = "";
    
                    /**
                     * GenericAction data.
                     * @member {string} data
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @instance
                     */
                    GenericAction.prototype.data = "";
    
                    /**
                     * GenericAction version.
                     * @member {number} version
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @instance
                     */
                    GenericAction.prototype.version = 0;
    
                    /**
                     * GenericAction options.
                     * @member {number} options
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @instance
                     */
                    GenericAction.prototype.options = 0;
    
                    /**
                     * Creates a new GenericAction instance using the specified properties.
                     * @function create
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @static
                     * @param {TW.Elrond.Proto.IGenericAction=} [properties] Properties to set
                     * @returns {TW.Elrond.Proto.GenericAction} GenericAction instance
                     */
                    GenericAction.create = function create(properties) {
                        return new GenericAction(properties);
                    };
    
                    /**
                     * Encodes the specified GenericAction message. Does not implicitly {@link TW.Elrond.Proto.GenericAction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @static
                     * @param {TW.Elrond.Proto.IGenericAction} message GenericAction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GenericAction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.accounts != null && Object.hasOwnProperty.call(message, "accounts"))
                            $root.TW.Elrond.Proto.Accounts.encode(message.accounts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.data);
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.version);
                        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.options);
                        return writer;
                    };
    
                    /**
                     * Decodes a GenericAction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Elrond.Proto.GenericAction} GenericAction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GenericAction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Elrond.Proto.GenericAction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.accounts = $root.TW.Elrond.Proto.Accounts.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.value = reader.string();
                                break;
                            case 3:
                                message.data = reader.string();
                                break;
                            case 4:
                                message.version = reader.uint32();
                                break;
                            case 5:
                                message.options = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a GenericAction message.
                     * @function verify
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GenericAction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.accounts != null && message.hasOwnProperty("accounts")) {
                            var error = $root.TW.Elrond.Proto.Accounts.verify(message.accounts);
                            if (error)
                                return "accounts." + error;
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!$util.isString(message.data))
                                return "data: string expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.options != null && message.hasOwnProperty("options"))
                            if (!$util.isInteger(message.options))
                                return "options: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a GenericAction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Elrond.Proto.GenericAction} GenericAction
                     */
                    GenericAction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Elrond.Proto.GenericAction)
                            return object;
                        var message = new $root.TW.Elrond.Proto.GenericAction();
                        if (object.accounts != null) {
                            if (typeof object.accounts !== "object")
                                throw TypeError(".TW.Elrond.Proto.GenericAction.accounts: object expected");
                            message.accounts = $root.TW.Elrond.Proto.Accounts.fromObject(object.accounts);
                        }
                        if (object.value != null)
                            message.value = String(object.value);
                        if (object.data != null)
                            message.data = String(object.data);
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.options != null)
                            message.options = object.options >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a GenericAction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @static
                     * @param {TW.Elrond.Proto.GenericAction} message GenericAction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GenericAction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.accounts = null;
                            object.value = "";
                            object.data = "";
                            object.version = 0;
                            object.options = 0;
                        }
                        if (message.accounts != null && message.hasOwnProperty("accounts"))
                            object.accounts = $root.TW.Elrond.Proto.Accounts.toObject(message.accounts, options);
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = message.data;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.options != null && message.hasOwnProperty("options"))
                            object.options = message.options;
                        return object;
                    };
    
                    /**
                     * Converts this GenericAction to JSON.
                     * @function toJSON
                     * @memberof TW.Elrond.Proto.GenericAction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GenericAction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return GenericAction;
                })();
    
                Proto.EGLDTransfer = (function() {
    
                    /**
                     * Properties of a EGLDTransfer.
                     * @memberof TW.Elrond.Proto
                     * @interface IEGLDTransfer
                     * @property {TW.Elrond.Proto.IAccounts|null} [accounts] EGLDTransfer accounts
                     * @property {string|null} [amount] EGLDTransfer amount
                     */
    
                    /**
                     * Constructs a new EGLDTransfer.
                     * @memberof TW.Elrond.Proto
                     * @classdesc Represents a EGLDTransfer.
                     * @implements IEGLDTransfer
                     * @constructor
                     * @param {TW.Elrond.Proto.IEGLDTransfer=} [properties] Properties to set
                     */
                    function EGLDTransfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * EGLDTransfer accounts.
                     * @member {TW.Elrond.Proto.IAccounts|null|undefined} accounts
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @instance
                     */
                    EGLDTransfer.prototype.accounts = null;
    
                    /**
                     * EGLDTransfer amount.
                     * @member {string} amount
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @instance
                     */
                    EGLDTransfer.prototype.amount = "";
    
                    /**
                     * Creates a new EGLDTransfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @static
                     * @param {TW.Elrond.Proto.IEGLDTransfer=} [properties] Properties to set
                     * @returns {TW.Elrond.Proto.EGLDTransfer} EGLDTransfer instance
                     */
                    EGLDTransfer.create = function create(properties) {
                        return new EGLDTransfer(properties);
                    };
    
                    /**
                     * Encodes the specified EGLDTransfer message. Does not implicitly {@link TW.Elrond.Proto.EGLDTransfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @static
                     * @param {TW.Elrond.Proto.IEGLDTransfer} message EGLDTransfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EGLDTransfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.accounts != null && Object.hasOwnProperty.call(message, "accounts"))
                            $root.TW.Elrond.Proto.Accounts.encode(message.accounts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a EGLDTransfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Elrond.Proto.EGLDTransfer} EGLDTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EGLDTransfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Elrond.Proto.EGLDTransfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.accounts = $root.TW.Elrond.Proto.Accounts.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.amount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a EGLDTransfer message.
                     * @function verify
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EGLDTransfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.accounts != null && message.hasOwnProperty("accounts")) {
                            var error = $root.TW.Elrond.Proto.Accounts.verify(message.accounts);
                            if (error)
                                return "accounts." + error;
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a EGLDTransfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Elrond.Proto.EGLDTransfer} EGLDTransfer
                     */
                    EGLDTransfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Elrond.Proto.EGLDTransfer)
                            return object;
                        var message = new $root.TW.Elrond.Proto.EGLDTransfer();
                        if (object.accounts != null) {
                            if (typeof object.accounts !== "object")
                                throw TypeError(".TW.Elrond.Proto.EGLDTransfer.accounts: object expected");
                            message.accounts = $root.TW.Elrond.Proto.Accounts.fromObject(object.accounts);
                        }
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a EGLDTransfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @static
                     * @param {TW.Elrond.Proto.EGLDTransfer} message EGLDTransfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EGLDTransfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.accounts = null;
                            object.amount = "";
                        }
                        if (message.accounts != null && message.hasOwnProperty("accounts"))
                            object.accounts = $root.TW.Elrond.Proto.Accounts.toObject(message.accounts, options);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this EGLDTransfer to JSON.
                     * @function toJSON
                     * @memberof TW.Elrond.Proto.EGLDTransfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EGLDTransfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return EGLDTransfer;
                })();
    
                Proto.ESDTTransfer = (function() {
    
                    /**
                     * Properties of a ESDTTransfer.
                     * @memberof TW.Elrond.Proto
                     * @interface IESDTTransfer
                     * @property {TW.Elrond.Proto.IAccounts|null} [accounts] ESDTTransfer accounts
                     * @property {string|null} [tokenIdentifier] ESDTTransfer tokenIdentifier
                     * @property {string|null} [amount] ESDTTransfer amount
                     */
    
                    /**
                     * Constructs a new ESDTTransfer.
                     * @memberof TW.Elrond.Proto
                     * @classdesc Represents a ESDTTransfer.
                     * @implements IESDTTransfer
                     * @constructor
                     * @param {TW.Elrond.Proto.IESDTTransfer=} [properties] Properties to set
                     */
                    function ESDTTransfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ESDTTransfer accounts.
                     * @member {TW.Elrond.Proto.IAccounts|null|undefined} accounts
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @instance
                     */
                    ESDTTransfer.prototype.accounts = null;
    
                    /**
                     * ESDTTransfer tokenIdentifier.
                     * @member {string} tokenIdentifier
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @instance
                     */
                    ESDTTransfer.prototype.tokenIdentifier = "";
    
                    /**
                     * ESDTTransfer amount.
                     * @member {string} amount
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @instance
                     */
                    ESDTTransfer.prototype.amount = "";
    
                    /**
                     * Creates a new ESDTTransfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @static
                     * @param {TW.Elrond.Proto.IESDTTransfer=} [properties] Properties to set
                     * @returns {TW.Elrond.Proto.ESDTTransfer} ESDTTransfer instance
                     */
                    ESDTTransfer.create = function create(properties) {
                        return new ESDTTransfer(properties);
                    };
    
                    /**
                     * Encodes the specified ESDTTransfer message. Does not implicitly {@link TW.Elrond.Proto.ESDTTransfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @static
                     * @param {TW.Elrond.Proto.IESDTTransfer} message ESDTTransfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ESDTTransfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.accounts != null && Object.hasOwnProperty.call(message, "accounts"))
                            $root.TW.Elrond.Proto.Accounts.encode(message.accounts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.tokenIdentifier != null && Object.hasOwnProperty.call(message, "tokenIdentifier"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.tokenIdentifier);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a ESDTTransfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Elrond.Proto.ESDTTransfer} ESDTTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ESDTTransfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Elrond.Proto.ESDTTransfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.accounts = $root.TW.Elrond.Proto.Accounts.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.tokenIdentifier = reader.string();
                                break;
                            case 3:
                                message.amount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a ESDTTransfer message.
                     * @function verify
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ESDTTransfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.accounts != null && message.hasOwnProperty("accounts")) {
                            var error = $root.TW.Elrond.Proto.Accounts.verify(message.accounts);
                            if (error)
                                return "accounts." + error;
                        }
                        if (message.tokenIdentifier != null && message.hasOwnProperty("tokenIdentifier"))
                            if (!$util.isString(message.tokenIdentifier))
                                return "tokenIdentifier: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a ESDTTransfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Elrond.Proto.ESDTTransfer} ESDTTransfer
                     */
                    ESDTTransfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Elrond.Proto.ESDTTransfer)
                            return object;
                        var message = new $root.TW.Elrond.Proto.ESDTTransfer();
                        if (object.accounts != null) {
                            if (typeof object.accounts !== "object")
                                throw TypeError(".TW.Elrond.Proto.ESDTTransfer.accounts: object expected");
                            message.accounts = $root.TW.Elrond.Proto.Accounts.fromObject(object.accounts);
                        }
                        if (object.tokenIdentifier != null)
                            message.tokenIdentifier = String(object.tokenIdentifier);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ESDTTransfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @static
                     * @param {TW.Elrond.Proto.ESDTTransfer} message ESDTTransfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ESDTTransfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.accounts = null;
                            object.tokenIdentifier = "";
                            object.amount = "";
                        }
                        if (message.accounts != null && message.hasOwnProperty("accounts"))
                            object.accounts = $root.TW.Elrond.Proto.Accounts.toObject(message.accounts, options);
                        if (message.tokenIdentifier != null && message.hasOwnProperty("tokenIdentifier"))
                            object.tokenIdentifier = message.tokenIdentifier;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this ESDTTransfer to JSON.
                     * @function toJSON
                     * @memberof TW.Elrond.Proto.ESDTTransfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ESDTTransfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ESDTTransfer;
                })();
    
                Proto.ESDTNFTTransfer = (function() {
    
                    /**
                     * Properties of a ESDTNFTTransfer.
                     * @memberof TW.Elrond.Proto
                     * @interface IESDTNFTTransfer
                     * @property {TW.Elrond.Proto.IAccounts|null} [accounts] ESDTNFTTransfer accounts
                     * @property {string|null} [tokenCollection] ESDTNFTTransfer tokenCollection
                     * @property {Long|null} [tokenNonce] ESDTNFTTransfer tokenNonce
                     * @property {string|null} [amount] ESDTNFTTransfer amount
                     */
    
                    /**
                     * Constructs a new ESDTNFTTransfer.
                     * @memberof TW.Elrond.Proto
                     * @classdesc Represents a ESDTNFTTransfer.
                     * @implements IESDTNFTTransfer
                     * @constructor
                     * @param {TW.Elrond.Proto.IESDTNFTTransfer=} [properties] Properties to set
                     */
                    function ESDTNFTTransfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ESDTNFTTransfer accounts.
                     * @member {TW.Elrond.Proto.IAccounts|null|undefined} accounts
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @instance
                     */
                    ESDTNFTTransfer.prototype.accounts = null;
    
                    /**
                     * ESDTNFTTransfer tokenCollection.
                     * @member {string} tokenCollection
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @instance
                     */
                    ESDTNFTTransfer.prototype.tokenCollection = "";
    
                    /**
                     * ESDTNFTTransfer tokenNonce.
                     * @member {Long} tokenNonce
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @instance
                     */
                    ESDTNFTTransfer.prototype.tokenNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ESDTNFTTransfer amount.
                     * @member {string} amount
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @instance
                     */
                    ESDTNFTTransfer.prototype.amount = "";
    
                    /**
                     * Creates a new ESDTNFTTransfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @static
                     * @param {TW.Elrond.Proto.IESDTNFTTransfer=} [properties] Properties to set
                     * @returns {TW.Elrond.Proto.ESDTNFTTransfer} ESDTNFTTransfer instance
                     */
                    ESDTNFTTransfer.create = function create(properties) {
                        return new ESDTNFTTransfer(properties);
                    };
    
                    /**
                     * Encodes the specified ESDTNFTTransfer message. Does not implicitly {@link TW.Elrond.Proto.ESDTNFTTransfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @static
                     * @param {TW.Elrond.Proto.IESDTNFTTransfer} message ESDTNFTTransfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ESDTNFTTransfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.accounts != null && Object.hasOwnProperty.call(message, "accounts"))
                            $root.TW.Elrond.Proto.Accounts.encode(message.accounts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.tokenCollection != null && Object.hasOwnProperty.call(message, "tokenCollection"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.tokenCollection);
                        if (message.tokenNonce != null && Object.hasOwnProperty.call(message, "tokenNonce"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.tokenNonce);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a ESDTNFTTransfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Elrond.Proto.ESDTNFTTransfer} ESDTNFTTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ESDTNFTTransfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Elrond.Proto.ESDTNFTTransfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.accounts = $root.TW.Elrond.Proto.Accounts.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.tokenCollection = reader.string();
                                break;
                            case 3:
                                message.tokenNonce = reader.uint64();
                                break;
                            case 4:
                                message.amount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a ESDTNFTTransfer message.
                     * @function verify
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ESDTNFTTransfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.accounts != null && message.hasOwnProperty("accounts")) {
                            var error = $root.TW.Elrond.Proto.Accounts.verify(message.accounts);
                            if (error)
                                return "accounts." + error;
                        }
                        if (message.tokenCollection != null && message.hasOwnProperty("tokenCollection"))
                            if (!$util.isString(message.tokenCollection))
                                return "tokenCollection: string expected";
                        if (message.tokenNonce != null && message.hasOwnProperty("tokenNonce"))
                            if (!$util.isInteger(message.tokenNonce) && !(message.tokenNonce && $util.isInteger(message.tokenNonce.low) && $util.isInteger(message.tokenNonce.high)))
                                return "tokenNonce: integer|Long expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a ESDTNFTTransfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Elrond.Proto.ESDTNFTTransfer} ESDTNFTTransfer
                     */
                    ESDTNFTTransfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Elrond.Proto.ESDTNFTTransfer)
                            return object;
                        var message = new $root.TW.Elrond.Proto.ESDTNFTTransfer();
                        if (object.accounts != null) {
                            if (typeof object.accounts !== "object")
                                throw TypeError(".TW.Elrond.Proto.ESDTNFTTransfer.accounts: object expected");
                            message.accounts = $root.TW.Elrond.Proto.Accounts.fromObject(object.accounts);
                        }
                        if (object.tokenCollection != null)
                            message.tokenCollection = String(object.tokenCollection);
                        if (object.tokenNonce != null)
                            if ($util.Long)
                                (message.tokenNonce = $util.Long.fromValue(object.tokenNonce)).unsigned = true;
                            else if (typeof object.tokenNonce === "string")
                                message.tokenNonce = parseInt(object.tokenNonce, 10);
                            else if (typeof object.tokenNonce === "number")
                                message.tokenNonce = object.tokenNonce;
                            else if (typeof object.tokenNonce === "object")
                                message.tokenNonce = new $util.LongBits(object.tokenNonce.low >>> 0, object.tokenNonce.high >>> 0).toNumber(true);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ESDTNFTTransfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @static
                     * @param {TW.Elrond.Proto.ESDTNFTTransfer} message ESDTNFTTransfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ESDTNFTTransfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.accounts = null;
                            object.tokenCollection = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.tokenNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.tokenNonce = options.longs === String ? "0" : 0;
                            object.amount = "";
                        }
                        if (message.accounts != null && message.hasOwnProperty("accounts"))
                            object.accounts = $root.TW.Elrond.Proto.Accounts.toObject(message.accounts, options);
                        if (message.tokenCollection != null && message.hasOwnProperty("tokenCollection"))
                            object.tokenCollection = message.tokenCollection;
                        if (message.tokenNonce != null && message.hasOwnProperty("tokenNonce"))
                            if (typeof message.tokenNonce === "number")
                                object.tokenNonce = options.longs === String ? String(message.tokenNonce) : message.tokenNonce;
                            else
                                object.tokenNonce = options.longs === String ? $util.Long.prototype.toString.call(message.tokenNonce) : options.longs === Number ? new $util.LongBits(message.tokenNonce.low >>> 0, message.tokenNonce.high >>> 0).toNumber(true) : message.tokenNonce;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this ESDTNFTTransfer to JSON.
                     * @function toJSON
                     * @memberof TW.Elrond.Proto.ESDTNFTTransfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ESDTNFTTransfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ESDTNFTTransfer;
                })();
    
                Proto.Accounts = (function() {
    
                    /**
                     * Properties of an Accounts.
                     * @memberof TW.Elrond.Proto
                     * @interface IAccounts
                     * @property {Long|null} [senderNonce] Accounts senderNonce
                     * @property {string|null} [sender] Accounts sender
                     * @property {string|null} [senderUsername] Accounts senderUsername
                     * @property {string|null} [receiver] Accounts receiver
                     * @property {string|null} [receiverUsername] Accounts receiverUsername
                     */
    
                    /**
                     * Constructs a new Accounts.
                     * @memberof TW.Elrond.Proto
                     * @classdesc Represents an Accounts.
                     * @implements IAccounts
                     * @constructor
                     * @param {TW.Elrond.Proto.IAccounts=} [properties] Properties to set
                     */
                    function Accounts(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Accounts senderNonce.
                     * @member {Long} senderNonce
                     * @memberof TW.Elrond.Proto.Accounts
                     * @instance
                     */
                    Accounts.prototype.senderNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Accounts sender.
                     * @member {string} sender
                     * @memberof TW.Elrond.Proto.Accounts
                     * @instance
                     */
                    Accounts.prototype.sender = "";
    
                    /**
                     * Accounts senderUsername.
                     * @member {string} senderUsername
                     * @memberof TW.Elrond.Proto.Accounts
                     * @instance
                     */
                    Accounts.prototype.senderUsername = "";
    
                    /**
                     * Accounts receiver.
                     * @member {string} receiver
                     * @memberof TW.Elrond.Proto.Accounts
                     * @instance
                     */
                    Accounts.prototype.receiver = "";
    
                    /**
                     * Accounts receiverUsername.
                     * @member {string} receiverUsername
                     * @memberof TW.Elrond.Proto.Accounts
                     * @instance
                     */
                    Accounts.prototype.receiverUsername = "";
    
                    /**
                     * Creates a new Accounts instance using the specified properties.
                     * @function create
                     * @memberof TW.Elrond.Proto.Accounts
                     * @static
                     * @param {TW.Elrond.Proto.IAccounts=} [properties] Properties to set
                     * @returns {TW.Elrond.Proto.Accounts} Accounts instance
                     */
                    Accounts.create = function create(properties) {
                        return new Accounts(properties);
                    };
    
                    /**
                     * Encodes the specified Accounts message. Does not implicitly {@link TW.Elrond.Proto.Accounts.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Elrond.Proto.Accounts
                     * @static
                     * @param {TW.Elrond.Proto.IAccounts} message Accounts message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Accounts.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.senderNonce != null && Object.hasOwnProperty.call(message, "senderNonce"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.senderNonce);
                        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
                        if (message.senderUsername != null && Object.hasOwnProperty.call(message, "senderUsername"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderUsername);
                        if (message.receiver != null && Object.hasOwnProperty.call(message, "receiver"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiver);
                        if (message.receiverUsername != null && Object.hasOwnProperty.call(message, "receiverUsername"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.receiverUsername);
                        return writer;
                    };
    
                    /**
                     * Decodes an Accounts message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Elrond.Proto.Accounts
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Elrond.Proto.Accounts} Accounts
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Accounts.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Elrond.Proto.Accounts();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.senderNonce = reader.uint64();
                                break;
                            case 2:
                                message.sender = reader.string();
                                break;
                            case 3:
                                message.senderUsername = reader.string();
                                break;
                            case 4:
                                message.receiver = reader.string();
                                break;
                            case 5:
                                message.receiverUsername = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Accounts message.
                     * @function verify
                     * @memberof TW.Elrond.Proto.Accounts
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Accounts.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.senderNonce != null && message.hasOwnProperty("senderNonce"))
                            if (!$util.isInteger(message.senderNonce) && !(message.senderNonce && $util.isInteger(message.senderNonce.low) && $util.isInteger(message.senderNonce.high)))
                                return "senderNonce: integer|Long expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!$util.isString(message.sender))
                                return "sender: string expected";
                        if (message.senderUsername != null && message.hasOwnProperty("senderUsername"))
                            if (!$util.isString(message.senderUsername))
                                return "senderUsername: string expected";
                        if (message.receiver != null && message.hasOwnProperty("receiver"))
                            if (!$util.isString(message.receiver))
                                return "receiver: string expected";
                        if (message.receiverUsername != null && message.hasOwnProperty("receiverUsername"))
                            if (!$util.isString(message.receiverUsername))
                                return "receiverUsername: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Accounts message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Elrond.Proto.Accounts
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Elrond.Proto.Accounts} Accounts
                     */
                    Accounts.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Elrond.Proto.Accounts)
                            return object;
                        var message = new $root.TW.Elrond.Proto.Accounts();
                        if (object.senderNonce != null)
                            if ($util.Long)
                                (message.senderNonce = $util.Long.fromValue(object.senderNonce)).unsigned = true;
                            else if (typeof object.senderNonce === "string")
                                message.senderNonce = parseInt(object.senderNonce, 10);
                            else if (typeof object.senderNonce === "number")
                                message.senderNonce = object.senderNonce;
                            else if (typeof object.senderNonce === "object")
                                message.senderNonce = new $util.LongBits(object.senderNonce.low >>> 0, object.senderNonce.high >>> 0).toNumber(true);
                        if (object.sender != null)
                            message.sender = String(object.sender);
                        if (object.senderUsername != null)
                            message.senderUsername = String(object.senderUsername);
                        if (object.receiver != null)
                            message.receiver = String(object.receiver);
                        if (object.receiverUsername != null)
                            message.receiverUsername = String(object.receiverUsername);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Accounts message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Elrond.Proto.Accounts
                     * @static
                     * @param {TW.Elrond.Proto.Accounts} message Accounts
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Accounts.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.senderNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.senderNonce = options.longs === String ? "0" : 0;
                            object.sender = "";
                            object.senderUsername = "";
                            object.receiver = "";
                            object.receiverUsername = "";
                        }
                        if (message.senderNonce != null && message.hasOwnProperty("senderNonce"))
                            if (typeof message.senderNonce === "number")
                                object.senderNonce = options.longs === String ? String(message.senderNonce) : message.senderNonce;
                            else
                                object.senderNonce = options.longs === String ? $util.Long.prototype.toString.call(message.senderNonce) : options.longs === Number ? new $util.LongBits(message.senderNonce.low >>> 0, message.senderNonce.high >>> 0).toNumber(true) : message.senderNonce;
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = message.sender;
                        if (message.senderUsername != null && message.hasOwnProperty("senderUsername"))
                            object.senderUsername = message.senderUsername;
                        if (message.receiver != null && message.hasOwnProperty("receiver"))
                            object.receiver = message.receiver;
                        if (message.receiverUsername != null && message.hasOwnProperty("receiverUsername"))
                            object.receiverUsername = message.receiverUsername;
                        return object;
                    };
    
                    /**
                     * Converts this Accounts to JSON.
                     * @function toJSON
                     * @memberof TW.Elrond.Proto.Accounts
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Accounts.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Accounts;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Elrond.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [chainId] SigningInput chainId
                     * @property {Long|null} [gasPrice] SigningInput gasPrice
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {TW.Elrond.Proto.IGenericAction|null} [genericAction] SigningInput genericAction
                     * @property {TW.Elrond.Proto.IEGLDTransfer|null} [egldTransfer] SigningInput egldTransfer
                     * @property {TW.Elrond.Proto.IESDTTransfer|null} [esdtTransfer] SigningInput esdtTransfer
                     * @property {TW.Elrond.Proto.IESDTNFTTransfer|null} [esdtnftTransfer] SigningInput esdtnftTransfer
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Elrond.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Elrond.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput chainId.
                     * @member {string} chainId
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Long} gasPrice
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput genericAction.
                     * @member {TW.Elrond.Proto.IGenericAction|null|undefined} genericAction
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.genericAction = null;
    
                    /**
                     * SigningInput egldTransfer.
                     * @member {TW.Elrond.Proto.IEGLDTransfer|null|undefined} egldTransfer
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.egldTransfer = null;
    
                    /**
                     * SigningInput esdtTransfer.
                     * @member {TW.Elrond.Proto.IESDTTransfer|null|undefined} esdtTransfer
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.esdtTransfer = null;
    
                    /**
                     * SigningInput esdtnftTransfer.
                     * @member {TW.Elrond.Proto.IESDTNFTTransfer|null|undefined} esdtnftTransfer
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.esdtnftTransfer = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput messageOneof.
                     * @member {"genericAction"|"egldTransfer"|"esdtTransfer"|"esdtnftTransfer"|undefined} messageOneof
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["genericAction", "egldTransfer", "esdtTransfer", "esdtnftTransfer"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @static
                     * @param {TW.Elrond.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Elrond.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Elrond.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @static
                     * @param {TW.Elrond.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.chainId);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.gasLimit);
                        if (message.genericAction != null && Object.hasOwnProperty.call(message, "genericAction"))
                            $root.TW.Elrond.Proto.GenericAction.encode(message.genericAction, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.egldTransfer != null && Object.hasOwnProperty.call(message, "egldTransfer"))
                            $root.TW.Elrond.Proto.EGLDTransfer.encode(message.egldTransfer, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.esdtTransfer != null && Object.hasOwnProperty.call(message, "esdtTransfer"))
                            $root.TW.Elrond.Proto.ESDTTransfer.encode(message.esdtTransfer, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.esdtnftTransfer != null && Object.hasOwnProperty.call(message, "esdtnftTransfer"))
                            $root.TW.Elrond.Proto.ESDTNFTTransfer.encode(message.esdtnftTransfer, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Elrond.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Elrond.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.chainId = reader.string();
                                break;
                            case 3:
                                message.gasPrice = reader.uint64();
                                break;
                            case 4:
                                message.gasLimit = reader.uint64();
                                break;
                            case 5:
                                message.genericAction = $root.TW.Elrond.Proto.GenericAction.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.egldTransfer = $root.TW.Elrond.Proto.EGLDTransfer.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.esdtTransfer = $root.TW.Elrond.Proto.ESDTTransfer.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.esdtnftTransfer = $root.TW.Elrond.Proto.ESDTNFTTransfer.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isInteger(message.gasPrice) && !(message.gasPrice && $util.isInteger(message.gasPrice.low) && $util.isInteger(message.gasPrice.high)))
                                return "gasPrice: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.genericAction != null && message.hasOwnProperty("genericAction")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Elrond.Proto.GenericAction.verify(message.genericAction);
                                if (error)
                                    return "genericAction." + error;
                            }
                        }
                        if (message.egldTransfer != null && message.hasOwnProperty("egldTransfer")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Elrond.Proto.EGLDTransfer.verify(message.egldTransfer);
                                if (error)
                                    return "egldTransfer." + error;
                            }
                        }
                        if (message.esdtTransfer != null && message.hasOwnProperty("esdtTransfer")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Elrond.Proto.ESDTTransfer.verify(message.esdtTransfer);
                                if (error)
                                    return "esdtTransfer." + error;
                            }
                        }
                        if (message.esdtnftTransfer != null && message.hasOwnProperty("esdtnftTransfer")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Elrond.Proto.ESDTNFTTransfer.verify(message.esdtnftTransfer);
                                if (error)
                                    return "esdtnftTransfer." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Elrond.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Elrond.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Elrond.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.gasPrice != null)
                            if ($util.Long)
                                (message.gasPrice = $util.Long.fromValue(object.gasPrice)).unsigned = true;
                            else if (typeof object.gasPrice === "string")
                                message.gasPrice = parseInt(object.gasPrice, 10);
                            else if (typeof object.gasPrice === "number")
                                message.gasPrice = object.gasPrice;
                            else if (typeof object.gasPrice === "object")
                                message.gasPrice = new $util.LongBits(object.gasPrice.low >>> 0, object.gasPrice.high >>> 0).toNumber(true);
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.genericAction != null) {
                            if (typeof object.genericAction !== "object")
                                throw TypeError(".TW.Elrond.Proto.SigningInput.genericAction: object expected");
                            message.genericAction = $root.TW.Elrond.Proto.GenericAction.fromObject(object.genericAction);
                        }
                        if (object.egldTransfer != null) {
                            if (typeof object.egldTransfer !== "object")
                                throw TypeError(".TW.Elrond.Proto.SigningInput.egldTransfer: object expected");
                            message.egldTransfer = $root.TW.Elrond.Proto.EGLDTransfer.fromObject(object.egldTransfer);
                        }
                        if (object.esdtTransfer != null) {
                            if (typeof object.esdtTransfer !== "object")
                                throw TypeError(".TW.Elrond.Proto.SigningInput.esdtTransfer: object expected");
                            message.esdtTransfer = $root.TW.Elrond.Proto.ESDTTransfer.fromObject(object.esdtTransfer);
                        }
                        if (object.esdtnftTransfer != null) {
                            if (typeof object.esdtnftTransfer !== "object")
                                throw TypeError(".TW.Elrond.Proto.SigningInput.esdtnftTransfer: object expected");
                            message.esdtnftTransfer = $root.TW.Elrond.Proto.ESDTNFTTransfer.fromObject(object.esdtnftTransfer);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @static
                     * @param {TW.Elrond.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.chainId = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasPrice = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (typeof message.gasPrice === "number")
                                object.gasPrice = options.longs === String ? String(message.gasPrice) : message.gasPrice;
                            else
                                object.gasPrice = options.longs === String ? $util.Long.prototype.toString.call(message.gasPrice) : options.longs === Number ? new $util.LongBits(message.gasPrice.low >>> 0, message.gasPrice.high >>> 0).toNumber(true) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.genericAction != null && message.hasOwnProperty("genericAction")) {
                            object.genericAction = $root.TW.Elrond.Proto.GenericAction.toObject(message.genericAction, options);
                            if (options.oneofs)
                                object.messageOneof = "genericAction";
                        }
                        if (message.egldTransfer != null && message.hasOwnProperty("egldTransfer")) {
                            object.egldTransfer = $root.TW.Elrond.Proto.EGLDTransfer.toObject(message.egldTransfer, options);
                            if (options.oneofs)
                                object.messageOneof = "egldTransfer";
                        }
                        if (message.esdtTransfer != null && message.hasOwnProperty("esdtTransfer")) {
                            object.esdtTransfer = $root.TW.Elrond.Proto.ESDTTransfer.toObject(message.esdtTransfer, options);
                            if (options.oneofs)
                                object.messageOneof = "esdtTransfer";
                        }
                        if (message.esdtnftTransfer != null && message.hasOwnProperty("esdtnftTransfer")) {
                            object.esdtnftTransfer = $root.TW.Elrond.Proto.ESDTNFTTransfer.toObject(message.esdtnftTransfer, options);
                            if (options.oneofs)
                                object.messageOneof = "esdtnftTransfer";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Elrond.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Elrond.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [encoded] SigningOutput encoded
                     * @property {string|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Elrond.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Elrond.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {string} encoded
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = "";
    
                    /**
                     * SigningOutput signature.
                     * @member {string} signature
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @static
                     * @param {TW.Elrond.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Elrond.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Elrond.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @static
                     * @param {TW.Elrond.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.encoded);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Elrond.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Elrond.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.string();
                                break;
                            case 2:
                                message.signature = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!$util.isString(message.encoded))
                                return "encoded: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!$util.isString(message.signature))
                                return "signature: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Elrond.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Elrond.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Elrond.Proto.SigningOutput();
                        if (object.encoded != null)
                            message.encoded = String(object.encoded);
                        if (object.signature != null)
                            message.signature = String(object.signature);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @static
                     * @param {TW.Elrond.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.encoded = "";
                            object.signature = "";
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Elrond.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Elrond;
        })();
    
        TW.EOS = (function() {
    
            /**
             * Namespace EOS.
             * @memberof TW
             * @namespace
             */
            var EOS = {};
    
            EOS.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.EOS
                 * @namespace
                 */
                var Proto = {};
    
                /**
                 * KeyType enum.
                 * @name TW.EOS.Proto.KeyType
                 * @enum {number}
                 * @property {number} LEGACY=0 LEGACY value
                 * @property {number} MODERNK1=1 MODERNK1 value
                 * @property {number} MODERNR1=2 MODERNR1 value
                 */
                Proto.KeyType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "LEGACY"] = 0;
                    values[valuesById[1] = "MODERNK1"] = 1;
                    values[valuesById[2] = "MODERNR1"] = 2;
                    return values;
                })();
    
                Proto.Asset = (function() {
    
                    /**
                     * Properties of an Asset.
                     * @memberof TW.EOS.Proto
                     * @interface IAsset
                     * @property {Long|null} [amount] Asset amount
                     * @property {number|null} [decimals] Asset decimals
                     * @property {string|null} [symbol] Asset symbol
                     */
    
                    /**
                     * Constructs a new Asset.
                     * @memberof TW.EOS.Proto
                     * @classdesc Represents an Asset.
                     * @implements IAsset
                     * @constructor
                     * @param {TW.EOS.Proto.IAsset=} [properties] Properties to set
                     */
                    function Asset(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Asset amount.
                     * @member {Long} amount
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Asset decimals.
                     * @member {number} decimals
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.decimals = 0;
    
                    /**
                     * Asset symbol.
                     * @member {string} symbol
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.symbol = "";
    
                    /**
                     * Creates a new Asset instance using the specified properties.
                     * @function create
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {TW.EOS.Proto.IAsset=} [properties] Properties to set
                     * @returns {TW.EOS.Proto.Asset} Asset instance
                     */
                    Asset.create = function create(properties) {
                        return new Asset(properties);
                    };
    
                    /**
                     * Encodes the specified Asset message. Does not implicitly {@link TW.EOS.Proto.Asset.verify|verify} messages.
                     * @function encode
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {TW.EOS.Proto.IAsset} message Asset message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Asset.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.decimals);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.symbol);
                        return writer;
                    };
    
                    /**
                     * Decodes an Asset message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.EOS.Proto.Asset} Asset
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Asset.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.EOS.Proto.Asset();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.decimals = reader.uint32();
                                break;
                            case 3:
                                message.symbol = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Asset message.
                     * @function verify
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Asset.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            if (!$util.isInteger(message.decimals))
                                return "decimals: integer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.EOS.Proto.Asset} Asset
                     */
                    Asset.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.EOS.Proto.Asset)
                            return object;
                        var message = new $root.TW.EOS.Proto.Asset();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.decimals != null)
                            message.decimals = object.decimals >>> 0;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Asset message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {TW.EOS.Proto.Asset} message Asset
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Asset.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.decimals = 0;
                            object.symbol = "";
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            object.decimals = message.decimals;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        return object;
                    };
    
                    /**
                     * Converts this Asset to JSON.
                     * @function toJSON
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Asset.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Asset;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.EOS.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {Uint8Array|null} [referenceBlockId] SigningInput referenceBlockId
                     * @property {number|null} [referenceBlockTime] SigningInput referenceBlockTime
                     * @property {string|null} [currency] SigningInput currency
                     * @property {string|null} [sender] SigningInput sender
                     * @property {string|null} [recipient] SigningInput recipient
                     * @property {string|null} [memo] SigningInput memo
                     * @property {TW.EOS.Proto.IAsset|null} [asset] SigningInput asset
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.EOS.Proto.KeyType|null} [privateKeyType] SigningInput privateKeyType
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.EOS.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.EOS.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput referenceBlockId.
                     * @member {Uint8Array} referenceBlockId
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.referenceBlockId = $util.newBuffer([]);
    
                    /**
                     * SigningInput referenceBlockTime.
                     * @member {number} referenceBlockTime
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.referenceBlockTime = 0;
    
                    /**
                     * SigningInput currency.
                     * @member {string} currency
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.currency = "";
    
                    /**
                     * SigningInput sender.
                     * @member {string} sender
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sender = "";
    
                    /**
                     * SigningInput recipient.
                     * @member {string} recipient
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.recipient = "";
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput asset.
                     * @member {TW.EOS.Proto.IAsset|null|undefined} asset
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.asset = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKeyType.
                     * @member {TW.EOS.Proto.KeyType} privateKeyType
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKeyType = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {TW.EOS.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.EOS.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.EOS.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {TW.EOS.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chainId);
                        if (message.referenceBlockId != null && Object.hasOwnProperty.call(message, "referenceBlockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.referenceBlockId);
                        if (message.referenceBlockTime != null && Object.hasOwnProperty.call(message, "referenceBlockTime"))
                            writer.uint32(/* id 3, wireType 5 =*/29).sfixed32(message.referenceBlockTime);
                        if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.currency);
                        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.sender);
                        if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.recipient);
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
                        if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                            $root.TW.EOS.Proto.Asset.encode(message.asset, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        if (message.privateKeyType != null && Object.hasOwnProperty.call(message, "privateKeyType"))
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.privateKeyType);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.EOS.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.EOS.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.bytes();
                                break;
                            case 2:
                                message.referenceBlockId = reader.bytes();
                                break;
                            case 3:
                                message.referenceBlockTime = reader.sfixed32();
                                break;
                            case 4:
                                message.currency = reader.string();
                                break;
                            case 5:
                                message.sender = reader.string();
                                break;
                            case 6:
                                message.recipient = reader.string();
                                break;
                            case 7:
                                message.memo = reader.string();
                                break;
                            case 8:
                                message.asset = $root.TW.EOS.Proto.Asset.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            case 10:
                                message.privateKeyType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            if (!(message.referenceBlockId && typeof message.referenceBlockId.length === "number" || $util.isString(message.referenceBlockId)))
                                return "referenceBlockId: buffer expected";
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            if (!$util.isInteger(message.referenceBlockTime))
                                return "referenceBlockTime: integer expected";
                        if (message.currency != null && message.hasOwnProperty("currency"))
                            if (!$util.isString(message.currency))
                                return "currency: string expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!$util.isString(message.sender))
                                return "sender: string expected";
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            if (!$util.isString(message.recipient))
                                return "recipient: string expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.asset != null && message.hasOwnProperty("asset")) {
                            var error = $root.TW.EOS.Proto.Asset.verify(message.asset);
                            if (error)
                                return "asset." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.privateKeyType != null && message.hasOwnProperty("privateKeyType"))
                            switch (message.privateKeyType) {
                            default:
                                return "privateKeyType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.EOS.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.EOS.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.EOS.Proto.SigningInput();
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.referenceBlockId != null)
                            if (typeof object.referenceBlockId === "string")
                                $util.base64.decode(object.referenceBlockId, message.referenceBlockId = $util.newBuffer($util.base64.length(object.referenceBlockId)), 0);
                            else if (object.referenceBlockId.length)
                                message.referenceBlockId = object.referenceBlockId;
                        if (object.referenceBlockTime != null)
                            message.referenceBlockTime = object.referenceBlockTime | 0;
                        if (object.currency != null)
                            message.currency = String(object.currency);
                        if (object.sender != null)
                            message.sender = String(object.sender);
                        if (object.recipient != null)
                            message.recipient = String(object.recipient);
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.asset != null) {
                            if (typeof object.asset !== "object")
                                throw TypeError(".TW.EOS.Proto.SigningInput.asset: object expected");
                            message.asset = $root.TW.EOS.Proto.Asset.fromObject(object.asset);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        switch (object.privateKeyType) {
                        case "LEGACY":
                        case 0:
                            message.privateKeyType = 0;
                            break;
                        case "MODERNK1":
                        case 1:
                            message.privateKeyType = 1;
                            break;
                        case "MODERNR1":
                        case 2:
                            message.privateKeyType = 2;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {TW.EOS.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if (options.bytes === String)
                                object.referenceBlockId = "";
                            else {
                                object.referenceBlockId = [];
                                if (options.bytes !== Array)
                                    object.referenceBlockId = $util.newBuffer(object.referenceBlockId);
                            }
                            object.referenceBlockTime = 0;
                            object.currency = "";
                            object.sender = "";
                            object.recipient = "";
                            object.memo = "";
                            object.asset = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.privateKeyType = options.enums === String ? "LEGACY" : 0;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            object.referenceBlockId = options.bytes === String ? $util.base64.encode(message.referenceBlockId, 0, message.referenceBlockId.length) : options.bytes === Array ? Array.prototype.slice.call(message.referenceBlockId) : message.referenceBlockId;
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            object.referenceBlockTime = message.referenceBlockTime;
                        if (message.currency != null && message.hasOwnProperty("currency"))
                            object.currency = message.currency;
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = message.sender;
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            object.recipient = message.recipient;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            object.asset = $root.TW.EOS.Proto.Asset.toObject(message.asset, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.privateKeyType != null && message.hasOwnProperty("privateKeyType"))
                            object.privateKeyType = options.enums === String ? $root.TW.EOS.Proto.KeyType[message.privateKeyType] : message.privateKeyType;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.EOS.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [jsonEncoded] SigningOutput jsonEncoded
                     * @property {TW.Common.Proto.SigningError|null} [error] SigningOutput error
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.EOS.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.EOS.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput jsonEncoded.
                     * @member {string} jsonEncoded
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.jsonEncoded = "";
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {TW.EOS.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.EOS.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.EOS.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {TW.EOS.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.jsonEncoded != null && Object.hasOwnProperty.call(message, "jsonEncoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.jsonEncoded);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.EOS.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.EOS.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.jsonEncoded = reader.string();
                                break;
                            case 2:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            if (!$util.isString(message.jsonEncoded))
                                return "jsonEncoded: string expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.EOS.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.EOS.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.EOS.Proto.SigningOutput();
                        if (object.jsonEncoded != null)
                            message.jsonEncoded = String(object.jsonEncoded);
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {TW.EOS.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.jsonEncoded = "";
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            object.jsonEncoded = message.jsonEncoded;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return EOS;
        })();
    
        TW.Ethereum = (function() {
    
            /**
             * Namespace Ethereum.
             * @memberof TW
             * @namespace
             */
            var Ethereum = {};
    
            Ethereum.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Ethereum
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Ethereum.Proto
                     * @interface ITransaction
                     * @property {TW.Ethereum.Proto.Transaction.ITransfer|null} [transfer] Transaction transfer
                     * @property {TW.Ethereum.Proto.Transaction.IERC20Transfer|null} [erc20Transfer] Transaction erc20Transfer
                     * @property {TW.Ethereum.Proto.Transaction.IERC20Approve|null} [erc20Approve] Transaction erc20Approve
                     * @property {TW.Ethereum.Proto.Transaction.IERC721Transfer|null} [erc721Transfer] Transaction erc721Transfer
                     * @property {TW.Ethereum.Proto.Transaction.IERC1155Transfer|null} [erc1155Transfer] Transaction erc1155Transfer
                     * @property {TW.Ethereum.Proto.Transaction.IContractGeneric|null} [contractGeneric] Transaction contractGeneric
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Ethereum.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Ethereum.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction transfer.
                     * @member {TW.Ethereum.Proto.Transaction.ITransfer|null|undefined} transfer
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.transfer = null;
    
                    /**
                     * Transaction erc20Transfer.
                     * @member {TW.Ethereum.Proto.Transaction.IERC20Transfer|null|undefined} erc20Transfer
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.erc20Transfer = null;
    
                    /**
                     * Transaction erc20Approve.
                     * @member {TW.Ethereum.Proto.Transaction.IERC20Approve|null|undefined} erc20Approve
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.erc20Approve = null;
    
                    /**
                     * Transaction erc721Transfer.
                     * @member {TW.Ethereum.Proto.Transaction.IERC721Transfer|null|undefined} erc721Transfer
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.erc721Transfer = null;
    
                    /**
                     * Transaction erc1155Transfer.
                     * @member {TW.Ethereum.Proto.Transaction.IERC1155Transfer|null|undefined} erc1155Transfer
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.erc1155Transfer = null;
    
                    /**
                     * Transaction contractGeneric.
                     * @member {TW.Ethereum.Proto.Transaction.IContractGeneric|null|undefined} contractGeneric
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.contractGeneric = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Transaction transactionOneof.
                     * @member {"transfer"|"erc20Transfer"|"erc20Approve"|"erc721Transfer"|"erc1155Transfer"|"contractGeneric"|undefined} transactionOneof
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     */
                    Object.defineProperty(Transaction.prototype, "transactionOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "erc20Transfer", "erc20Approve", "erc721Transfer", "erc1155Transfer", "contractGeneric"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @static
                     * @param {TW.Ethereum.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Ethereum.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @static
                     * @param {TW.Ethereum.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.Ethereum.Proto.Transaction.Transfer.encode(message.transfer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.erc20Transfer != null && Object.hasOwnProperty.call(message, "erc20Transfer"))
                            $root.TW.Ethereum.Proto.Transaction.ERC20Transfer.encode(message.erc20Transfer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.erc20Approve != null && Object.hasOwnProperty.call(message, "erc20Approve"))
                            $root.TW.Ethereum.Proto.Transaction.ERC20Approve.encode(message.erc20Approve, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.erc721Transfer != null && Object.hasOwnProperty.call(message, "erc721Transfer"))
                            $root.TW.Ethereum.Proto.Transaction.ERC721Transfer.encode(message.erc721Transfer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.erc1155Transfer != null && Object.hasOwnProperty.call(message, "erc1155Transfer"))
                            $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer.encode(message.erc1155Transfer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.contractGeneric != null && Object.hasOwnProperty.call(message, "contractGeneric"))
                            $root.TW.Ethereum.Proto.Transaction.ContractGeneric.encode(message.contractGeneric, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ethereum.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transfer = $root.TW.Ethereum.Proto.Transaction.Transfer.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.erc20Transfer = $root.TW.Ethereum.Proto.Transaction.ERC20Transfer.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.erc20Approve = $root.TW.Ethereum.Proto.Transaction.ERC20Approve.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.erc721Transfer = $root.TW.Ethereum.Proto.Transaction.ERC721Transfer.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.erc1155Transfer = $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.contractGeneric = $root.TW.Ethereum.Proto.Transaction.ContractGeneric.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.transactionOneof = 1;
                            {
                                var error = $root.TW.Ethereum.Proto.Transaction.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.erc20Transfer != null && message.hasOwnProperty("erc20Transfer")) {
                            if (properties.transactionOneof === 1)
                                return "transactionOneof: multiple values";
                            properties.transactionOneof = 1;
                            {
                                var error = $root.TW.Ethereum.Proto.Transaction.ERC20Transfer.verify(message.erc20Transfer);
                                if (error)
                                    return "erc20Transfer." + error;
                            }
                        }
                        if (message.erc20Approve != null && message.hasOwnProperty("erc20Approve")) {
                            if (properties.transactionOneof === 1)
                                return "transactionOneof: multiple values";
                            properties.transactionOneof = 1;
                            {
                                var error = $root.TW.Ethereum.Proto.Transaction.ERC20Approve.verify(message.erc20Approve);
                                if (error)
                                    return "erc20Approve." + error;
                            }
                        }
                        if (message.erc721Transfer != null && message.hasOwnProperty("erc721Transfer")) {
                            if (properties.transactionOneof === 1)
                                return "transactionOneof: multiple values";
                            properties.transactionOneof = 1;
                            {
                                var error = $root.TW.Ethereum.Proto.Transaction.ERC721Transfer.verify(message.erc721Transfer);
                                if (error)
                                    return "erc721Transfer." + error;
                            }
                        }
                        if (message.erc1155Transfer != null && message.hasOwnProperty("erc1155Transfer")) {
                            if (properties.transactionOneof === 1)
                                return "transactionOneof: multiple values";
                            properties.transactionOneof = 1;
                            {
                                var error = $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer.verify(message.erc1155Transfer);
                                if (error)
                                    return "erc1155Transfer." + error;
                            }
                        }
                        if (message.contractGeneric != null && message.hasOwnProperty("contractGeneric")) {
                            if (properties.transactionOneof === 1)
                                return "transactionOneof: multiple values";
                            properties.transactionOneof = 1;
                            {
                                var error = $root.TW.Ethereum.Proto.Transaction.ContractGeneric.verify(message.contractGeneric);
                                if (error)
                                    return "contractGeneric." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ethereum.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ethereum.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Ethereum.Proto.Transaction();
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.Ethereum.Proto.Transaction.transfer: object expected");
                            message.transfer = $root.TW.Ethereum.Proto.Transaction.Transfer.fromObject(object.transfer);
                        }
                        if (object.erc20Transfer != null) {
                            if (typeof object.erc20Transfer !== "object")
                                throw TypeError(".TW.Ethereum.Proto.Transaction.erc20Transfer: object expected");
                            message.erc20Transfer = $root.TW.Ethereum.Proto.Transaction.ERC20Transfer.fromObject(object.erc20Transfer);
                        }
                        if (object.erc20Approve != null) {
                            if (typeof object.erc20Approve !== "object")
                                throw TypeError(".TW.Ethereum.Proto.Transaction.erc20Approve: object expected");
                            message.erc20Approve = $root.TW.Ethereum.Proto.Transaction.ERC20Approve.fromObject(object.erc20Approve);
                        }
                        if (object.erc721Transfer != null) {
                            if (typeof object.erc721Transfer !== "object")
                                throw TypeError(".TW.Ethereum.Proto.Transaction.erc721Transfer: object expected");
                            message.erc721Transfer = $root.TW.Ethereum.Proto.Transaction.ERC721Transfer.fromObject(object.erc721Transfer);
                        }
                        if (object.erc1155Transfer != null) {
                            if (typeof object.erc1155Transfer !== "object")
                                throw TypeError(".TW.Ethereum.Proto.Transaction.erc1155Transfer: object expected");
                            message.erc1155Transfer = $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer.fromObject(object.erc1155Transfer);
                        }
                        if (object.contractGeneric != null) {
                            if (typeof object.contractGeneric !== "object")
                                throw TypeError(".TW.Ethereum.Proto.Transaction.contractGeneric: object expected");
                            message.contractGeneric = $root.TW.Ethereum.Proto.Transaction.ContractGeneric.fromObject(object.contractGeneric);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @static
                     * @param {TW.Ethereum.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.Ethereum.Proto.Transaction.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.transactionOneof = "transfer";
                        }
                        if (message.erc20Transfer != null && message.hasOwnProperty("erc20Transfer")) {
                            object.erc20Transfer = $root.TW.Ethereum.Proto.Transaction.ERC20Transfer.toObject(message.erc20Transfer, options);
                            if (options.oneofs)
                                object.transactionOneof = "erc20Transfer";
                        }
                        if (message.erc20Approve != null && message.hasOwnProperty("erc20Approve")) {
                            object.erc20Approve = $root.TW.Ethereum.Proto.Transaction.ERC20Approve.toObject(message.erc20Approve, options);
                            if (options.oneofs)
                                object.transactionOneof = "erc20Approve";
                        }
                        if (message.erc721Transfer != null && message.hasOwnProperty("erc721Transfer")) {
                            object.erc721Transfer = $root.TW.Ethereum.Proto.Transaction.ERC721Transfer.toObject(message.erc721Transfer, options);
                            if (options.oneofs)
                                object.transactionOneof = "erc721Transfer";
                        }
                        if (message.erc1155Transfer != null && message.hasOwnProperty("erc1155Transfer")) {
                            object.erc1155Transfer = $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer.toObject(message.erc1155Transfer, options);
                            if (options.oneofs)
                                object.transactionOneof = "erc1155Transfer";
                        }
                        if (message.contractGeneric != null && message.hasOwnProperty("contractGeneric")) {
                            object.contractGeneric = $root.TW.Ethereum.Proto.Transaction.ContractGeneric.toObject(message.contractGeneric, options);
                            if (options.oneofs)
                                object.transactionOneof = "contractGeneric";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Ethereum.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Transaction.Transfer = (function() {
    
                        /**
                         * Properties of a Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @interface ITransfer
                         * @property {Uint8Array|null} [amount] Transfer amount
                         * @property {Uint8Array|null} [data] Transfer data
                         */
    
                        /**
                         * Constructs a new Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @classdesc Represents a Transfer.
                         * @implements ITransfer
                         * @constructor
                         * @param {TW.Ethereum.Proto.Transaction.ITransfer=} [properties] Properties to set
                         */
                        function Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Transfer amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @instance
                         */
                        Transfer.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * Transfer data.
                         * @member {Uint8Array} data
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @instance
                         */
                        Transfer.prototype.data = $util.newBuffer([]);
    
                        /**
                         * Creates a new Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.ITransfer=} [properties] Properties to set
                         * @returns {TW.Ethereum.Proto.Transaction.Transfer} Transfer instance
                         */
                        Transfer.create = function create(properties) {
                            return new Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.ITransfer} message Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.amount);
                            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                            return writer;
                        };
    
                        /**
                         * Decodes a Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Ethereum.Proto.Transaction.Transfer} Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.Transaction.Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.amount = reader.bytes();
                                    break;
                                case 2:
                                    message.data = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Transfer message.
                         * @function verify
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            if (message.data != null && message.hasOwnProperty("data"))
                                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                    return "data: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Ethereum.Proto.Transaction.Transfer} Transfer
                         */
                        Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Ethereum.Proto.Transaction.Transfer)
                                return object;
                            var message = new $root.TW.Ethereum.Proto.Transaction.Transfer();
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            if (object.data != null)
                                if (typeof object.data === "string")
                                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                                else if (object.data.length)
                                    message.data = object.data;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.Transfer} message Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                                if (options.bytes === String)
                                    object.data = "";
                                else {
                                    object.data = [];
                                    if (options.bytes !== Array)
                                        object.data = $util.newBuffer(object.data);
                                }
                            }
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            if (message.data != null && message.hasOwnProperty("data"))
                                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                            return object;
                        };
    
                        /**
                         * Converts this Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.Ethereum.Proto.Transaction.Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Transfer;
                    })();
    
                    Transaction.ERC20Transfer = (function() {
    
                        /**
                         * Properties of a ERC20Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @interface IERC20Transfer
                         * @property {string|null} [to] ERC20Transfer to
                         * @property {Uint8Array|null} [amount] ERC20Transfer amount
                         */
    
                        /**
                         * Constructs a new ERC20Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @classdesc Represents a ERC20Transfer.
                         * @implements IERC20Transfer
                         * @constructor
                         * @param {TW.Ethereum.Proto.Transaction.IERC20Transfer=} [properties] Properties to set
                         */
                        function ERC20Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ERC20Transfer to.
                         * @member {string} to
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @instance
                         */
                        ERC20Transfer.prototype.to = "";
    
                        /**
                         * ERC20Transfer amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @instance
                         */
                        ERC20Transfer.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * Creates a new ERC20Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC20Transfer=} [properties] Properties to set
                         * @returns {TW.Ethereum.Proto.Transaction.ERC20Transfer} ERC20Transfer instance
                         */
                        ERC20Transfer.create = function create(properties) {
                            return new ERC20Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified ERC20Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC20Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC20Transfer} message ERC20Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ERC20Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.to);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.amount);
                            return writer;
                        };
    
                        /**
                         * Decodes a ERC20Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Ethereum.Proto.Transaction.ERC20Transfer} ERC20Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ERC20Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.Transaction.ERC20Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.to = reader.string();
                                    break;
                                case 2:
                                    message.amount = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a ERC20Transfer message.
                         * @function verify
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ERC20Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.to != null && message.hasOwnProperty("to"))
                                if (!$util.isString(message.to))
                                    return "to: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a ERC20Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Ethereum.Proto.Transaction.ERC20Transfer} ERC20Transfer
                         */
                        ERC20Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Ethereum.Proto.Transaction.ERC20Transfer)
                                return object;
                            var message = new $root.TW.Ethereum.Proto.Transaction.ERC20Transfer();
                            if (object.to != null)
                                message.to = String(object.to);
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a ERC20Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.ERC20Transfer} message ERC20Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ERC20Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.to = "";
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                            }
                            if (message.to != null && message.hasOwnProperty("to"))
                                object.to = message.to;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            return object;
                        };
    
                        /**
                         * Converts this ERC20Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ERC20Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return ERC20Transfer;
                    })();
    
                    Transaction.ERC20Approve = (function() {
    
                        /**
                         * Properties of a ERC20Approve.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @interface IERC20Approve
                         * @property {string|null} [spender] ERC20Approve spender
                         * @property {Uint8Array|null} [amount] ERC20Approve amount
                         */
    
                        /**
                         * Constructs a new ERC20Approve.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @classdesc Represents a ERC20Approve.
                         * @implements IERC20Approve
                         * @constructor
                         * @param {TW.Ethereum.Proto.Transaction.IERC20Approve=} [properties] Properties to set
                         */
                        function ERC20Approve(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ERC20Approve spender.
                         * @member {string} spender
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @instance
                         */
                        ERC20Approve.prototype.spender = "";
    
                        /**
                         * ERC20Approve amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @instance
                         */
                        ERC20Approve.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * Creates a new ERC20Approve instance using the specified properties.
                         * @function create
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC20Approve=} [properties] Properties to set
                         * @returns {TW.Ethereum.Proto.Transaction.ERC20Approve} ERC20Approve instance
                         */
                        ERC20Approve.create = function create(properties) {
                            return new ERC20Approve(properties);
                        };
    
                        /**
                         * Encodes the specified ERC20Approve message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC20Approve.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC20Approve} message ERC20Approve message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ERC20Approve.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.spender != null && Object.hasOwnProperty.call(message, "spender"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.spender);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.amount);
                            return writer;
                        };
    
                        /**
                         * Decodes a ERC20Approve message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Ethereum.Proto.Transaction.ERC20Approve} ERC20Approve
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ERC20Approve.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.Transaction.ERC20Approve();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.spender = reader.string();
                                    break;
                                case 2:
                                    message.amount = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a ERC20Approve message.
                         * @function verify
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ERC20Approve.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.spender != null && message.hasOwnProperty("spender"))
                                if (!$util.isString(message.spender))
                                    return "spender: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a ERC20Approve message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Ethereum.Proto.Transaction.ERC20Approve} ERC20Approve
                         */
                        ERC20Approve.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Ethereum.Proto.Transaction.ERC20Approve)
                                return object;
                            var message = new $root.TW.Ethereum.Proto.Transaction.ERC20Approve();
                            if (object.spender != null)
                                message.spender = String(object.spender);
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a ERC20Approve message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.ERC20Approve} message ERC20Approve
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ERC20Approve.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.spender = "";
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                            }
                            if (message.spender != null && message.hasOwnProperty("spender"))
                                object.spender = message.spender;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            return object;
                        };
    
                        /**
                         * Converts this ERC20Approve to JSON.
                         * @function toJSON
                         * @memberof TW.Ethereum.Proto.Transaction.ERC20Approve
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ERC20Approve.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return ERC20Approve;
                    })();
    
                    Transaction.ERC721Transfer = (function() {
    
                        /**
                         * Properties of a ERC721Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @interface IERC721Transfer
                         * @property {string|null} [from] ERC721Transfer from
                         * @property {string|null} [to] ERC721Transfer to
                         * @property {Uint8Array|null} [tokenId] ERC721Transfer tokenId
                         */
    
                        /**
                         * Constructs a new ERC721Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @classdesc Represents a ERC721Transfer.
                         * @implements IERC721Transfer
                         * @constructor
                         * @param {TW.Ethereum.Proto.Transaction.IERC721Transfer=} [properties] Properties to set
                         */
                        function ERC721Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ERC721Transfer from.
                         * @member {string} from
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @instance
                         */
                        ERC721Transfer.prototype.from = "";
    
                        /**
                         * ERC721Transfer to.
                         * @member {string} to
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @instance
                         */
                        ERC721Transfer.prototype.to = "";
    
                        /**
                         * ERC721Transfer tokenId.
                         * @member {Uint8Array} tokenId
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @instance
                         */
                        ERC721Transfer.prototype.tokenId = $util.newBuffer([]);
    
                        /**
                         * Creates a new ERC721Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC721Transfer=} [properties] Properties to set
                         * @returns {TW.Ethereum.Proto.Transaction.ERC721Transfer} ERC721Transfer instance
                         */
                        ERC721Transfer.create = function create(properties) {
                            return new ERC721Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified ERC721Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC721Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC721Transfer} message ERC721Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ERC721Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.from);
                            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.to);
                            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tokenId);
                            return writer;
                        };
    
                        /**
                         * Decodes a ERC721Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Ethereum.Proto.Transaction.ERC721Transfer} ERC721Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ERC721Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.Transaction.ERC721Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.from = reader.string();
                                    break;
                                case 2:
                                    message.to = reader.string();
                                    break;
                                case 3:
                                    message.tokenId = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a ERC721Transfer message.
                         * @function verify
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ERC721Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.from != null && message.hasOwnProperty("from"))
                                if (!$util.isString(message.from))
                                    return "from: string expected";
                            if (message.to != null && message.hasOwnProperty("to"))
                                if (!$util.isString(message.to))
                                    return "to: string expected";
                            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                                    return "tokenId: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a ERC721Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Ethereum.Proto.Transaction.ERC721Transfer} ERC721Transfer
                         */
                        ERC721Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Ethereum.Proto.Transaction.ERC721Transfer)
                                return object;
                            var message = new $root.TW.Ethereum.Proto.Transaction.ERC721Transfer();
                            if (object.from != null)
                                message.from = String(object.from);
                            if (object.to != null)
                                message.to = String(object.to);
                            if (object.tokenId != null)
                                if (typeof object.tokenId === "string")
                                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                                else if (object.tokenId.length)
                                    message.tokenId = object.tokenId;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a ERC721Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.ERC721Transfer} message ERC721Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ERC721Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.from = "";
                                object.to = "";
                                if (options.bytes === String)
                                    object.tokenId = "";
                                else {
                                    object.tokenId = [];
                                    if (options.bytes !== Array)
                                        object.tokenId = $util.newBuffer(object.tokenId);
                                }
                            }
                            if (message.from != null && message.hasOwnProperty("from"))
                                object.from = message.from;
                            if (message.to != null && message.hasOwnProperty("to"))
                                object.to = message.to;
                            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
                            return object;
                        };
    
                        /**
                         * Converts this ERC721Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.Ethereum.Proto.Transaction.ERC721Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ERC721Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return ERC721Transfer;
                    })();
    
                    Transaction.ERC1155Transfer = (function() {
    
                        /**
                         * Properties of a ERC1155Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @interface IERC1155Transfer
                         * @property {string|null} [from] ERC1155Transfer from
                         * @property {string|null} [to] ERC1155Transfer to
                         * @property {Uint8Array|null} [tokenId] ERC1155Transfer tokenId
                         * @property {Uint8Array|null} [value] ERC1155Transfer value
                         * @property {Uint8Array|null} [data] ERC1155Transfer data
                         */
    
                        /**
                         * Constructs a new ERC1155Transfer.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @classdesc Represents a ERC1155Transfer.
                         * @implements IERC1155Transfer
                         * @constructor
                         * @param {TW.Ethereum.Proto.Transaction.IERC1155Transfer=} [properties] Properties to set
                         */
                        function ERC1155Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ERC1155Transfer from.
                         * @member {string} from
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @instance
                         */
                        ERC1155Transfer.prototype.from = "";
    
                        /**
                         * ERC1155Transfer to.
                         * @member {string} to
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @instance
                         */
                        ERC1155Transfer.prototype.to = "";
    
                        /**
                         * ERC1155Transfer tokenId.
                         * @member {Uint8Array} tokenId
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @instance
                         */
                        ERC1155Transfer.prototype.tokenId = $util.newBuffer([]);
    
                        /**
                         * ERC1155Transfer value.
                         * @member {Uint8Array} value
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @instance
                         */
                        ERC1155Transfer.prototype.value = $util.newBuffer([]);
    
                        /**
                         * ERC1155Transfer data.
                         * @member {Uint8Array} data
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @instance
                         */
                        ERC1155Transfer.prototype.data = $util.newBuffer([]);
    
                        /**
                         * Creates a new ERC1155Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC1155Transfer=} [properties] Properties to set
                         * @returns {TW.Ethereum.Proto.Transaction.ERC1155Transfer} ERC1155Transfer instance
                         */
                        ERC1155Transfer.create = function create(properties) {
                            return new ERC1155Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified ERC1155Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC1155Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IERC1155Transfer} message ERC1155Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ERC1155Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.from);
                            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.to);
                            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tokenId);
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);
                            return writer;
                        };
    
                        /**
                         * Decodes a ERC1155Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Ethereum.Proto.Transaction.ERC1155Transfer} ERC1155Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ERC1155Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.from = reader.string();
                                    break;
                                case 2:
                                    message.to = reader.string();
                                    break;
                                case 3:
                                    message.tokenId = reader.bytes();
                                    break;
                                case 4:
                                    message.value = reader.bytes();
                                    break;
                                case 5:
                                    message.data = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a ERC1155Transfer message.
                         * @function verify
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ERC1155Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.from != null && message.hasOwnProperty("from"))
                                if (!$util.isString(message.from))
                                    return "from: string expected";
                            if (message.to != null && message.hasOwnProperty("to"))
                                if (!$util.isString(message.to))
                                    return "to: string expected";
                            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                                    return "tokenId: buffer expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                    return "value: buffer expected";
                            if (message.data != null && message.hasOwnProperty("data"))
                                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                    return "data: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a ERC1155Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Ethereum.Proto.Transaction.ERC1155Transfer} ERC1155Transfer
                         */
                        ERC1155Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer)
                                return object;
                            var message = new $root.TW.Ethereum.Proto.Transaction.ERC1155Transfer();
                            if (object.from != null)
                                message.from = String(object.from);
                            if (object.to != null)
                                message.to = String(object.to);
                            if (object.tokenId != null)
                                if (typeof object.tokenId === "string")
                                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                                else if (object.tokenId.length)
                                    message.tokenId = object.tokenId;
                            if (object.value != null)
                                if (typeof object.value === "string")
                                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                                else if (object.value.length)
                                    message.value = object.value;
                            if (object.data != null)
                                if (typeof object.data === "string")
                                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                                else if (object.data.length)
                                    message.data = object.data;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a ERC1155Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.ERC1155Transfer} message ERC1155Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ERC1155Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.from = "";
                                object.to = "";
                                if (options.bytes === String)
                                    object.tokenId = "";
                                else {
                                    object.tokenId = [];
                                    if (options.bytes !== Array)
                                        object.tokenId = $util.newBuffer(object.tokenId);
                                }
                                if (options.bytes === String)
                                    object.value = "";
                                else {
                                    object.value = [];
                                    if (options.bytes !== Array)
                                        object.value = $util.newBuffer(object.value);
                                }
                                if (options.bytes === String)
                                    object.data = "";
                                else {
                                    object.data = [];
                                    if (options.bytes !== Array)
                                        object.data = $util.newBuffer(object.data);
                                }
                            }
                            if (message.from != null && message.hasOwnProperty("from"))
                                object.from = message.from;
                            if (message.to != null && message.hasOwnProperty("to"))
                                object.to = message.to;
                            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                            if (message.data != null && message.hasOwnProperty("data"))
                                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                            return object;
                        };
    
                        /**
                         * Converts this ERC1155Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.Ethereum.Proto.Transaction.ERC1155Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ERC1155Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return ERC1155Transfer;
                    })();
    
                    Transaction.ContractGeneric = (function() {
    
                        /**
                         * Properties of a ContractGeneric.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @interface IContractGeneric
                         * @property {Uint8Array|null} [amount] ContractGeneric amount
                         * @property {Uint8Array|null} [data] ContractGeneric data
                         */
    
                        /**
                         * Constructs a new ContractGeneric.
                         * @memberof TW.Ethereum.Proto.Transaction
                         * @classdesc Represents a ContractGeneric.
                         * @implements IContractGeneric
                         * @constructor
                         * @param {TW.Ethereum.Proto.Transaction.IContractGeneric=} [properties] Properties to set
                         */
                        function ContractGeneric(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ContractGeneric amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @instance
                         */
                        ContractGeneric.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * ContractGeneric data.
                         * @member {Uint8Array} data
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @instance
                         */
                        ContractGeneric.prototype.data = $util.newBuffer([]);
    
                        /**
                         * Creates a new ContractGeneric instance using the specified properties.
                         * @function create
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IContractGeneric=} [properties] Properties to set
                         * @returns {TW.Ethereum.Proto.Transaction.ContractGeneric} ContractGeneric instance
                         */
                        ContractGeneric.create = function create(properties) {
                            return new ContractGeneric(properties);
                        };
    
                        /**
                         * Encodes the specified ContractGeneric message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ContractGeneric.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.IContractGeneric} message ContractGeneric message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ContractGeneric.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.amount);
                            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                            return writer;
                        };
    
                        /**
                         * Decodes a ContractGeneric message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Ethereum.Proto.Transaction.ContractGeneric} ContractGeneric
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ContractGeneric.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.Transaction.ContractGeneric();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.amount = reader.bytes();
                                    break;
                                case 2:
                                    message.data = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a ContractGeneric message.
                         * @function verify
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ContractGeneric.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            if (message.data != null && message.hasOwnProperty("data"))
                                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                    return "data: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a ContractGeneric message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Ethereum.Proto.Transaction.ContractGeneric} ContractGeneric
                         */
                        ContractGeneric.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Ethereum.Proto.Transaction.ContractGeneric)
                                return object;
                            var message = new $root.TW.Ethereum.Proto.Transaction.ContractGeneric();
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            if (object.data != null)
                                if (typeof object.data === "string")
                                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                                else if (object.data.length)
                                    message.data = object.data;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a ContractGeneric message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @static
                         * @param {TW.Ethereum.Proto.Transaction.ContractGeneric} message ContractGeneric
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ContractGeneric.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                                if (options.bytes === String)
                                    object.data = "";
                                else {
                                    object.data = [];
                                    if (options.bytes !== Array)
                                        object.data = $util.newBuffer(object.data);
                                }
                            }
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            if (message.data != null && message.hasOwnProperty("data"))
                                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                            return object;
                        };
    
                        /**
                         * Converts this ContractGeneric to JSON.
                         * @function toJSON
                         * @memberof TW.Ethereum.Proto.Transaction.ContractGeneric
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ContractGeneric.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return ContractGeneric;
                    })();
    
                    return Transaction;
                })();
    
                /**
                 * TransactionMode enum.
                 * @name TW.Ethereum.Proto.TransactionMode
                 * @enum {number}
                 * @property {number} Legacy=0 Legacy value
                 * @property {number} Enveloped=1 Enveloped value
                 */
                Proto.TransactionMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "Legacy"] = 0;
                    values[valuesById[1] = "Enveloped"] = 1;
                    return values;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Ethereum.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {TW.Ethereum.Proto.TransactionMode|null} [txMode] SigningInput txMode
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [gasLimit] SigningInput gasLimit
                     * @property {Uint8Array|null} [maxInclusionFeePerGas] SigningInput maxInclusionFeePerGas
                     * @property {Uint8Array|null} [maxFeePerGas] SigningInput maxFeePerGas
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Ethereum.Proto.ITransaction|null} [transaction] SigningInput transaction
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Ethereum.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Ethereum.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput txMode.
                     * @member {TW.Ethereum.Proto.TransactionMode} txMode
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.txMode = 0;
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput maxInclusionFeePerGas.
                     * @member {Uint8Array} maxInclusionFeePerGas
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.maxInclusionFeePerGas = $util.newBuffer([]);
    
                    /**
                     * SigningInput maxFeePerGas.
                     * @member {Uint8Array} maxFeePerGas
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.maxFeePerGas = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput transaction.
                     * @member {TW.Ethereum.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transaction = null;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Ethereum.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ethereum.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chainId);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
                        if (message.txMode != null && Object.hasOwnProperty.call(message, "txMode"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.txMode);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.gasLimit);
                        if (message.maxInclusionFeePerGas != null && Object.hasOwnProperty.call(message, "maxInclusionFeePerGas"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.maxInclusionFeePerGas);
                        if (message.maxFeePerGas != null && Object.hasOwnProperty.call(message, "maxFeePerGas"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.maxFeePerGas);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.toAddress);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                            $root.TW.Ethereum.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ethereum.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.bytes();
                                break;
                            case 2:
                                message.nonce = reader.bytes();
                                break;
                            case 3:
                                message.txMode = reader.int32();
                                break;
                            case 4:
                                message.gasPrice = reader.bytes();
                                break;
                            case 5:
                                message.gasLimit = reader.bytes();
                                break;
                            case 6:
                                message.maxInclusionFeePerGas = reader.bytes();
                                break;
                            case 7:
                                message.maxFeePerGas = reader.bytes();
                                break;
                            case 8:
                                message.toAddress = reader.string();
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            case 10:
                                message.transaction = $root.TW.Ethereum.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.txMode != null && message.hasOwnProperty("txMode"))
                            switch (message.txMode) {
                            default:
                                return "txMode: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.maxInclusionFeePerGas != null && message.hasOwnProperty("maxInclusionFeePerGas"))
                            if (!(message.maxInclusionFeePerGas && typeof message.maxInclusionFeePerGas.length === "number" || $util.isString(message.maxInclusionFeePerGas)))
                                return "maxInclusionFeePerGas: buffer expected";
                        if (message.maxFeePerGas != null && message.hasOwnProperty("maxFeePerGas"))
                            if (!(message.maxFeePerGas && typeof message.maxFeePerGas.length === "number" || $util.isString(message.maxFeePerGas)))
                                return "maxFeePerGas: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Ethereum.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ethereum.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ethereum.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Ethereum.Proto.SigningInput();
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        switch (object.txMode) {
                        case "Legacy":
                        case 0:
                            message.txMode = 0;
                            break;
                        case "Enveloped":
                        case 1:
                            message.txMode = 1;
                            break;
                        }
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.maxInclusionFeePerGas != null)
                            if (typeof object.maxInclusionFeePerGas === "string")
                                $util.base64.decode(object.maxInclusionFeePerGas, message.maxInclusionFeePerGas = $util.newBuffer($util.base64.length(object.maxInclusionFeePerGas)), 0);
                            else if (object.maxInclusionFeePerGas.length)
                                message.maxInclusionFeePerGas = object.maxInclusionFeePerGas;
                        if (object.maxFeePerGas != null)
                            if (typeof object.maxFeePerGas === "string")
                                $util.base64.decode(object.maxFeePerGas, message.maxFeePerGas = $util.newBuffer($util.base64.length(object.maxFeePerGas)), 0);
                            else if (object.maxFeePerGas.length)
                                message.maxFeePerGas = object.maxFeePerGas;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Ethereum.Proto.SigningInput.transaction: object expected");
                            message.transaction = $root.TW.Ethereum.Proto.Transaction.fromObject(object.transaction);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {TW.Ethereum.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            object.txMode = options.enums === String ? "Legacy" : 0;
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            if (options.bytes === String)
                                object.maxInclusionFeePerGas = "";
                            else {
                                object.maxInclusionFeePerGas = [];
                                if (options.bytes !== Array)
                                    object.maxInclusionFeePerGas = $util.newBuffer(object.maxInclusionFeePerGas);
                            }
                            if (options.bytes === String)
                                object.maxFeePerGas = "";
                            else {
                                object.maxFeePerGas = [];
                                if (options.bytes !== Array)
                                    object.maxFeePerGas = $util.newBuffer(object.maxFeePerGas);
                            }
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.transaction = null;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.txMode != null && message.hasOwnProperty("txMode"))
                            object.txMode = options.enums === String ? $root.TW.Ethereum.Proto.TransactionMode[message.txMode] : message.txMode;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.maxInclusionFeePerGas != null && message.hasOwnProperty("maxInclusionFeePerGas"))
                            object.maxInclusionFeePerGas = options.bytes === String ? $util.base64.encode(message.maxInclusionFeePerGas, 0, message.maxInclusionFeePerGas.length) : options.bytes === Array ? Array.prototype.slice.call(message.maxInclusionFeePerGas) : message.maxInclusionFeePerGas;
                        if (message.maxFeePerGas != null && message.hasOwnProperty("maxFeePerGas"))
                            object.maxFeePerGas = options.bytes === String ? $util.base64.encode(message.maxFeePerGas, 0, message.maxFeePerGas.length) : options.bytes === Array ? Array.prototype.slice.call(message.maxFeePerGas) : message.maxFeePerGas;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Ethereum.Proto.Transaction.toObject(message.transaction, options);
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Ethereum.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [v] SigningOutput v
                     * @property {Uint8Array|null} [r] SigningOutput r
                     * @property {Uint8Array|null} [s] SigningOutput s
                     * @property {Uint8Array|null} [data] SigningOutput data
                     * @property {TW.Common.Proto.SigningError|null} [error] error code, 0 is ok, other codes will be treated as errors
                     * @property {string|null} [errorMessage] error code description
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Ethereum.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Ethereum.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput v.
                     * @member {Uint8Array} v
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.v = $util.newBuffer([]);
    
                    /**
                     * SigningOutput r.
                     * @member {Uint8Array} r
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.r = $util.newBuffer([]);
    
                    /**
                     * SigningOutput s.
                     * @member {Uint8Array} s
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.s = $util.newBuffer([]);
    
                    /**
                     * SigningOutput data.
                     * @member {Uint8Array} data
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.data = $util.newBuffer([]);
    
                    /**
                     * error code, 0 is ok, other codes will be treated as errors
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * error code description
                     * @member {string} errorMessage
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.errorMessage = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Ethereum.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ethereum.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.v != null && Object.hasOwnProperty.call(message, "v"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.v);
                        if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.r);
                        if (message.s != null && Object.hasOwnProperty.call(message, "s"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.error);
                        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.errorMessage);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ethereum.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.v = reader.bytes();
                                break;
                            case 3:
                                message.r = reader.bytes();
                                break;
                            case 4:
                                message.s = reader.bytes();
                                break;
                            case 5:
                                message.data = reader.bytes();
                                break;
                            case 6:
                                message.error = reader.int32();
                                break;
                            case 7:
                                message.errorMessage = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.v != null && message.hasOwnProperty("v"))
                            if (!(message.v && typeof message.v.length === "number" || $util.isString(message.v)))
                                return "v: buffer expected";
                        if (message.r != null && message.hasOwnProperty("r"))
                            if (!(message.r && typeof message.r.length === "number" || $util.isString(message.r)))
                                return "r: buffer expected";
                        if (message.s != null && message.hasOwnProperty("s"))
                            if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                                return "s: buffer expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            if (!$util.isString(message.errorMessage))
                                return "errorMessage: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ethereum.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ethereum.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Ethereum.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.v != null)
                            if (typeof object.v === "string")
                                $util.base64.decode(object.v, message.v = $util.newBuffer($util.base64.length(object.v)), 0);
                            else if (object.v.length)
                                message.v = object.v;
                        if (object.r != null)
                            if (typeof object.r === "string")
                                $util.base64.decode(object.r, message.r = $util.newBuffer($util.base64.length(object.r)), 0);
                            else if (object.r.length)
                                message.r = object.r;
                        if (object.s != null)
                            if (typeof object.s === "string")
                                $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
                            else if (object.s.length)
                                message.s = object.s;
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        if (object.errorMessage != null)
                            message.errorMessage = String(object.errorMessage);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {TW.Ethereum.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.v = "";
                            else {
                                object.v = [];
                                if (options.bytes !== Array)
                                    object.v = $util.newBuffer(object.v);
                            }
                            if (options.bytes === String)
                                object.r = "";
                            else {
                                object.r = [];
                                if (options.bytes !== Array)
                                    object.r = $util.newBuffer(object.r);
                            }
                            if (options.bytes === String)
                                object.s = "";
                            else {
                                object.s = [];
                                if (options.bytes !== Array)
                                    object.s = $util.newBuffer(object.s);
                            }
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                            object.error = options.enums === String ? "OK" : 0;
                            object.errorMessage = "";
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.v != null && message.hasOwnProperty("v"))
                            object.v = options.bytes === String ? $util.base64.encode(message.v, 0, message.v.length) : options.bytes === Array ? Array.prototype.slice.call(message.v) : message.v;
                        if (message.r != null && message.hasOwnProperty("r"))
                            object.r = options.bytes === String ? $util.base64.encode(message.r, 0, message.r.length) : options.bytes === Array ? Array.prototype.slice.call(message.r) : message.r;
                        if (message.s != null && message.hasOwnProperty("s"))
                            object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            object.errorMessage = message.errorMessage;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Ethereum;
        })();
    
        TW.Filecoin = (function() {
    
            /**
             * Namespace Filecoin.
             * @memberof TW
             * @namespace
             */
            var Filecoin = {};
    
            Filecoin.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Filecoin
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Filecoin.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [to] SigningInput to
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [value] SigningInput value
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {Uint8Array|null} [gasFeeCap] SigningInput gasFeeCap
                     * @property {Uint8Array|null} [gasPremium] SigningInput gasPremium
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Filecoin.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Filecoin.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput to.
                     * @member {string} to
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.to = "";
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput value.
                     * @member {Uint8Array} value
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.value = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput gasFeeCap.
                     * @member {Uint8Array} gasFeeCap
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasFeeCap = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPremium.
                     * @member {Uint8Array} gasPremium
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPremium = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @static
                     * @param {TW.Filecoin.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Filecoin.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Filecoin.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @static
                     * @param {TW.Filecoin.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.to);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.nonce);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.gasLimit);
                        if (message.gasFeeCap != null && Object.hasOwnProperty.call(message, "gasFeeCap"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.gasFeeCap);
                        if (message.gasPremium != null && Object.hasOwnProperty.call(message, "gasPremium"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.gasPremium);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Filecoin.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Filecoin.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.to = reader.string();
                                break;
                            case 3:
                                message.nonce = reader.uint64();
                                break;
                            case 4:
                                message.value = reader.bytes();
                                break;
                            case 5:
                                message.gasLimit = reader.int64();
                                break;
                            case 6:
                                message.gasFeeCap = reader.bytes();
                                break;
                            case 7:
                                message.gasPremium = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.gasFeeCap != null && message.hasOwnProperty("gasFeeCap"))
                            if (!(message.gasFeeCap && typeof message.gasFeeCap.length === "number" || $util.isString(message.gasFeeCap)))
                                return "gasFeeCap: buffer expected";
                        if (message.gasPremium != null && message.hasOwnProperty("gasPremium"))
                            if (!(message.gasPremium && typeof message.gasPremium.length === "number" || $util.isString(message.gasPremium)))
                                return "gasPremium: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Filecoin.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Filecoin.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Filecoin.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = false;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber();
                        if (object.gasFeeCap != null)
                            if (typeof object.gasFeeCap === "string")
                                $util.base64.decode(object.gasFeeCap, message.gasFeeCap = $util.newBuffer($util.base64.length(object.gasFeeCap)), 0);
                            else if (object.gasFeeCap.length)
                                message.gasFeeCap = object.gasFeeCap;
                        if (object.gasPremium != null)
                            if (typeof object.gasPremium === "string")
                                $util.base64.decode(object.gasPremium, message.gasPremium = $util.newBuffer($util.base64.length(object.gasPremium)), 0);
                            else if (object.gasPremium.length)
                                message.gasPremium = object.gasPremium;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @static
                     * @param {TW.Filecoin.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.to = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.gasFeeCap = "";
                            else {
                                object.gasFeeCap = [];
                                if (options.bytes !== Array)
                                    object.gasFeeCap = $util.newBuffer(object.gasFeeCap);
                            }
                            if (options.bytes === String)
                                object.gasPremium = "";
                            else {
                                object.gasPremium = [];
                                if (options.bytes !== Array)
                                    object.gasPremium = $util.newBuffer(object.gasPremium);
                            }
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber() : message.gasLimit;
                        if (message.gasFeeCap != null && message.hasOwnProperty("gasFeeCap"))
                            object.gasFeeCap = options.bytes === String ? $util.base64.encode(message.gasFeeCap, 0, message.gasFeeCap.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasFeeCap) : message.gasFeeCap;
                        if (message.gasPremium != null && message.hasOwnProperty("gasPremium"))
                            object.gasPremium = options.bytes === String ? $util.base64.encode(message.gasPremium, 0, message.gasPremium.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPremium) : message.gasPremium;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Filecoin.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Filecoin.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Filecoin.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Filecoin.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Filecoin.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Filecoin.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Filecoin.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Filecoin.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Filecoin.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Filecoin.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Filecoin.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Filecoin.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Filecoin.Proto.SigningOutput();
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Filecoin.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.json = "";
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Filecoin.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Filecoin;
        })();
    
        TW.FIO = (function() {
    
            /**
             * Namespace FIO.
             * @memberof TW
             * @namespace
             */
            var FIO = {};
    
            FIO.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.FIO
                 * @namespace
                 */
                var Proto = {};
    
                Proto.PublicAddress = (function() {
    
                    /**
                     * Properties of a PublicAddress.
                     * @memberof TW.FIO.Proto
                     * @interface IPublicAddress
                     * @property {string|null} [coinSymbol] PublicAddress coinSymbol
                     * @property {string|null} [address] PublicAddress address
                     */
    
                    /**
                     * Constructs a new PublicAddress.
                     * @memberof TW.FIO.Proto
                     * @classdesc Represents a PublicAddress.
                     * @implements IPublicAddress
                     * @constructor
                     * @param {TW.FIO.Proto.IPublicAddress=} [properties] Properties to set
                     */
                    function PublicAddress(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * PublicAddress coinSymbol.
                     * @member {string} coinSymbol
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @instance
                     */
                    PublicAddress.prototype.coinSymbol = "";
    
                    /**
                     * PublicAddress address.
                     * @member {string} address
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @instance
                     */
                    PublicAddress.prototype.address = "";
    
                    /**
                     * Creates a new PublicAddress instance using the specified properties.
                     * @function create
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @static
                     * @param {TW.FIO.Proto.IPublicAddress=} [properties] Properties to set
                     * @returns {TW.FIO.Proto.PublicAddress} PublicAddress instance
                     */
                    PublicAddress.create = function create(properties) {
                        return new PublicAddress(properties);
                    };
    
                    /**
                     * Encodes the specified PublicAddress message. Does not implicitly {@link TW.FIO.Proto.PublicAddress.verify|verify} messages.
                     * @function encode
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @static
                     * @param {TW.FIO.Proto.IPublicAddress} message PublicAddress message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PublicAddress.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.coinSymbol != null && Object.hasOwnProperty.call(message, "coinSymbol"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.coinSymbol);
                        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
                        return writer;
                    };
    
                    /**
                     * Decodes a PublicAddress message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.FIO.Proto.PublicAddress} PublicAddress
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PublicAddress.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.PublicAddress();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.coinSymbol = reader.string();
                                break;
                            case 2:
                                message.address = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a PublicAddress message.
                     * @function verify
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PublicAddress.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.coinSymbol != null && message.hasOwnProperty("coinSymbol"))
                            if (!$util.isString(message.coinSymbol))
                                return "coinSymbol: string expected";
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!$util.isString(message.address))
                                return "address: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a PublicAddress message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.FIO.Proto.PublicAddress} PublicAddress
                     */
                    PublicAddress.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.FIO.Proto.PublicAddress)
                            return object;
                        var message = new $root.TW.FIO.Proto.PublicAddress();
                        if (object.coinSymbol != null)
                            message.coinSymbol = String(object.coinSymbol);
                        if (object.address != null)
                            message.address = String(object.address);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a PublicAddress message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @static
                     * @param {TW.FIO.Proto.PublicAddress} message PublicAddress
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PublicAddress.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.coinSymbol = "";
                            object.address = "";
                        }
                        if (message.coinSymbol != null && message.hasOwnProperty("coinSymbol"))
                            object.coinSymbol = message.coinSymbol;
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = message.address;
                        return object;
                    };
    
                    /**
                     * Converts this PublicAddress to JSON.
                     * @function toJSON
                     * @memberof TW.FIO.Proto.PublicAddress
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PublicAddress.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PublicAddress;
                })();
    
                Proto.NewFundsContent = (function() {
    
                    /**
                     * Properties of a NewFundsContent.
                     * @memberof TW.FIO.Proto
                     * @interface INewFundsContent
                     * @property {string|null} [payeePublicAddress] NewFundsContent payeePublicAddress
                     * @property {string|null} [amount] NewFundsContent amount
                     * @property {string|null} [coinSymbol] NewFundsContent coinSymbol
                     * @property {string|null} [memo] NewFundsContent memo
                     * @property {string|null} [hash] NewFundsContent hash
                     * @property {string|null} [offlineUrl] NewFundsContent offlineUrl
                     */
    
                    /**
                     * Constructs a new NewFundsContent.
                     * @memberof TW.FIO.Proto
                     * @classdesc Represents a NewFundsContent.
                     * @implements INewFundsContent
                     * @constructor
                     * @param {TW.FIO.Proto.INewFundsContent=} [properties] Properties to set
                     */
                    function NewFundsContent(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NewFundsContent payeePublicAddress.
                     * @member {string} payeePublicAddress
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @instance
                     */
                    NewFundsContent.prototype.payeePublicAddress = "";
    
                    /**
                     * NewFundsContent amount.
                     * @member {string} amount
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @instance
                     */
                    NewFundsContent.prototype.amount = "";
    
                    /**
                     * NewFundsContent coinSymbol.
                     * @member {string} coinSymbol
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @instance
                     */
                    NewFundsContent.prototype.coinSymbol = "";
    
                    /**
                     * NewFundsContent memo.
                     * @member {string} memo
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @instance
                     */
                    NewFundsContent.prototype.memo = "";
    
                    /**
                     * NewFundsContent hash.
                     * @member {string} hash
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @instance
                     */
                    NewFundsContent.prototype.hash = "";
    
                    /**
                     * NewFundsContent offlineUrl.
                     * @member {string} offlineUrl
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @instance
                     */
                    NewFundsContent.prototype.offlineUrl = "";
    
                    /**
                     * Creates a new NewFundsContent instance using the specified properties.
                     * @function create
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @static
                     * @param {TW.FIO.Proto.INewFundsContent=} [properties] Properties to set
                     * @returns {TW.FIO.Proto.NewFundsContent} NewFundsContent instance
                     */
                    NewFundsContent.create = function create(properties) {
                        return new NewFundsContent(properties);
                    };
    
                    /**
                     * Encodes the specified NewFundsContent message. Does not implicitly {@link TW.FIO.Proto.NewFundsContent.verify|verify} messages.
                     * @function encode
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @static
                     * @param {TW.FIO.Proto.INewFundsContent} message NewFundsContent message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NewFundsContent.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.payeePublicAddress != null && Object.hasOwnProperty.call(message, "payeePublicAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.payeePublicAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                        if (message.coinSymbol != null && Object.hasOwnProperty.call(message, "coinSymbol"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.coinSymbol);
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.memo);
                        if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.hash);
                        if (message.offlineUrl != null && Object.hasOwnProperty.call(message, "offlineUrl"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.offlineUrl);
                        return writer;
                    };
    
                    /**
                     * Decodes a NewFundsContent message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.FIO.Proto.NewFundsContent} NewFundsContent
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NewFundsContent.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.NewFundsContent();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.payeePublicAddress = reader.string();
                                break;
                            case 2:
                                message.amount = reader.string();
                                break;
                            case 3:
                                message.coinSymbol = reader.string();
                                break;
                            case 4:
                                message.memo = reader.string();
                                break;
                            case 5:
                                message.hash = reader.string();
                                break;
                            case 6:
                                message.offlineUrl = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a NewFundsContent message.
                     * @function verify
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NewFundsContent.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.payeePublicAddress != null && message.hasOwnProperty("payeePublicAddress"))
                            if (!$util.isString(message.payeePublicAddress))
                                return "payeePublicAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        if (message.coinSymbol != null && message.hasOwnProperty("coinSymbol"))
                            if (!$util.isString(message.coinSymbol))
                                return "coinSymbol: string expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!$util.isString(message.hash))
                                return "hash: string expected";
                        if (message.offlineUrl != null && message.hasOwnProperty("offlineUrl"))
                            if (!$util.isString(message.offlineUrl))
                                return "offlineUrl: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a NewFundsContent message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.FIO.Proto.NewFundsContent} NewFundsContent
                     */
                    NewFundsContent.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.FIO.Proto.NewFundsContent)
                            return object;
                        var message = new $root.TW.FIO.Proto.NewFundsContent();
                        if (object.payeePublicAddress != null)
                            message.payeePublicAddress = String(object.payeePublicAddress);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        if (object.coinSymbol != null)
                            message.coinSymbol = String(object.coinSymbol);
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.hash != null)
                            message.hash = String(object.hash);
                        if (object.offlineUrl != null)
                            message.offlineUrl = String(object.offlineUrl);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NewFundsContent message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @static
                     * @param {TW.FIO.Proto.NewFundsContent} message NewFundsContent
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NewFundsContent.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.payeePublicAddress = "";
                            object.amount = "";
                            object.coinSymbol = "";
                            object.memo = "";
                            object.hash = "";
                            object.offlineUrl = "";
                        }
                        if (message.payeePublicAddress != null && message.hasOwnProperty("payeePublicAddress"))
                            object.payeePublicAddress = message.payeePublicAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        if (message.coinSymbol != null && message.hasOwnProperty("coinSymbol"))
                            object.coinSymbol = message.coinSymbol;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = message.hash;
                        if (message.offlineUrl != null && message.hasOwnProperty("offlineUrl"))
                            object.offlineUrl = message.offlineUrl;
                        return object;
                    };
    
                    /**
                     * Converts this NewFundsContent to JSON.
                     * @function toJSON
                     * @memberof TW.FIO.Proto.NewFundsContent
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NewFundsContent.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NewFundsContent;
                })();
    
                Proto.Action = (function() {
    
                    /**
                     * Properties of an Action.
                     * @memberof TW.FIO.Proto
                     * @interface IAction
                     * @property {TW.FIO.Proto.Action.IRegisterFioAddress|null} [registerFioAddressMessage] Action registerFioAddressMessage
                     * @property {TW.FIO.Proto.Action.IAddPubAddress|null} [addPubAddressMessage] Action addPubAddressMessage
                     * @property {TW.FIO.Proto.Action.ITransfer|null} [transferMessage] Action transferMessage
                     * @property {TW.FIO.Proto.Action.IRenewFioAddress|null} [renewFioAddressMessage] Action renewFioAddressMessage
                     * @property {TW.FIO.Proto.Action.INewFundsRequest|null} [newFundsRequestMessage] Action newFundsRequestMessage
                     */
    
                    /**
                     * Constructs a new Action.
                     * @memberof TW.FIO.Proto
                     * @classdesc Represents an Action.
                     * @implements IAction
                     * @constructor
                     * @param {TW.FIO.Proto.IAction=} [properties] Properties to set
                     */
                    function Action(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Action registerFioAddressMessage.
                     * @member {TW.FIO.Proto.Action.IRegisterFioAddress|null|undefined} registerFioAddressMessage
                     * @memberof TW.FIO.Proto.Action
                     * @instance
                     */
                    Action.prototype.registerFioAddressMessage = null;
    
                    /**
                     * Action addPubAddressMessage.
                     * @member {TW.FIO.Proto.Action.IAddPubAddress|null|undefined} addPubAddressMessage
                     * @memberof TW.FIO.Proto.Action
                     * @instance
                     */
                    Action.prototype.addPubAddressMessage = null;
    
                    /**
                     * Action transferMessage.
                     * @member {TW.FIO.Proto.Action.ITransfer|null|undefined} transferMessage
                     * @memberof TW.FIO.Proto.Action
                     * @instance
                     */
                    Action.prototype.transferMessage = null;
    
                    /**
                     * Action renewFioAddressMessage.
                     * @member {TW.FIO.Proto.Action.IRenewFioAddress|null|undefined} renewFioAddressMessage
                     * @memberof TW.FIO.Proto.Action
                     * @instance
                     */
                    Action.prototype.renewFioAddressMessage = null;
    
                    /**
                     * Action newFundsRequestMessage.
                     * @member {TW.FIO.Proto.Action.INewFundsRequest|null|undefined} newFundsRequestMessage
                     * @memberof TW.FIO.Proto.Action
                     * @instance
                     */
                    Action.prototype.newFundsRequestMessage = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Action messageOneof.
                     * @member {"registerFioAddressMessage"|"addPubAddressMessage"|"transferMessage"|"renewFioAddressMessage"|"newFundsRequestMessage"|undefined} messageOneof
                     * @memberof TW.FIO.Proto.Action
                     * @instance
                     */
                    Object.defineProperty(Action.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["registerFioAddressMessage", "addPubAddressMessage", "transferMessage", "renewFioAddressMessage", "newFundsRequestMessage"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Action instance using the specified properties.
                     * @function create
                     * @memberof TW.FIO.Proto.Action
                     * @static
                     * @param {TW.FIO.Proto.IAction=} [properties] Properties to set
                     * @returns {TW.FIO.Proto.Action} Action instance
                     */
                    Action.create = function create(properties) {
                        return new Action(properties);
                    };
    
                    /**
                     * Encodes the specified Action message. Does not implicitly {@link TW.FIO.Proto.Action.verify|verify} messages.
                     * @function encode
                     * @memberof TW.FIO.Proto.Action
                     * @static
                     * @param {TW.FIO.Proto.IAction} message Action message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Action.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.registerFioAddressMessage != null && Object.hasOwnProperty.call(message, "registerFioAddressMessage"))
                            $root.TW.FIO.Proto.Action.RegisterFioAddress.encode(message.registerFioAddressMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.addPubAddressMessage != null && Object.hasOwnProperty.call(message, "addPubAddressMessage"))
                            $root.TW.FIO.Proto.Action.AddPubAddress.encode(message.addPubAddressMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.transferMessage != null && Object.hasOwnProperty.call(message, "transferMessage"))
                            $root.TW.FIO.Proto.Action.Transfer.encode(message.transferMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.renewFioAddressMessage != null && Object.hasOwnProperty.call(message, "renewFioAddressMessage"))
                            $root.TW.FIO.Proto.Action.RenewFioAddress.encode(message.renewFioAddressMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.newFundsRequestMessage != null && Object.hasOwnProperty.call(message, "newFundsRequestMessage"))
                            $root.TW.FIO.Proto.Action.NewFundsRequest.encode(message.newFundsRequestMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an Action message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.FIO.Proto.Action
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.FIO.Proto.Action} Action
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Action.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.Action();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.registerFioAddressMessage = $root.TW.FIO.Proto.Action.RegisterFioAddress.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.addPubAddressMessage = $root.TW.FIO.Proto.Action.AddPubAddress.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.transferMessage = $root.TW.FIO.Proto.Action.Transfer.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.renewFioAddressMessage = $root.TW.FIO.Proto.Action.RenewFioAddress.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.newFundsRequestMessage = $root.TW.FIO.Proto.Action.NewFundsRequest.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Action message.
                     * @function verify
                     * @memberof TW.FIO.Proto.Action
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Action.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.registerFioAddressMessage != null && message.hasOwnProperty("registerFioAddressMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.FIO.Proto.Action.RegisterFioAddress.verify(message.registerFioAddressMessage);
                                if (error)
                                    return "registerFioAddressMessage." + error;
                            }
                        }
                        if (message.addPubAddressMessage != null && message.hasOwnProperty("addPubAddressMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.FIO.Proto.Action.AddPubAddress.verify(message.addPubAddressMessage);
                                if (error)
                                    return "addPubAddressMessage." + error;
                            }
                        }
                        if (message.transferMessage != null && message.hasOwnProperty("transferMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.FIO.Proto.Action.Transfer.verify(message.transferMessage);
                                if (error)
                                    return "transferMessage." + error;
                            }
                        }
                        if (message.renewFioAddressMessage != null && message.hasOwnProperty("renewFioAddressMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.FIO.Proto.Action.RenewFioAddress.verify(message.renewFioAddressMessage);
                                if (error)
                                    return "renewFioAddressMessage." + error;
                            }
                        }
                        if (message.newFundsRequestMessage != null && message.hasOwnProperty("newFundsRequestMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.FIO.Proto.Action.NewFundsRequest.verify(message.newFundsRequestMessage);
                                if (error)
                                    return "newFundsRequestMessage." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an Action message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.FIO.Proto.Action
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.FIO.Proto.Action} Action
                     */
                    Action.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.FIO.Proto.Action)
                            return object;
                        var message = new $root.TW.FIO.Proto.Action();
                        if (object.registerFioAddressMessage != null) {
                            if (typeof object.registerFioAddressMessage !== "object")
                                throw TypeError(".TW.FIO.Proto.Action.registerFioAddressMessage: object expected");
                            message.registerFioAddressMessage = $root.TW.FIO.Proto.Action.RegisterFioAddress.fromObject(object.registerFioAddressMessage);
                        }
                        if (object.addPubAddressMessage != null) {
                            if (typeof object.addPubAddressMessage !== "object")
                                throw TypeError(".TW.FIO.Proto.Action.addPubAddressMessage: object expected");
                            message.addPubAddressMessage = $root.TW.FIO.Proto.Action.AddPubAddress.fromObject(object.addPubAddressMessage);
                        }
                        if (object.transferMessage != null) {
                            if (typeof object.transferMessage !== "object")
                                throw TypeError(".TW.FIO.Proto.Action.transferMessage: object expected");
                            message.transferMessage = $root.TW.FIO.Proto.Action.Transfer.fromObject(object.transferMessage);
                        }
                        if (object.renewFioAddressMessage != null) {
                            if (typeof object.renewFioAddressMessage !== "object")
                                throw TypeError(".TW.FIO.Proto.Action.renewFioAddressMessage: object expected");
                            message.renewFioAddressMessage = $root.TW.FIO.Proto.Action.RenewFioAddress.fromObject(object.renewFioAddressMessage);
                        }
                        if (object.newFundsRequestMessage != null) {
                            if (typeof object.newFundsRequestMessage !== "object")
                                throw TypeError(".TW.FIO.Proto.Action.newFundsRequestMessage: object expected");
                            message.newFundsRequestMessage = $root.TW.FIO.Proto.Action.NewFundsRequest.fromObject(object.newFundsRequestMessage);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Action message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.FIO.Proto.Action
                     * @static
                     * @param {TW.FIO.Proto.Action} message Action
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Action.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.registerFioAddressMessage != null && message.hasOwnProperty("registerFioAddressMessage")) {
                            object.registerFioAddressMessage = $root.TW.FIO.Proto.Action.RegisterFioAddress.toObject(message.registerFioAddressMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "registerFioAddressMessage";
                        }
                        if (message.addPubAddressMessage != null && message.hasOwnProperty("addPubAddressMessage")) {
                            object.addPubAddressMessage = $root.TW.FIO.Proto.Action.AddPubAddress.toObject(message.addPubAddressMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "addPubAddressMessage";
                        }
                        if (message.transferMessage != null && message.hasOwnProperty("transferMessage")) {
                            object.transferMessage = $root.TW.FIO.Proto.Action.Transfer.toObject(message.transferMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "transferMessage";
                        }
                        if (message.renewFioAddressMessage != null && message.hasOwnProperty("renewFioAddressMessage")) {
                            object.renewFioAddressMessage = $root.TW.FIO.Proto.Action.RenewFioAddress.toObject(message.renewFioAddressMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "renewFioAddressMessage";
                        }
                        if (message.newFundsRequestMessage != null && message.hasOwnProperty("newFundsRequestMessage")) {
                            object.newFundsRequestMessage = $root.TW.FIO.Proto.Action.NewFundsRequest.toObject(message.newFundsRequestMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "newFundsRequestMessage";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Action to JSON.
                     * @function toJSON
                     * @memberof TW.FIO.Proto.Action
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Action.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Action.RegisterFioAddress = (function() {
    
                        /**
                         * Properties of a RegisterFioAddress.
                         * @memberof TW.FIO.Proto.Action
                         * @interface IRegisterFioAddress
                         * @property {string|null} [fioAddress] RegisterFioAddress fioAddress
                         * @property {string|null} [ownerFioPublicKey] RegisterFioAddress ownerFioPublicKey
                         * @property {Long|null} [fee] RegisterFioAddress fee
                         */
    
                        /**
                         * Constructs a new RegisterFioAddress.
                         * @memberof TW.FIO.Proto.Action
                         * @classdesc Represents a RegisterFioAddress.
                         * @implements IRegisterFioAddress
                         * @constructor
                         * @param {TW.FIO.Proto.Action.IRegisterFioAddress=} [properties] Properties to set
                         */
                        function RegisterFioAddress(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * RegisterFioAddress fioAddress.
                         * @member {string} fioAddress
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @instance
                         */
                        RegisterFioAddress.prototype.fioAddress = "";
    
                        /**
                         * RegisterFioAddress ownerFioPublicKey.
                         * @member {string} ownerFioPublicKey
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @instance
                         */
                        RegisterFioAddress.prototype.ownerFioPublicKey = "";
    
                        /**
                         * RegisterFioAddress fee.
                         * @member {Long} fee
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @instance
                         */
                        RegisterFioAddress.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Creates a new RegisterFioAddress instance using the specified properties.
                         * @function create
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.IRegisterFioAddress=} [properties] Properties to set
                         * @returns {TW.FIO.Proto.Action.RegisterFioAddress} RegisterFioAddress instance
                         */
                        RegisterFioAddress.create = function create(properties) {
                            return new RegisterFioAddress(properties);
                        };
    
                        /**
                         * Encodes the specified RegisterFioAddress message. Does not implicitly {@link TW.FIO.Proto.Action.RegisterFioAddress.verify|verify} messages.
                         * @function encode
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.IRegisterFioAddress} message RegisterFioAddress message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RegisterFioAddress.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.fioAddress != null && Object.hasOwnProperty.call(message, "fioAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fioAddress);
                            if (message.ownerFioPublicKey != null && Object.hasOwnProperty.call(message, "ownerFioPublicKey"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ownerFioPublicKey);
                            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
                            return writer;
                        };
    
                        /**
                         * Decodes a RegisterFioAddress message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.FIO.Proto.Action.RegisterFioAddress} RegisterFioAddress
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RegisterFioAddress.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.Action.RegisterFioAddress();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.fioAddress = reader.string();
                                    break;
                                case 2:
                                    message.ownerFioPublicKey = reader.string();
                                    break;
                                case 3:
                                    message.fee = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a RegisterFioAddress message.
                         * @function verify
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RegisterFioAddress.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.fioAddress != null && message.hasOwnProperty("fioAddress"))
                                if (!$util.isString(message.fioAddress))
                                    return "fioAddress: string expected";
                            if (message.ownerFioPublicKey != null && message.hasOwnProperty("ownerFioPublicKey"))
                                if (!$util.isString(message.ownerFioPublicKey))
                                    return "ownerFioPublicKey: string expected";
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                    return "fee: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a RegisterFioAddress message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.FIO.Proto.Action.RegisterFioAddress} RegisterFioAddress
                         */
                        RegisterFioAddress.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.FIO.Proto.Action.RegisterFioAddress)
                                return object;
                            var message = new $root.TW.FIO.Proto.Action.RegisterFioAddress();
                            if (object.fioAddress != null)
                                message.fioAddress = String(object.fioAddress);
                            if (object.ownerFioPublicKey != null)
                                message.ownerFioPublicKey = String(object.ownerFioPublicKey);
                            if (object.fee != null)
                                if ($util.Long)
                                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                                else if (typeof object.fee === "string")
                                    message.fee = parseInt(object.fee, 10);
                                else if (typeof object.fee === "number")
                                    message.fee = object.fee;
                                else if (typeof object.fee === "object")
                                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a RegisterFioAddress message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.RegisterFioAddress} message RegisterFioAddress
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RegisterFioAddress.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.fioAddress = "";
                                object.ownerFioPublicKey = "";
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.fee = options.longs === String ? "0" : 0;
                            }
                            if (message.fioAddress != null && message.hasOwnProperty("fioAddress"))
                                object.fioAddress = message.fioAddress;
                            if (message.ownerFioPublicKey != null && message.hasOwnProperty("ownerFioPublicKey"))
                                object.ownerFioPublicKey = message.ownerFioPublicKey;
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (typeof message.fee === "number")
                                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                                else
                                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                            return object;
                        };
    
                        /**
                         * Converts this RegisterFioAddress to JSON.
                         * @function toJSON
                         * @memberof TW.FIO.Proto.Action.RegisterFioAddress
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RegisterFioAddress.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return RegisterFioAddress;
                    })();
    
                    Action.AddPubAddress = (function() {
    
                        /**
                         * Properties of an AddPubAddress.
                         * @memberof TW.FIO.Proto.Action
                         * @interface IAddPubAddress
                         * @property {string|null} [fioAddress] AddPubAddress fioAddress
                         * @property {Array.<TW.FIO.Proto.IPublicAddress>|null} [publicAddresses] AddPubAddress publicAddresses
                         * @property {Long|null} [fee] AddPubAddress fee
                         */
    
                        /**
                         * Constructs a new AddPubAddress.
                         * @memberof TW.FIO.Proto.Action
                         * @classdesc Represents an AddPubAddress.
                         * @implements IAddPubAddress
                         * @constructor
                         * @param {TW.FIO.Proto.Action.IAddPubAddress=} [properties] Properties to set
                         */
                        function AddPubAddress(properties) {
                            this.publicAddresses = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * AddPubAddress fioAddress.
                         * @member {string} fioAddress
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @instance
                         */
                        AddPubAddress.prototype.fioAddress = "";
    
                        /**
                         * AddPubAddress publicAddresses.
                         * @member {Array.<TW.FIO.Proto.IPublicAddress>} publicAddresses
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @instance
                         */
                        AddPubAddress.prototype.publicAddresses = $util.emptyArray;
    
                        /**
                         * AddPubAddress fee.
                         * @member {Long} fee
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @instance
                         */
                        AddPubAddress.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Creates a new AddPubAddress instance using the specified properties.
                         * @function create
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.IAddPubAddress=} [properties] Properties to set
                         * @returns {TW.FIO.Proto.Action.AddPubAddress} AddPubAddress instance
                         */
                        AddPubAddress.create = function create(properties) {
                            return new AddPubAddress(properties);
                        };
    
                        /**
                         * Encodes the specified AddPubAddress message. Does not implicitly {@link TW.FIO.Proto.Action.AddPubAddress.verify|verify} messages.
                         * @function encode
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.IAddPubAddress} message AddPubAddress message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AddPubAddress.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.fioAddress != null && Object.hasOwnProperty.call(message, "fioAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fioAddress);
                            if (message.publicAddresses != null && message.publicAddresses.length)
                                for (var i = 0; i < message.publicAddresses.length; ++i)
                                    $root.TW.FIO.Proto.PublicAddress.encode(message.publicAddresses[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
                            return writer;
                        };
    
                        /**
                         * Decodes an AddPubAddress message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.FIO.Proto.Action.AddPubAddress} AddPubAddress
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AddPubAddress.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.Action.AddPubAddress();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.fioAddress = reader.string();
                                    break;
                                case 2:
                                    if (!(message.publicAddresses && message.publicAddresses.length))
                                        message.publicAddresses = [];
                                    message.publicAddresses.push($root.TW.FIO.Proto.PublicAddress.decode(reader, reader.uint32()));
                                    break;
                                case 3:
                                    message.fee = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies an AddPubAddress message.
                         * @function verify
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AddPubAddress.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.fioAddress != null && message.hasOwnProperty("fioAddress"))
                                if (!$util.isString(message.fioAddress))
                                    return "fioAddress: string expected";
                            if (message.publicAddresses != null && message.hasOwnProperty("publicAddresses")) {
                                if (!Array.isArray(message.publicAddresses))
                                    return "publicAddresses: array expected";
                                for (var i = 0; i < message.publicAddresses.length; ++i) {
                                    var error = $root.TW.FIO.Proto.PublicAddress.verify(message.publicAddresses[i]);
                                    if (error)
                                        return "publicAddresses." + error;
                                }
                            }
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                    return "fee: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates an AddPubAddress message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.FIO.Proto.Action.AddPubAddress} AddPubAddress
                         */
                        AddPubAddress.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.FIO.Proto.Action.AddPubAddress)
                                return object;
                            var message = new $root.TW.FIO.Proto.Action.AddPubAddress();
                            if (object.fioAddress != null)
                                message.fioAddress = String(object.fioAddress);
                            if (object.publicAddresses) {
                                if (!Array.isArray(object.publicAddresses))
                                    throw TypeError(".TW.FIO.Proto.Action.AddPubAddress.publicAddresses: array expected");
                                message.publicAddresses = [];
                                for (var i = 0; i < object.publicAddresses.length; ++i) {
                                    if (typeof object.publicAddresses[i] !== "object")
                                        throw TypeError(".TW.FIO.Proto.Action.AddPubAddress.publicAddresses: object expected");
                                    message.publicAddresses[i] = $root.TW.FIO.Proto.PublicAddress.fromObject(object.publicAddresses[i]);
                                }
                            }
                            if (object.fee != null)
                                if ($util.Long)
                                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                                else if (typeof object.fee === "string")
                                    message.fee = parseInt(object.fee, 10);
                                else if (typeof object.fee === "number")
                                    message.fee = object.fee;
                                else if (typeof object.fee === "object")
                                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an AddPubAddress message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.AddPubAddress} message AddPubAddress
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AddPubAddress.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.publicAddresses = [];
                            if (options.defaults) {
                                object.fioAddress = "";
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.fee = options.longs === String ? "0" : 0;
                            }
                            if (message.fioAddress != null && message.hasOwnProperty("fioAddress"))
                                object.fioAddress = message.fioAddress;
                            if (message.publicAddresses && message.publicAddresses.length) {
                                object.publicAddresses = [];
                                for (var j = 0; j < message.publicAddresses.length; ++j)
                                    object.publicAddresses[j] = $root.TW.FIO.Proto.PublicAddress.toObject(message.publicAddresses[j], options);
                            }
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (typeof message.fee === "number")
                                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                                else
                                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                            return object;
                        };
    
                        /**
                         * Converts this AddPubAddress to JSON.
                         * @function toJSON
                         * @memberof TW.FIO.Proto.Action.AddPubAddress
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AddPubAddress.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return AddPubAddress;
                    })();
    
                    Action.Transfer = (function() {
    
                        /**
                         * Properties of a Transfer.
                         * @memberof TW.FIO.Proto.Action
                         * @interface ITransfer
                         * @property {string|null} [payeePublicKey] Transfer payeePublicKey
                         * @property {Long|null} [amount] Transfer amount
                         * @property {Long|null} [fee] Transfer fee
                         */
    
                        /**
                         * Constructs a new Transfer.
                         * @memberof TW.FIO.Proto.Action
                         * @classdesc Represents a Transfer.
                         * @implements ITransfer
                         * @constructor
                         * @param {TW.FIO.Proto.Action.ITransfer=} [properties] Properties to set
                         */
                        function Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Transfer payeePublicKey.
                         * @member {string} payeePublicKey
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @instance
                         */
                        Transfer.prototype.payeePublicKey = "";
    
                        /**
                         * Transfer amount.
                         * @member {Long} amount
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @instance
                         */
                        Transfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Transfer fee.
                         * @member {Long} fee
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @instance
                         */
                        Transfer.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Creates a new Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @static
                         * @param {TW.FIO.Proto.Action.ITransfer=} [properties] Properties to set
                         * @returns {TW.FIO.Proto.Action.Transfer} Transfer instance
                         */
                        Transfer.create = function create(properties) {
                            return new Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified Transfer message. Does not implicitly {@link TW.FIO.Proto.Action.Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @static
                         * @param {TW.FIO.Proto.Action.ITransfer} message Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.payeePublicKey != null && Object.hasOwnProperty.call(message, "payeePublicKey"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payeePublicKey);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
                            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
                            return writer;
                        };
    
                        /**
                         * Decodes a Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.FIO.Proto.Action.Transfer} Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.Action.Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.payeePublicKey = reader.string();
                                    break;
                                case 2:
                                    message.amount = reader.uint64();
                                    break;
                                case 3:
                                    message.fee = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Transfer message.
                         * @function verify
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.payeePublicKey != null && message.hasOwnProperty("payeePublicKey"))
                                if (!$util.isString(message.payeePublicKey))
                                    return "payeePublicKey: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                    return "amount: integer|Long expected";
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                    return "fee: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.FIO.Proto.Action.Transfer} Transfer
                         */
                        Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.FIO.Proto.Action.Transfer)
                                return object;
                            var message = new $root.TW.FIO.Proto.Action.Transfer();
                            if (object.payeePublicKey != null)
                                message.payeePublicKey = String(object.payeePublicKey);
                            if (object.amount != null)
                                if ($util.Long)
                                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                                else if (typeof object.amount === "string")
                                    message.amount = parseInt(object.amount, 10);
                                else if (typeof object.amount === "number")
                                    message.amount = object.amount;
                                else if (typeof object.amount === "object")
                                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                            if (object.fee != null)
                                if ($util.Long)
                                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                                else if (typeof object.fee === "string")
                                    message.fee = parseInt(object.fee, 10);
                                else if (typeof object.fee === "number")
                                    message.fee = object.fee;
                                else if (typeof object.fee === "object")
                                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @static
                         * @param {TW.FIO.Proto.Action.Transfer} message Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.payeePublicKey = "";
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.amount = options.longs === String ? "0" : 0;
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.fee = options.longs === String ? "0" : 0;
                            }
                            if (message.payeePublicKey != null && message.hasOwnProperty("payeePublicKey"))
                                object.payeePublicKey = message.payeePublicKey;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (typeof message.amount === "number")
                                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                                else
                                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (typeof message.fee === "number")
                                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                                else
                                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                            return object;
                        };
    
                        /**
                         * Converts this Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.FIO.Proto.Action.Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Transfer;
                    })();
    
                    Action.RenewFioAddress = (function() {
    
                        /**
                         * Properties of a RenewFioAddress.
                         * @memberof TW.FIO.Proto.Action
                         * @interface IRenewFioAddress
                         * @property {string|null} [fioAddress] RenewFioAddress fioAddress
                         * @property {string|null} [ownerFioPublicKey] RenewFioAddress ownerFioPublicKey
                         * @property {Long|null} [fee] RenewFioAddress fee
                         */
    
                        /**
                         * Constructs a new RenewFioAddress.
                         * @memberof TW.FIO.Proto.Action
                         * @classdesc Represents a RenewFioAddress.
                         * @implements IRenewFioAddress
                         * @constructor
                         * @param {TW.FIO.Proto.Action.IRenewFioAddress=} [properties] Properties to set
                         */
                        function RenewFioAddress(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * RenewFioAddress fioAddress.
                         * @member {string} fioAddress
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @instance
                         */
                        RenewFioAddress.prototype.fioAddress = "";
    
                        /**
                         * RenewFioAddress ownerFioPublicKey.
                         * @member {string} ownerFioPublicKey
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @instance
                         */
                        RenewFioAddress.prototype.ownerFioPublicKey = "";
    
                        /**
                         * RenewFioAddress fee.
                         * @member {Long} fee
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @instance
                         */
                        RenewFioAddress.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Creates a new RenewFioAddress instance using the specified properties.
                         * @function create
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.IRenewFioAddress=} [properties] Properties to set
                         * @returns {TW.FIO.Proto.Action.RenewFioAddress} RenewFioAddress instance
                         */
                        RenewFioAddress.create = function create(properties) {
                            return new RenewFioAddress(properties);
                        };
    
                        /**
                         * Encodes the specified RenewFioAddress message. Does not implicitly {@link TW.FIO.Proto.Action.RenewFioAddress.verify|verify} messages.
                         * @function encode
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.IRenewFioAddress} message RenewFioAddress message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RenewFioAddress.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.fioAddress != null && Object.hasOwnProperty.call(message, "fioAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fioAddress);
                            if (message.ownerFioPublicKey != null && Object.hasOwnProperty.call(message, "ownerFioPublicKey"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ownerFioPublicKey);
                            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
                            return writer;
                        };
    
                        /**
                         * Decodes a RenewFioAddress message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.FIO.Proto.Action.RenewFioAddress} RenewFioAddress
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RenewFioAddress.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.Action.RenewFioAddress();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.fioAddress = reader.string();
                                    break;
                                case 2:
                                    message.ownerFioPublicKey = reader.string();
                                    break;
                                case 3:
                                    message.fee = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a RenewFioAddress message.
                         * @function verify
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RenewFioAddress.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.fioAddress != null && message.hasOwnProperty("fioAddress"))
                                if (!$util.isString(message.fioAddress))
                                    return "fioAddress: string expected";
                            if (message.ownerFioPublicKey != null && message.hasOwnProperty("ownerFioPublicKey"))
                                if (!$util.isString(message.ownerFioPublicKey))
                                    return "ownerFioPublicKey: string expected";
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                    return "fee: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a RenewFioAddress message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.FIO.Proto.Action.RenewFioAddress} RenewFioAddress
                         */
                        RenewFioAddress.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.FIO.Proto.Action.RenewFioAddress)
                                return object;
                            var message = new $root.TW.FIO.Proto.Action.RenewFioAddress();
                            if (object.fioAddress != null)
                                message.fioAddress = String(object.fioAddress);
                            if (object.ownerFioPublicKey != null)
                                message.ownerFioPublicKey = String(object.ownerFioPublicKey);
                            if (object.fee != null)
                                if ($util.Long)
                                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                                else if (typeof object.fee === "string")
                                    message.fee = parseInt(object.fee, 10);
                                else if (typeof object.fee === "number")
                                    message.fee = object.fee;
                                else if (typeof object.fee === "object")
                                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a RenewFioAddress message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @static
                         * @param {TW.FIO.Proto.Action.RenewFioAddress} message RenewFioAddress
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RenewFioAddress.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.fioAddress = "";
                                object.ownerFioPublicKey = "";
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.fee = options.longs === String ? "0" : 0;
                            }
                            if (message.fioAddress != null && message.hasOwnProperty("fioAddress"))
                                object.fioAddress = message.fioAddress;
                            if (message.ownerFioPublicKey != null && message.hasOwnProperty("ownerFioPublicKey"))
                                object.ownerFioPublicKey = message.ownerFioPublicKey;
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (typeof message.fee === "number")
                                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                                else
                                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                            return object;
                        };
    
                        /**
                         * Converts this RenewFioAddress to JSON.
                         * @function toJSON
                         * @memberof TW.FIO.Proto.Action.RenewFioAddress
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RenewFioAddress.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return RenewFioAddress;
                    })();
    
                    Action.NewFundsRequest = (function() {
    
                        /**
                         * Properties of a NewFundsRequest.
                         * @memberof TW.FIO.Proto.Action
                         * @interface INewFundsRequest
                         * @property {string|null} [payerFioName] NewFundsRequest payerFioName
                         * @property {string|null} [payerFioAddress] NewFundsRequest payerFioAddress
                         * @property {string|null} [payeeFioName] NewFundsRequest payeeFioName
                         * @property {TW.FIO.Proto.INewFundsContent|null} [content] NewFundsRequest content
                         * @property {Long|null} [fee] NewFundsRequest fee
                         */
    
                        /**
                         * Constructs a new NewFundsRequest.
                         * @memberof TW.FIO.Proto.Action
                         * @classdesc Represents a NewFundsRequest.
                         * @implements INewFundsRequest
                         * @constructor
                         * @param {TW.FIO.Proto.Action.INewFundsRequest=} [properties] Properties to set
                         */
                        function NewFundsRequest(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * NewFundsRequest payerFioName.
                         * @member {string} payerFioName
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @instance
                         */
                        NewFundsRequest.prototype.payerFioName = "";
    
                        /**
                         * NewFundsRequest payerFioAddress.
                         * @member {string} payerFioAddress
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @instance
                         */
                        NewFundsRequest.prototype.payerFioAddress = "";
    
                        /**
                         * NewFundsRequest payeeFioName.
                         * @member {string} payeeFioName
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @instance
                         */
                        NewFundsRequest.prototype.payeeFioName = "";
    
                        /**
                         * NewFundsRequest content.
                         * @member {TW.FIO.Proto.INewFundsContent|null|undefined} content
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @instance
                         */
                        NewFundsRequest.prototype.content = null;
    
                        /**
                         * NewFundsRequest fee.
                         * @member {Long} fee
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @instance
                         */
                        NewFundsRequest.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Creates a new NewFundsRequest instance using the specified properties.
                         * @function create
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @static
                         * @param {TW.FIO.Proto.Action.INewFundsRequest=} [properties] Properties to set
                         * @returns {TW.FIO.Proto.Action.NewFundsRequest} NewFundsRequest instance
                         */
                        NewFundsRequest.create = function create(properties) {
                            return new NewFundsRequest(properties);
                        };
    
                        /**
                         * Encodes the specified NewFundsRequest message. Does not implicitly {@link TW.FIO.Proto.Action.NewFundsRequest.verify|verify} messages.
                         * @function encode
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @static
                         * @param {TW.FIO.Proto.Action.INewFundsRequest} message NewFundsRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NewFundsRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.payerFioName != null && Object.hasOwnProperty.call(message, "payerFioName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payerFioName);
                            if (message.payerFioAddress != null && Object.hasOwnProperty.call(message, "payerFioAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.payerFioAddress);
                            if (message.payeeFioName != null && Object.hasOwnProperty.call(message, "payeeFioName"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.payeeFioName);
                            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                                $root.TW.FIO.Proto.NewFundsContent.encode(message.content, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.fee);
                            return writer;
                        };
    
                        /**
                         * Decodes a NewFundsRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.FIO.Proto.Action.NewFundsRequest} NewFundsRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NewFundsRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.Action.NewFundsRequest();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.payerFioName = reader.string();
                                    break;
                                case 2:
                                    message.payerFioAddress = reader.string();
                                    break;
                                case 3:
                                    message.payeeFioName = reader.string();
                                    break;
                                case 4:
                                    message.content = $root.TW.FIO.Proto.NewFundsContent.decode(reader, reader.uint32());
                                    break;
                                case 5:
                                    message.fee = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a NewFundsRequest message.
                         * @function verify
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        NewFundsRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.payerFioName != null && message.hasOwnProperty("payerFioName"))
                                if (!$util.isString(message.payerFioName))
                                    return "payerFioName: string expected";
                            if (message.payerFioAddress != null && message.hasOwnProperty("payerFioAddress"))
                                if (!$util.isString(message.payerFioAddress))
                                    return "payerFioAddress: string expected";
                            if (message.payeeFioName != null && message.hasOwnProperty("payeeFioName"))
                                if (!$util.isString(message.payeeFioName))
                                    return "payeeFioName: string expected";
                            if (message.content != null && message.hasOwnProperty("content")) {
                                var error = $root.TW.FIO.Proto.NewFundsContent.verify(message.content);
                                if (error)
                                    return "content." + error;
                            }
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                    return "fee: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a NewFundsRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.FIO.Proto.Action.NewFundsRequest} NewFundsRequest
                         */
                        NewFundsRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.FIO.Proto.Action.NewFundsRequest)
                                return object;
                            var message = new $root.TW.FIO.Proto.Action.NewFundsRequest();
                            if (object.payerFioName != null)
                                message.payerFioName = String(object.payerFioName);
                            if (object.payerFioAddress != null)
                                message.payerFioAddress = String(object.payerFioAddress);
                            if (object.payeeFioName != null)
                                message.payeeFioName = String(object.payeeFioName);
                            if (object.content != null) {
                                if (typeof object.content !== "object")
                                    throw TypeError(".TW.FIO.Proto.Action.NewFundsRequest.content: object expected");
                                message.content = $root.TW.FIO.Proto.NewFundsContent.fromObject(object.content);
                            }
                            if (object.fee != null)
                                if ($util.Long)
                                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                                else if (typeof object.fee === "string")
                                    message.fee = parseInt(object.fee, 10);
                                else if (typeof object.fee === "number")
                                    message.fee = object.fee;
                                else if (typeof object.fee === "object")
                                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a NewFundsRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @static
                         * @param {TW.FIO.Proto.Action.NewFundsRequest} message NewFundsRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        NewFundsRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.payerFioName = "";
                                object.payerFioAddress = "";
                                object.payeeFioName = "";
                                object.content = null;
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.fee = options.longs === String ? "0" : 0;
                            }
                            if (message.payerFioName != null && message.hasOwnProperty("payerFioName"))
                                object.payerFioName = message.payerFioName;
                            if (message.payerFioAddress != null && message.hasOwnProperty("payerFioAddress"))
                                object.payerFioAddress = message.payerFioAddress;
                            if (message.payeeFioName != null && message.hasOwnProperty("payeeFioName"))
                                object.payeeFioName = message.payeeFioName;
                            if (message.content != null && message.hasOwnProperty("content"))
                                object.content = $root.TW.FIO.Proto.NewFundsContent.toObject(message.content, options);
                            if (message.fee != null && message.hasOwnProperty("fee"))
                                if (typeof message.fee === "number")
                                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                                else
                                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                            return object;
                        };
    
                        /**
                         * Converts this NewFundsRequest to JSON.
                         * @function toJSON
                         * @memberof TW.FIO.Proto.Action.NewFundsRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        NewFundsRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return NewFundsRequest;
                    })();
    
                    return Action;
                })();
    
                Proto.ChainParams = (function() {
    
                    /**
                     * Properties of a ChainParams.
                     * @memberof TW.FIO.Proto
                     * @interface IChainParams
                     * @property {Uint8Array|null} [chainId] ChainParams chainId
                     * @property {Long|null} [headBlockNumber] ChainParams headBlockNumber
                     * @property {Long|null} [refBlockPrefix] ChainParams refBlockPrefix
                     */
    
                    /**
                     * Constructs a new ChainParams.
                     * @memberof TW.FIO.Proto
                     * @classdesc Represents a ChainParams.
                     * @implements IChainParams
                     * @constructor
                     * @param {TW.FIO.Proto.IChainParams=} [properties] Properties to set
                     */
                    function ChainParams(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ChainParams chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.FIO.Proto.ChainParams
                     * @instance
                     */
                    ChainParams.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * ChainParams headBlockNumber.
                     * @member {Long} headBlockNumber
                     * @memberof TW.FIO.Proto.ChainParams
                     * @instance
                     */
                    ChainParams.prototype.headBlockNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ChainParams refBlockPrefix.
                     * @member {Long} refBlockPrefix
                     * @memberof TW.FIO.Proto.ChainParams
                     * @instance
                     */
                    ChainParams.prototype.refBlockPrefix = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new ChainParams instance using the specified properties.
                     * @function create
                     * @memberof TW.FIO.Proto.ChainParams
                     * @static
                     * @param {TW.FIO.Proto.IChainParams=} [properties] Properties to set
                     * @returns {TW.FIO.Proto.ChainParams} ChainParams instance
                     */
                    ChainParams.create = function create(properties) {
                        return new ChainParams(properties);
                    };
    
                    /**
                     * Encodes the specified ChainParams message. Does not implicitly {@link TW.FIO.Proto.ChainParams.verify|verify} messages.
                     * @function encode
                     * @memberof TW.FIO.Proto.ChainParams
                     * @static
                     * @param {TW.FIO.Proto.IChainParams} message ChainParams message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChainParams.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chainId);
                        if (message.headBlockNumber != null && Object.hasOwnProperty.call(message, "headBlockNumber"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.headBlockNumber);
                        if (message.refBlockPrefix != null && Object.hasOwnProperty.call(message, "refBlockPrefix"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.refBlockPrefix);
                        return writer;
                    };
    
                    /**
                     * Decodes a ChainParams message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.FIO.Proto.ChainParams
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.FIO.Proto.ChainParams} ChainParams
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChainParams.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.ChainParams();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.bytes();
                                break;
                            case 2:
                                message.headBlockNumber = reader.uint64();
                                break;
                            case 3:
                                message.refBlockPrefix = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a ChainParams message.
                     * @function verify
                     * @memberof TW.FIO.Proto.ChainParams
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChainParams.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.headBlockNumber != null && message.hasOwnProperty("headBlockNumber"))
                            if (!$util.isInteger(message.headBlockNumber) && !(message.headBlockNumber && $util.isInteger(message.headBlockNumber.low) && $util.isInteger(message.headBlockNumber.high)))
                                return "headBlockNumber: integer|Long expected";
                        if (message.refBlockPrefix != null && message.hasOwnProperty("refBlockPrefix"))
                            if (!$util.isInteger(message.refBlockPrefix) && !(message.refBlockPrefix && $util.isInteger(message.refBlockPrefix.low) && $util.isInteger(message.refBlockPrefix.high)))
                                return "refBlockPrefix: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a ChainParams message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.FIO.Proto.ChainParams
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.FIO.Proto.ChainParams} ChainParams
                     */
                    ChainParams.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.FIO.Proto.ChainParams)
                            return object;
                        var message = new $root.TW.FIO.Proto.ChainParams();
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.headBlockNumber != null)
                            if ($util.Long)
                                (message.headBlockNumber = $util.Long.fromValue(object.headBlockNumber)).unsigned = true;
                            else if (typeof object.headBlockNumber === "string")
                                message.headBlockNumber = parseInt(object.headBlockNumber, 10);
                            else if (typeof object.headBlockNumber === "number")
                                message.headBlockNumber = object.headBlockNumber;
                            else if (typeof object.headBlockNumber === "object")
                                message.headBlockNumber = new $util.LongBits(object.headBlockNumber.low >>> 0, object.headBlockNumber.high >>> 0).toNumber(true);
                        if (object.refBlockPrefix != null)
                            if ($util.Long)
                                (message.refBlockPrefix = $util.Long.fromValue(object.refBlockPrefix)).unsigned = true;
                            else if (typeof object.refBlockPrefix === "string")
                                message.refBlockPrefix = parseInt(object.refBlockPrefix, 10);
                            else if (typeof object.refBlockPrefix === "number")
                                message.refBlockPrefix = object.refBlockPrefix;
                            else if (typeof object.refBlockPrefix === "object")
                                message.refBlockPrefix = new $util.LongBits(object.refBlockPrefix.low >>> 0, object.refBlockPrefix.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ChainParams message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.FIO.Proto.ChainParams
                     * @static
                     * @param {TW.FIO.Proto.ChainParams} message ChainParams
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChainParams.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.headBlockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.headBlockNumber = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.refBlockPrefix = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.refBlockPrefix = options.longs === String ? "0" : 0;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.headBlockNumber != null && message.hasOwnProperty("headBlockNumber"))
                            if (typeof message.headBlockNumber === "number")
                                object.headBlockNumber = options.longs === String ? String(message.headBlockNumber) : message.headBlockNumber;
                            else
                                object.headBlockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.headBlockNumber) : options.longs === Number ? new $util.LongBits(message.headBlockNumber.low >>> 0, message.headBlockNumber.high >>> 0).toNumber(true) : message.headBlockNumber;
                        if (message.refBlockPrefix != null && message.hasOwnProperty("refBlockPrefix"))
                            if (typeof message.refBlockPrefix === "number")
                                object.refBlockPrefix = options.longs === String ? String(message.refBlockPrefix) : message.refBlockPrefix;
                            else
                                object.refBlockPrefix = options.longs === String ? $util.Long.prototype.toString.call(message.refBlockPrefix) : options.longs === Number ? new $util.LongBits(message.refBlockPrefix.low >>> 0, message.refBlockPrefix.high >>> 0).toNumber(true) : message.refBlockPrefix;
                        return object;
                    };
    
                    /**
                     * Converts this ChainParams to JSON.
                     * @function toJSON
                     * @memberof TW.FIO.Proto.ChainParams
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChainParams.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ChainParams;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.FIO.Proto
                     * @interface ISigningInput
                     * @property {number|null} [expiry] SigningInput expiry
                     * @property {TW.FIO.Proto.IChainParams|null} [chainParams] SigningInput chainParams
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [tpid] SigningInput tpid
                     * @property {TW.FIO.Proto.IAction|null} [action] SigningInput action
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.FIO.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.FIO.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput expiry.
                     * @member {number} expiry
                     * @memberof TW.FIO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.expiry = 0;
    
                    /**
                     * SigningInput chainParams.
                     * @member {TW.FIO.Proto.IChainParams|null|undefined} chainParams
                     * @memberof TW.FIO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainParams = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.FIO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput tpid.
                     * @member {string} tpid
                     * @memberof TW.FIO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.tpid = "";
    
                    /**
                     * SigningInput action.
                     * @member {TW.FIO.Proto.IAction|null|undefined} action
                     * @memberof TW.FIO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.action = null;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.FIO.Proto.SigningInput
                     * @static
                     * @param {TW.FIO.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.FIO.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.FIO.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.FIO.Proto.SigningInput
                     * @static
                     * @param {TW.FIO.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.expiry);
                        if (message.chainParams != null && Object.hasOwnProperty.call(message, "chainParams"))
                            $root.TW.FIO.Proto.ChainParams.encode(message.chainParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
                        if (message.tpid != null && Object.hasOwnProperty.call(message, "tpid"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.tpid);
                        if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                            $root.TW.FIO.Proto.Action.encode(message.action, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.FIO.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.FIO.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.expiry = reader.uint32();
                                break;
                            case 2:
                                message.chainParams = $root.TW.FIO.Proto.ChainParams.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.privateKey = reader.bytes();
                                break;
                            case 4:
                                message.tpid = reader.string();
                                break;
                            case 5:
                                message.action = $root.TW.FIO.Proto.Action.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.FIO.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.expiry != null && message.hasOwnProperty("expiry"))
                            if (!$util.isInteger(message.expiry))
                                return "expiry: integer expected";
                        if (message.chainParams != null && message.hasOwnProperty("chainParams")) {
                            var error = $root.TW.FIO.Proto.ChainParams.verify(message.chainParams);
                            if (error)
                                return "chainParams." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.tpid != null && message.hasOwnProperty("tpid"))
                            if (!$util.isString(message.tpid))
                                return "tpid: string expected";
                        if (message.action != null && message.hasOwnProperty("action")) {
                            var error = $root.TW.FIO.Proto.Action.verify(message.action);
                            if (error)
                                return "action." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.FIO.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.FIO.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.FIO.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.FIO.Proto.SigningInput();
                        if (object.expiry != null)
                            message.expiry = object.expiry >>> 0;
                        if (object.chainParams != null) {
                            if (typeof object.chainParams !== "object")
                                throw TypeError(".TW.FIO.Proto.SigningInput.chainParams: object expected");
                            message.chainParams = $root.TW.FIO.Proto.ChainParams.fromObject(object.chainParams);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.tpid != null)
                            message.tpid = String(object.tpid);
                        if (object.action != null) {
                            if (typeof object.action !== "object")
                                throw TypeError(".TW.FIO.Proto.SigningInput.action: object expected");
                            message.action = $root.TW.FIO.Proto.Action.fromObject(object.action);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.FIO.Proto.SigningInput
                     * @static
                     * @param {TW.FIO.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.expiry = 0;
                            object.chainParams = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.tpid = "";
                            object.action = null;
                        }
                        if (message.expiry != null && message.hasOwnProperty("expiry"))
                            object.expiry = message.expiry;
                        if (message.chainParams != null && message.hasOwnProperty("chainParams"))
                            object.chainParams = $root.TW.FIO.Proto.ChainParams.toObject(message.chainParams, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.tpid != null && message.hasOwnProperty("tpid"))
                            object.tpid = message.tpid;
                        if (message.action != null && message.hasOwnProperty("action"))
                            object.action = $root.TW.FIO.Proto.Action.toObject(message.action, options);
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.FIO.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.FIO.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [json] SigningOutput json
                     * @property {TW.Common.Proto.SigningError|null} [error] SigningOutput error
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.FIO.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.FIO.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @static
                     * @param {TW.FIO.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.FIO.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.FIO.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @static
                     * @param {TW.FIO.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.FIO.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.FIO.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.json = reader.string();
                                break;
                            case 2:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.FIO.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.FIO.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.FIO.Proto.SigningOutput();
                        if (object.json != null)
                            message.json = String(object.json);
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @static
                     * @param {TW.FIO.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.json = "";
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.FIO.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return FIO;
        })();
    
        TW.Harmony = (function() {
    
            /**
             * Namespace Harmony.
             * @memberof TW
             * @namespace
             */
            var Harmony = {};
    
            Harmony.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Harmony
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Harmony.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Harmony.Proto.ITransactionMessage|null} [transactionMessage] SigningInput transactionMessage
                     * @property {TW.Harmony.Proto.IStakingMessage|null} [stakingMessage] SigningInput stakingMessage
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Harmony.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput transactionMessage.
                     * @member {TW.Harmony.Proto.ITransactionMessage|null|undefined} transactionMessage
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transactionMessage = null;
    
                    /**
                     * SigningInput stakingMessage.
                     * @member {TW.Harmony.Proto.IStakingMessage|null|undefined} stakingMessage
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakingMessage = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput messageOneof.
                     * @member {"transactionMessage"|"stakingMessage"|undefined} messageOneof
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transactionMessage", "stakingMessage"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @static
                     * @param {TW.Harmony.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Harmony.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @static
                     * @param {TW.Harmony.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chainId);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                        if (message.transactionMessage != null && Object.hasOwnProperty.call(message, "transactionMessage"))
                            $root.TW.Harmony.Proto.TransactionMessage.encode(message.transactionMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.stakingMessage != null && Object.hasOwnProperty.call(message, "stakingMessage"))
                            $root.TW.Harmony.Proto.StakingMessage.encode(message.stakingMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.bytes();
                                break;
                            case 2:
                                message.privateKey = reader.bytes();
                                break;
                            case 3:
                                message.transactionMessage = $root.TW.Harmony.Proto.TransactionMessage.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.stakingMessage = $root.TW.Harmony.Proto.StakingMessage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.transactionMessage != null && message.hasOwnProperty("transactionMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Harmony.Proto.TransactionMessage.verify(message.transactionMessage);
                                if (error)
                                    return "transactionMessage." + error;
                            }
                        }
                        if (message.stakingMessage != null && message.hasOwnProperty("stakingMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Harmony.Proto.StakingMessage.verify(message.stakingMessage);
                                if (error)
                                    return "stakingMessage." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Harmony.Proto.SigningInput();
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.transactionMessage != null) {
                            if (typeof object.transactionMessage !== "object")
                                throw TypeError(".TW.Harmony.Proto.SigningInput.transactionMessage: object expected");
                            message.transactionMessage = $root.TW.Harmony.Proto.TransactionMessage.fromObject(object.transactionMessage);
                        }
                        if (object.stakingMessage != null) {
                            if (typeof object.stakingMessage !== "object")
                                throw TypeError(".TW.Harmony.Proto.SigningInput.stakingMessage: object expected");
                            message.stakingMessage = $root.TW.Harmony.Proto.StakingMessage.fromObject(object.stakingMessage);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @static
                     * @param {TW.Harmony.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.transactionMessage != null && message.hasOwnProperty("transactionMessage")) {
                            object.transactionMessage = $root.TW.Harmony.Proto.TransactionMessage.toObject(message.transactionMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "transactionMessage";
                        }
                        if (message.stakingMessage != null && message.hasOwnProperty("stakingMessage")) {
                            object.stakingMessage = $root.TW.Harmony.Proto.StakingMessage.toObject(message.stakingMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "stakingMessage";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Harmony.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [v] SigningOutput v
                     * @property {Uint8Array|null} [r] SigningOutput r
                     * @property {Uint8Array|null} [s] SigningOutput s
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Harmony.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput v.
                     * @member {Uint8Array} v
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.v = $util.newBuffer([]);
    
                    /**
                     * SigningOutput r.
                     * @member {Uint8Array} r
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.r = $util.newBuffer([]);
    
                    /**
                     * SigningOutput s.
                     * @member {Uint8Array} s
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.s = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @static
                     * @param {TW.Harmony.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Harmony.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @static
                     * @param {TW.Harmony.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.v != null && Object.hasOwnProperty.call(message, "v"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.v);
                        if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.r);
                        if (message.s != null && Object.hasOwnProperty.call(message, "s"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.v = reader.bytes();
                                break;
                            case 3:
                                message.r = reader.bytes();
                                break;
                            case 4:
                                message.s = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.v != null && message.hasOwnProperty("v"))
                            if (!(message.v && typeof message.v.length === "number" || $util.isString(message.v)))
                                return "v: buffer expected";
                        if (message.r != null && message.hasOwnProperty("r"))
                            if (!(message.r && typeof message.r.length === "number" || $util.isString(message.r)))
                                return "r: buffer expected";
                        if (message.s != null && message.hasOwnProperty("s"))
                            if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                                return "s: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Harmony.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.v != null)
                            if (typeof object.v === "string")
                                $util.base64.decode(object.v, message.v = $util.newBuffer($util.base64.length(object.v)), 0);
                            else if (object.v.length)
                                message.v = object.v;
                        if (object.r != null)
                            if (typeof object.r === "string")
                                $util.base64.decode(object.r, message.r = $util.newBuffer($util.base64.length(object.r)), 0);
                            else if (object.r.length)
                                message.r = object.r;
                        if (object.s != null)
                            if (typeof object.s === "string")
                                $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
                            else if (object.s.length)
                                message.s = object.s;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @static
                     * @param {TW.Harmony.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.v = "";
                            else {
                                object.v = [];
                                if (options.bytes !== Array)
                                    object.v = $util.newBuffer(object.v);
                            }
                            if (options.bytes === String)
                                object.r = "";
                            else {
                                object.r = [];
                                if (options.bytes !== Array)
                                    object.r = $util.newBuffer(object.r);
                            }
                            if (options.bytes === String)
                                object.s = "";
                            else {
                                object.s = [];
                                if (options.bytes !== Array)
                                    object.s = $util.newBuffer(object.s);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.v != null && message.hasOwnProperty("v"))
                            object.v = options.bytes === String ? $util.base64.encode(message.v, 0, message.v.length) : options.bytes === Array ? Array.prototype.slice.call(message.v) : message.v;
                        if (message.r != null && message.hasOwnProperty("r"))
                            object.r = options.bytes === String ? $util.base64.encode(message.r, 0, message.r.length) : options.bytes === Array ? Array.prototype.slice.call(message.r) : message.r;
                        if (message.s != null && message.hasOwnProperty("s"))
                            object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.TransactionMessage = (function() {
    
                    /**
                     * Properties of a TransactionMessage.
                     * @memberof TW.Harmony.Proto
                     * @interface ITransactionMessage
                     * @property {Uint8Array|null} [nonce] TransactionMessage nonce
                     * @property {Uint8Array|null} [gasPrice] TransactionMessage gasPrice
                     * @property {Uint8Array|null} [gasLimit] TransactionMessage gasLimit
                     * @property {string|null} [toAddress] TransactionMessage toAddress
                     * @property {Uint8Array|null} [amount] TransactionMessage amount
                     * @property {Uint8Array|null} [payload] TransactionMessage payload
                     * @property {Uint8Array|null} [fromShardId] TransactionMessage fromShardId
                     * @property {Uint8Array|null} [toShardId] TransactionMessage toShardId
                     */
    
                    /**
                     * Constructs a new TransactionMessage.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a TransactionMessage.
                     * @implements ITransactionMessage
                     * @constructor
                     * @param {TW.Harmony.Proto.ITransactionMessage=} [properties] Properties to set
                     */
                    function TransactionMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionMessage nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * TransactionMessage gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * TransactionMessage gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * TransactionMessage toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.toAddress = "";
    
                    /**
                     * TransactionMessage amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * TransactionMessage payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * TransactionMessage fromShardId.
                     * @member {Uint8Array} fromShardId
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.fromShardId = $util.newBuffer([]);
    
                    /**
                     * TransactionMessage toShardId.
                     * @member {Uint8Array} toShardId
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     */
                    TransactionMessage.prototype.toShardId = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @static
                     * @param {TW.Harmony.Proto.ITransactionMessage=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.TransactionMessage} TransactionMessage instance
                     */
                    TransactionMessage.create = function create(properties) {
                        return new TransactionMessage(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionMessage message. Does not implicitly {@link TW.Harmony.Proto.TransactionMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @static
                     * @param {TW.Harmony.Proto.ITransactionMessage} message TransactionMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.gasLimit);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.amount);
                        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
                        if (message.fromShardId != null && Object.hasOwnProperty.call(message, "fromShardId"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.fromShardId);
                        if (message.toShardId != null && Object.hasOwnProperty.call(message, "toShardId"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.toShardId);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.TransactionMessage} TransactionMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.TransactionMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nonce = reader.bytes();
                                break;
                            case 2:
                                message.gasPrice = reader.bytes();
                                break;
                            case 3:
                                message.gasLimit = reader.bytes();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.amount = reader.bytes();
                                break;
                            case 6:
                                message.payload = reader.bytes();
                                break;
                            case 7:
                                message.fromShardId = reader.bytes();
                                break;
                            case 8:
                                message.toShardId = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionMessage message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        if (message.fromShardId != null && message.hasOwnProperty("fromShardId"))
                            if (!(message.fromShardId && typeof message.fromShardId.length === "number" || $util.isString(message.fromShardId)))
                                return "fromShardId: buffer expected";
                        if (message.toShardId != null && message.hasOwnProperty("toShardId"))
                            if (!(message.toShardId && typeof message.toShardId.length === "number" || $util.isString(message.toShardId)))
                                return "toShardId: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.TransactionMessage} TransactionMessage
                     */
                    TransactionMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.TransactionMessage)
                            return object;
                        var message = new $root.TW.Harmony.Proto.TransactionMessage();
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        if (object.fromShardId != null)
                            if (typeof object.fromShardId === "string")
                                $util.base64.decode(object.fromShardId, message.fromShardId = $util.newBuffer($util.base64.length(object.fromShardId)), 0);
                            else if (object.fromShardId.length)
                                message.fromShardId = object.fromShardId;
                        if (object.toShardId != null)
                            if (typeof object.toShardId === "string")
                                $util.base64.decode(object.toShardId, message.toShardId = $util.newBuffer($util.base64.length(object.toShardId)), 0);
                            else if (object.toShardId.length)
                                message.toShardId = object.toShardId;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @static
                     * @param {TW.Harmony.Proto.TransactionMessage} message TransactionMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                            if (options.bytes === String)
                                object.fromShardId = "";
                            else {
                                object.fromShardId = [];
                                if (options.bytes !== Array)
                                    object.fromShardId = $util.newBuffer(object.fromShardId);
                            }
                            if (options.bytes === String)
                                object.toShardId = "";
                            else {
                                object.toShardId = [];
                                if (options.bytes !== Array)
                                    object.toShardId = $util.newBuffer(object.toShardId);
                            }
                        }
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        if (message.fromShardId != null && message.hasOwnProperty("fromShardId"))
                            object.fromShardId = options.bytes === String ? $util.base64.encode(message.fromShardId, 0, message.fromShardId.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromShardId) : message.fromShardId;
                        if (message.toShardId != null && message.hasOwnProperty("toShardId"))
                            object.toShardId = options.bytes === String ? $util.base64.encode(message.toShardId, 0, message.toShardId.length) : options.bytes === Array ? Array.prototype.slice.call(message.toShardId) : message.toShardId;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.TransactionMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionMessage;
                })();
    
                Proto.StakingMessage = (function() {
    
                    /**
                     * Properties of a StakingMessage.
                     * @memberof TW.Harmony.Proto
                     * @interface IStakingMessage
                     * @property {TW.Harmony.Proto.IDirectiveCreateValidator|null} [createValidatorMessage] StakingMessage createValidatorMessage
                     * @property {TW.Harmony.Proto.IDirectiveEditValidator|null} [editValidatorMessage] StakingMessage editValidatorMessage
                     * @property {TW.Harmony.Proto.IDirectiveDelegate|null} [delegateMessage] StakingMessage delegateMessage
                     * @property {TW.Harmony.Proto.IDirectiveUndelegate|null} [undelegateMessage] StakingMessage undelegateMessage
                     * @property {TW.Harmony.Proto.IDirectiveCollectRewards|null} [collectRewards] StakingMessage collectRewards
                     * @property {Uint8Array|null} [nonce] StakingMessage nonce
                     * @property {Uint8Array|null} [gasPrice] StakingMessage gasPrice
                     * @property {Uint8Array|null} [gasLimit] StakingMessage gasLimit
                     */
    
                    /**
                     * Constructs a new StakingMessage.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a StakingMessage.
                     * @implements IStakingMessage
                     * @constructor
                     * @param {TW.Harmony.Proto.IStakingMessage=} [properties] Properties to set
                     */
                    function StakingMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * StakingMessage createValidatorMessage.
                     * @member {TW.Harmony.Proto.IDirectiveCreateValidator|null|undefined} createValidatorMessage
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.createValidatorMessage = null;
    
                    /**
                     * StakingMessage editValidatorMessage.
                     * @member {TW.Harmony.Proto.IDirectiveEditValidator|null|undefined} editValidatorMessage
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.editValidatorMessage = null;
    
                    /**
                     * StakingMessage delegateMessage.
                     * @member {TW.Harmony.Proto.IDirectiveDelegate|null|undefined} delegateMessage
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.delegateMessage = null;
    
                    /**
                     * StakingMessage undelegateMessage.
                     * @member {TW.Harmony.Proto.IDirectiveUndelegate|null|undefined} undelegateMessage
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.undelegateMessage = null;
    
                    /**
                     * StakingMessage collectRewards.
                     * @member {TW.Harmony.Proto.IDirectiveCollectRewards|null|undefined} collectRewards
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.collectRewards = null;
    
                    /**
                     * StakingMessage nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * StakingMessage gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * StakingMessage gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    StakingMessage.prototype.gasLimit = $util.newBuffer([]);
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * StakingMessage stakeMsg.
                     * @member {"createValidatorMessage"|"editValidatorMessage"|"delegateMessage"|"undelegateMessage"|"collectRewards"|undefined} stakeMsg
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     */
                    Object.defineProperty(StakingMessage.prototype, "stakeMsg", {
                        get: $util.oneOfGetter($oneOfFields = ["createValidatorMessage", "editValidatorMessage", "delegateMessage", "undelegateMessage", "collectRewards"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new StakingMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @static
                     * @param {TW.Harmony.Proto.IStakingMessage=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.StakingMessage} StakingMessage instance
                     */
                    StakingMessage.create = function create(properties) {
                        return new StakingMessage(properties);
                    };
    
                    /**
                     * Encodes the specified StakingMessage message. Does not implicitly {@link TW.Harmony.Proto.StakingMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @static
                     * @param {TW.Harmony.Proto.IStakingMessage} message StakingMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StakingMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.createValidatorMessage != null && Object.hasOwnProperty.call(message, "createValidatorMessage"))
                            $root.TW.Harmony.Proto.DirectiveCreateValidator.encode(message.createValidatorMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.editValidatorMessage != null && Object.hasOwnProperty.call(message, "editValidatorMessage"))
                            $root.TW.Harmony.Proto.DirectiveEditValidator.encode(message.editValidatorMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.delegateMessage != null && Object.hasOwnProperty.call(message, "delegateMessage"))
                            $root.TW.Harmony.Proto.DirectiveDelegate.encode(message.delegateMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.undelegateMessage != null && Object.hasOwnProperty.call(message, "undelegateMessage"))
                            $root.TW.Harmony.Proto.DirectiveUndelegate.encode(message.undelegateMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.collectRewards != null && Object.hasOwnProperty.call(message, "collectRewards"))
                            $root.TW.Harmony.Proto.DirectiveCollectRewards.encode(message.collectRewards, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.nonce);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.gasLimit);
                        return writer;
                    };
    
                    /**
                     * Decodes a StakingMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.StakingMessage} StakingMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StakingMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.StakingMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.createValidatorMessage = $root.TW.Harmony.Proto.DirectiveCreateValidator.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.editValidatorMessage = $root.TW.Harmony.Proto.DirectiveEditValidator.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.delegateMessage = $root.TW.Harmony.Proto.DirectiveDelegate.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.undelegateMessage = $root.TW.Harmony.Proto.DirectiveUndelegate.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.collectRewards = $root.TW.Harmony.Proto.DirectiveCollectRewards.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.nonce = reader.bytes();
                                break;
                            case 7:
                                message.gasPrice = reader.bytes();
                                break;
                            case 8:
                                message.gasLimit = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a StakingMessage message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StakingMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.createValidatorMessage != null && message.hasOwnProperty("createValidatorMessage")) {
                            properties.stakeMsg = 1;
                            {
                                var error = $root.TW.Harmony.Proto.DirectiveCreateValidator.verify(message.createValidatorMessage);
                                if (error)
                                    return "createValidatorMessage." + error;
                            }
                        }
                        if (message.editValidatorMessage != null && message.hasOwnProperty("editValidatorMessage")) {
                            if (properties.stakeMsg === 1)
                                return "stakeMsg: multiple values";
                            properties.stakeMsg = 1;
                            {
                                var error = $root.TW.Harmony.Proto.DirectiveEditValidator.verify(message.editValidatorMessage);
                                if (error)
                                    return "editValidatorMessage." + error;
                            }
                        }
                        if (message.delegateMessage != null && message.hasOwnProperty("delegateMessage")) {
                            if (properties.stakeMsg === 1)
                                return "stakeMsg: multiple values";
                            properties.stakeMsg = 1;
                            {
                                var error = $root.TW.Harmony.Proto.DirectiveDelegate.verify(message.delegateMessage);
                                if (error)
                                    return "delegateMessage." + error;
                            }
                        }
                        if (message.undelegateMessage != null && message.hasOwnProperty("undelegateMessage")) {
                            if (properties.stakeMsg === 1)
                                return "stakeMsg: multiple values";
                            properties.stakeMsg = 1;
                            {
                                var error = $root.TW.Harmony.Proto.DirectiveUndelegate.verify(message.undelegateMessage);
                                if (error)
                                    return "undelegateMessage." + error;
                            }
                        }
                        if (message.collectRewards != null && message.hasOwnProperty("collectRewards")) {
                            if (properties.stakeMsg === 1)
                                return "stakeMsg: multiple values";
                            properties.stakeMsg = 1;
                            {
                                var error = $root.TW.Harmony.Proto.DirectiveCollectRewards.verify(message.collectRewards);
                                if (error)
                                    return "collectRewards." + error;
                            }
                        }
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a StakingMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.StakingMessage} StakingMessage
                     */
                    StakingMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.StakingMessage)
                            return object;
                        var message = new $root.TW.Harmony.Proto.StakingMessage();
                        if (object.createValidatorMessage != null) {
                            if (typeof object.createValidatorMessage !== "object")
                                throw TypeError(".TW.Harmony.Proto.StakingMessage.createValidatorMessage: object expected");
                            message.createValidatorMessage = $root.TW.Harmony.Proto.DirectiveCreateValidator.fromObject(object.createValidatorMessage);
                        }
                        if (object.editValidatorMessage != null) {
                            if (typeof object.editValidatorMessage !== "object")
                                throw TypeError(".TW.Harmony.Proto.StakingMessage.editValidatorMessage: object expected");
                            message.editValidatorMessage = $root.TW.Harmony.Proto.DirectiveEditValidator.fromObject(object.editValidatorMessage);
                        }
                        if (object.delegateMessage != null) {
                            if (typeof object.delegateMessage !== "object")
                                throw TypeError(".TW.Harmony.Proto.StakingMessage.delegateMessage: object expected");
                            message.delegateMessage = $root.TW.Harmony.Proto.DirectiveDelegate.fromObject(object.delegateMessage);
                        }
                        if (object.undelegateMessage != null) {
                            if (typeof object.undelegateMessage !== "object")
                                throw TypeError(".TW.Harmony.Proto.StakingMessage.undelegateMessage: object expected");
                            message.undelegateMessage = $root.TW.Harmony.Proto.DirectiveUndelegate.fromObject(object.undelegateMessage);
                        }
                        if (object.collectRewards != null) {
                            if (typeof object.collectRewards !== "object")
                                throw TypeError(".TW.Harmony.Proto.StakingMessage.collectRewards: object expected");
                            message.collectRewards = $root.TW.Harmony.Proto.DirectiveCollectRewards.fromObject(object.collectRewards);
                        }
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a StakingMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @static
                     * @param {TW.Harmony.Proto.StakingMessage} message StakingMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StakingMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                        }
                        if (message.createValidatorMessage != null && message.hasOwnProperty("createValidatorMessage")) {
                            object.createValidatorMessage = $root.TW.Harmony.Proto.DirectiveCreateValidator.toObject(message.createValidatorMessage, options);
                            if (options.oneofs)
                                object.stakeMsg = "createValidatorMessage";
                        }
                        if (message.editValidatorMessage != null && message.hasOwnProperty("editValidatorMessage")) {
                            object.editValidatorMessage = $root.TW.Harmony.Proto.DirectiveEditValidator.toObject(message.editValidatorMessage, options);
                            if (options.oneofs)
                                object.stakeMsg = "editValidatorMessage";
                        }
                        if (message.delegateMessage != null && message.hasOwnProperty("delegateMessage")) {
                            object.delegateMessage = $root.TW.Harmony.Proto.DirectiveDelegate.toObject(message.delegateMessage, options);
                            if (options.oneofs)
                                object.stakeMsg = "delegateMessage";
                        }
                        if (message.undelegateMessage != null && message.hasOwnProperty("undelegateMessage")) {
                            object.undelegateMessage = $root.TW.Harmony.Proto.DirectiveUndelegate.toObject(message.undelegateMessage, options);
                            if (options.oneofs)
                                object.stakeMsg = "undelegateMessage";
                        }
                        if (message.collectRewards != null && message.hasOwnProperty("collectRewards")) {
                            object.collectRewards = $root.TW.Harmony.Proto.DirectiveCollectRewards.toObject(message.collectRewards, options);
                            if (options.oneofs)
                                object.stakeMsg = "collectRewards";
                        }
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        return object;
                    };
    
                    /**
                     * Converts this StakingMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.StakingMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StakingMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return StakingMessage;
                })();
    
                Proto.Description = (function() {
    
                    /**
                     * Properties of a Description.
                     * @memberof TW.Harmony.Proto
                     * @interface IDescription
                     * @property {string|null} [name] Description name
                     * @property {string|null} [identity] Description identity
                     * @property {string|null} [website] Description website
                     * @property {string|null} [securityContact] Description securityContact
                     * @property {string|null} [details] Description details
                     */
    
                    /**
                     * Constructs a new Description.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a Description.
                     * @implements IDescription
                     * @constructor
                     * @param {TW.Harmony.Proto.IDescription=} [properties] Properties to set
                     */
                    function Description(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Description name.
                     * @member {string} name
                     * @memberof TW.Harmony.Proto.Description
                     * @instance
                     */
                    Description.prototype.name = "";
    
                    /**
                     * Description identity.
                     * @member {string} identity
                     * @memberof TW.Harmony.Proto.Description
                     * @instance
                     */
                    Description.prototype.identity = "";
    
                    /**
                     * Description website.
                     * @member {string} website
                     * @memberof TW.Harmony.Proto.Description
                     * @instance
                     */
                    Description.prototype.website = "";
    
                    /**
                     * Description securityContact.
                     * @member {string} securityContact
                     * @memberof TW.Harmony.Proto.Description
                     * @instance
                     */
                    Description.prototype.securityContact = "";
    
                    /**
                     * Description details.
                     * @member {string} details
                     * @memberof TW.Harmony.Proto.Description
                     * @instance
                     */
                    Description.prototype.details = "";
    
                    /**
                     * Creates a new Description instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.Description
                     * @static
                     * @param {TW.Harmony.Proto.IDescription=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.Description} Description instance
                     */
                    Description.create = function create(properties) {
                        return new Description(properties);
                    };
    
                    /**
                     * Encodes the specified Description message. Does not implicitly {@link TW.Harmony.Proto.Description.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.Description
                     * @static
                     * @param {TW.Harmony.Proto.IDescription} message Description message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Description.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.identity != null && Object.hasOwnProperty.call(message, "identity"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.identity);
                        if (message.website != null && Object.hasOwnProperty.call(message, "website"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.website);
                        if (message.securityContact != null && Object.hasOwnProperty.call(message, "securityContact"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.securityContact);
                        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.details);
                        return writer;
                    };
    
                    /**
                     * Decodes a Description message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.Description
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.Description} Description
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Description.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.Description();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.identity = reader.string();
                                break;
                            case 3:
                                message.website = reader.string();
                                break;
                            case 4:
                                message.securityContact = reader.string();
                                break;
                            case 5:
                                message.details = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Description message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.Description
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Description.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.identity != null && message.hasOwnProperty("identity"))
                            if (!$util.isString(message.identity))
                                return "identity: string expected";
                        if (message.website != null && message.hasOwnProperty("website"))
                            if (!$util.isString(message.website))
                                return "website: string expected";
                        if (message.securityContact != null && message.hasOwnProperty("securityContact"))
                            if (!$util.isString(message.securityContact))
                                return "securityContact: string expected";
                        if (message.details != null && message.hasOwnProperty("details"))
                            if (!$util.isString(message.details))
                                return "details: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a Description message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.Description
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.Description} Description
                     */
                    Description.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.Description)
                            return object;
                        var message = new $root.TW.Harmony.Proto.Description();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.identity != null)
                            message.identity = String(object.identity);
                        if (object.website != null)
                            message.website = String(object.website);
                        if (object.securityContact != null)
                            message.securityContact = String(object.securityContact);
                        if (object.details != null)
                            message.details = String(object.details);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Description message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.Description
                     * @static
                     * @param {TW.Harmony.Proto.Description} message Description
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Description.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.identity = "";
                            object.website = "";
                            object.securityContact = "";
                            object.details = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.identity != null && message.hasOwnProperty("identity"))
                            object.identity = message.identity;
                        if (message.website != null && message.hasOwnProperty("website"))
                            object.website = message.website;
                        if (message.securityContact != null && message.hasOwnProperty("securityContact"))
                            object.securityContact = message.securityContact;
                        if (message.details != null && message.hasOwnProperty("details"))
                            object.details = message.details;
                        return object;
                    };
    
                    /**
                     * Converts this Description to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.Description
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Description.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Description;
                })();
    
                Proto.Decimal = (function() {
    
                    /**
                     * Properties of a Decimal.
                     * @memberof TW.Harmony.Proto
                     * @interface IDecimal
                     * @property {Uint8Array|null} [value] Decimal value
                     * @property {Uint8Array|null} [precision] Decimal precision
                     */
    
                    /**
                     * Constructs a new Decimal.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a Decimal.
                     * @implements IDecimal
                     * @constructor
                     * @param {TW.Harmony.Proto.IDecimal=} [properties] Properties to set
                     */
                    function Decimal(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Decimal value.
                     * @member {Uint8Array} value
                     * @memberof TW.Harmony.Proto.Decimal
                     * @instance
                     */
                    Decimal.prototype.value = $util.newBuffer([]);
    
                    /**
                     * Decimal precision.
                     * @member {Uint8Array} precision
                     * @memberof TW.Harmony.Proto.Decimal
                     * @instance
                     */
                    Decimal.prototype.precision = $util.newBuffer([]);
    
                    /**
                     * Creates a new Decimal instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.Decimal
                     * @static
                     * @param {TW.Harmony.Proto.IDecimal=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.Decimal} Decimal instance
                     */
                    Decimal.create = function create(properties) {
                        return new Decimal(properties);
                    };
    
                    /**
                     * Encodes the specified Decimal message. Does not implicitly {@link TW.Harmony.Proto.Decimal.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.Decimal
                     * @static
                     * @param {TW.Harmony.Proto.IDecimal} message Decimal message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Decimal.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                        if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.precision);
                        return writer;
                    };
    
                    /**
                     * Decodes a Decimal message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.Decimal
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.Decimal} Decimal
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Decimal.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.Decimal();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.bytes();
                                break;
                            case 2:
                                message.precision = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Decimal message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.Decimal
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Decimal.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.precision != null && message.hasOwnProperty("precision"))
                            if (!(message.precision && typeof message.precision.length === "number" || $util.isString(message.precision)))
                                return "precision: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Decimal message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.Decimal
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.Decimal} Decimal
                     */
                    Decimal.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.Decimal)
                            return object;
                        var message = new $root.TW.Harmony.Proto.Decimal();
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.precision != null)
                            if (typeof object.precision === "string")
                                $util.base64.decode(object.precision, message.precision = $util.newBuffer($util.base64.length(object.precision)), 0);
                            else if (object.precision.length)
                                message.precision = object.precision;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Decimal message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.Decimal
                     * @static
                     * @param {TW.Harmony.Proto.Decimal} message Decimal
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Decimal.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if (options.bytes === String)
                                object.precision = "";
                            else {
                                object.precision = [];
                                if (options.bytes !== Array)
                                    object.precision = $util.newBuffer(object.precision);
                            }
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.precision != null && message.hasOwnProperty("precision"))
                            object.precision = options.bytes === String ? $util.base64.encode(message.precision, 0, message.precision.length) : options.bytes === Array ? Array.prototype.slice.call(message.precision) : message.precision;
                        return object;
                    };
    
                    /**
                     * Converts this Decimal to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.Decimal
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Decimal.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Decimal;
                })();
    
                Proto.CommissionRate = (function() {
    
                    /**
                     * Properties of a CommissionRate.
                     * @memberof TW.Harmony.Proto
                     * @interface ICommissionRate
                     * @property {TW.Harmony.Proto.IDecimal|null} [rate] CommissionRate rate
                     * @property {TW.Harmony.Proto.IDecimal|null} [maxRate] CommissionRate maxRate
                     * @property {TW.Harmony.Proto.IDecimal|null} [maxChangeRate] CommissionRate maxChangeRate
                     */
    
                    /**
                     * Constructs a new CommissionRate.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a CommissionRate.
                     * @implements ICommissionRate
                     * @constructor
                     * @param {TW.Harmony.Proto.ICommissionRate=} [properties] Properties to set
                     */
                    function CommissionRate(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CommissionRate rate.
                     * @member {TW.Harmony.Proto.IDecimal|null|undefined} rate
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @instance
                     */
                    CommissionRate.prototype.rate = null;
    
                    /**
                     * CommissionRate maxRate.
                     * @member {TW.Harmony.Proto.IDecimal|null|undefined} maxRate
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @instance
                     */
                    CommissionRate.prototype.maxRate = null;
    
                    /**
                     * CommissionRate maxChangeRate.
                     * @member {TW.Harmony.Proto.IDecimal|null|undefined} maxChangeRate
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @instance
                     */
                    CommissionRate.prototype.maxChangeRate = null;
    
                    /**
                     * Creates a new CommissionRate instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @static
                     * @param {TW.Harmony.Proto.ICommissionRate=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.CommissionRate} CommissionRate instance
                     */
                    CommissionRate.create = function create(properties) {
                        return new CommissionRate(properties);
                    };
    
                    /**
                     * Encodes the specified CommissionRate message. Does not implicitly {@link TW.Harmony.Proto.CommissionRate.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @static
                     * @param {TW.Harmony.Proto.ICommissionRate} message CommissionRate message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CommissionRate.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.rate != null && Object.hasOwnProperty.call(message, "rate"))
                            $root.TW.Harmony.Proto.Decimal.encode(message.rate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.maxRate != null && Object.hasOwnProperty.call(message, "maxRate"))
                            $root.TW.Harmony.Proto.Decimal.encode(message.maxRate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.maxChangeRate != null && Object.hasOwnProperty.call(message, "maxChangeRate"))
                            $root.TW.Harmony.Proto.Decimal.encode(message.maxChangeRate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a CommissionRate message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.CommissionRate} CommissionRate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CommissionRate.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.CommissionRate();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.rate = $root.TW.Harmony.Proto.Decimal.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.maxRate = $root.TW.Harmony.Proto.Decimal.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.maxChangeRate = $root.TW.Harmony.Proto.Decimal.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a CommissionRate message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CommissionRate.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.rate != null && message.hasOwnProperty("rate")) {
                            var error = $root.TW.Harmony.Proto.Decimal.verify(message.rate);
                            if (error)
                                return "rate." + error;
                        }
                        if (message.maxRate != null && message.hasOwnProperty("maxRate")) {
                            var error = $root.TW.Harmony.Proto.Decimal.verify(message.maxRate);
                            if (error)
                                return "maxRate." + error;
                        }
                        if (message.maxChangeRate != null && message.hasOwnProperty("maxChangeRate")) {
                            var error = $root.TW.Harmony.Proto.Decimal.verify(message.maxChangeRate);
                            if (error)
                                return "maxChangeRate." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a CommissionRate message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.CommissionRate} CommissionRate
                     */
                    CommissionRate.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.CommissionRate)
                            return object;
                        var message = new $root.TW.Harmony.Proto.CommissionRate();
                        if (object.rate != null) {
                            if (typeof object.rate !== "object")
                                throw TypeError(".TW.Harmony.Proto.CommissionRate.rate: object expected");
                            message.rate = $root.TW.Harmony.Proto.Decimal.fromObject(object.rate);
                        }
                        if (object.maxRate != null) {
                            if (typeof object.maxRate !== "object")
                                throw TypeError(".TW.Harmony.Proto.CommissionRate.maxRate: object expected");
                            message.maxRate = $root.TW.Harmony.Proto.Decimal.fromObject(object.maxRate);
                        }
                        if (object.maxChangeRate != null) {
                            if (typeof object.maxChangeRate !== "object")
                                throw TypeError(".TW.Harmony.Proto.CommissionRate.maxChangeRate: object expected");
                            message.maxChangeRate = $root.TW.Harmony.Proto.Decimal.fromObject(object.maxChangeRate);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CommissionRate message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @static
                     * @param {TW.Harmony.Proto.CommissionRate} message CommissionRate
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CommissionRate.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.rate = null;
                            object.maxRate = null;
                            object.maxChangeRate = null;
                        }
                        if (message.rate != null && message.hasOwnProperty("rate"))
                            object.rate = $root.TW.Harmony.Proto.Decimal.toObject(message.rate, options);
                        if (message.maxRate != null && message.hasOwnProperty("maxRate"))
                            object.maxRate = $root.TW.Harmony.Proto.Decimal.toObject(message.maxRate, options);
                        if (message.maxChangeRate != null && message.hasOwnProperty("maxChangeRate"))
                            object.maxChangeRate = $root.TW.Harmony.Proto.Decimal.toObject(message.maxChangeRate, options);
                        return object;
                    };
    
                    /**
                     * Converts this CommissionRate to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.CommissionRate
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CommissionRate.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CommissionRate;
                })();
    
                Proto.DirectiveCreateValidator = (function() {
    
                    /**
                     * Properties of a DirectiveCreateValidator.
                     * @memberof TW.Harmony.Proto
                     * @interface IDirectiveCreateValidator
                     * @property {string|null} [validatorAddress] DirectiveCreateValidator validatorAddress
                     * @property {TW.Harmony.Proto.IDescription|null} [description] DirectiveCreateValidator description
                     * @property {TW.Harmony.Proto.ICommissionRate|null} [commissionRates] DirectiveCreateValidator commissionRates
                     * @property {Uint8Array|null} [minSelfDelegation] DirectiveCreateValidator minSelfDelegation
                     * @property {Uint8Array|null} [maxTotalDelegation] DirectiveCreateValidator maxTotalDelegation
                     * @property {Array.<Uint8Array>|null} [slotPubKeys] DirectiveCreateValidator slotPubKeys
                     * @property {Array.<Uint8Array>|null} [slotKeySigs] DirectiveCreateValidator slotKeySigs
                     * @property {Uint8Array|null} [amount] DirectiveCreateValidator amount
                     */
    
                    /**
                     * Constructs a new DirectiveCreateValidator.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a DirectiveCreateValidator.
                     * @implements IDirectiveCreateValidator
                     * @constructor
                     * @param {TW.Harmony.Proto.IDirectiveCreateValidator=} [properties] Properties to set
                     */
                    function DirectiveCreateValidator(properties) {
                        this.slotPubKeys = [];
                        this.slotKeySigs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DirectiveCreateValidator validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.validatorAddress = "";
    
                    /**
                     * DirectiveCreateValidator description.
                     * @member {TW.Harmony.Proto.IDescription|null|undefined} description
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.description = null;
    
                    /**
                     * DirectiveCreateValidator commissionRates.
                     * @member {TW.Harmony.Proto.ICommissionRate|null|undefined} commissionRates
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.commissionRates = null;
    
                    /**
                     * DirectiveCreateValidator minSelfDelegation.
                     * @member {Uint8Array} minSelfDelegation
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.minSelfDelegation = $util.newBuffer([]);
    
                    /**
                     * DirectiveCreateValidator maxTotalDelegation.
                     * @member {Uint8Array} maxTotalDelegation
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.maxTotalDelegation = $util.newBuffer([]);
    
                    /**
                     * DirectiveCreateValidator slotPubKeys.
                     * @member {Array.<Uint8Array>} slotPubKeys
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.slotPubKeys = $util.emptyArray;
    
                    /**
                     * DirectiveCreateValidator slotKeySigs.
                     * @member {Array.<Uint8Array>} slotKeySigs
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.slotKeySigs = $util.emptyArray;
    
                    /**
                     * DirectiveCreateValidator amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     */
                    DirectiveCreateValidator.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * Creates a new DirectiveCreateValidator instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveCreateValidator=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.DirectiveCreateValidator} DirectiveCreateValidator instance
                     */
                    DirectiveCreateValidator.create = function create(properties) {
                        return new DirectiveCreateValidator(properties);
                    };
    
                    /**
                     * Encodes the specified DirectiveCreateValidator message. Does not implicitly {@link TW.Harmony.Proto.DirectiveCreateValidator.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveCreateValidator} message DirectiveCreateValidator message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DirectiveCreateValidator.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.validatorAddress);
                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                            $root.TW.Harmony.Proto.Description.encode(message.description, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.commissionRates != null && Object.hasOwnProperty.call(message, "commissionRates"))
                            $root.TW.Harmony.Proto.CommissionRate.encode(message.commissionRates, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.minSelfDelegation != null && Object.hasOwnProperty.call(message, "minSelfDelegation"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.minSelfDelegation);
                        if (message.maxTotalDelegation != null && Object.hasOwnProperty.call(message, "maxTotalDelegation"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.maxTotalDelegation);
                        if (message.slotPubKeys != null && message.slotPubKeys.length)
                            for (var i = 0; i < message.slotPubKeys.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.slotPubKeys[i]);
                        if (message.slotKeySigs != null && message.slotKeySigs.length)
                            for (var i = 0; i < message.slotKeySigs.length; ++i)
                                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.slotKeySigs[i]);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a DirectiveCreateValidator message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.DirectiveCreateValidator} DirectiveCreateValidator
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DirectiveCreateValidator.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.DirectiveCreateValidator();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.validatorAddress = reader.string();
                                break;
                            case 2:
                                message.description = $root.TW.Harmony.Proto.Description.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.commissionRates = $root.TW.Harmony.Proto.CommissionRate.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.minSelfDelegation = reader.bytes();
                                break;
                            case 5:
                                message.maxTotalDelegation = reader.bytes();
                                break;
                            case 6:
                                if (!(message.slotPubKeys && message.slotPubKeys.length))
                                    message.slotPubKeys = [];
                                message.slotPubKeys.push(reader.bytes());
                                break;
                            case 7:
                                if (!(message.slotKeySigs && message.slotKeySigs.length))
                                    message.slotKeySigs = [];
                                message.slotKeySigs.push(reader.bytes());
                                break;
                            case 8:
                                message.amount = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DirectiveCreateValidator message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DirectiveCreateValidator.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.description != null && message.hasOwnProperty("description")) {
                            var error = $root.TW.Harmony.Proto.Description.verify(message.description);
                            if (error)
                                return "description." + error;
                        }
                        if (message.commissionRates != null && message.hasOwnProperty("commissionRates")) {
                            var error = $root.TW.Harmony.Proto.CommissionRate.verify(message.commissionRates);
                            if (error)
                                return "commissionRates." + error;
                        }
                        if (message.minSelfDelegation != null && message.hasOwnProperty("minSelfDelegation"))
                            if (!(message.minSelfDelegation && typeof message.minSelfDelegation.length === "number" || $util.isString(message.minSelfDelegation)))
                                return "minSelfDelegation: buffer expected";
                        if (message.maxTotalDelegation != null && message.hasOwnProperty("maxTotalDelegation"))
                            if (!(message.maxTotalDelegation && typeof message.maxTotalDelegation.length === "number" || $util.isString(message.maxTotalDelegation)))
                                return "maxTotalDelegation: buffer expected";
                        if (message.slotPubKeys != null && message.hasOwnProperty("slotPubKeys")) {
                            if (!Array.isArray(message.slotPubKeys))
                                return "slotPubKeys: array expected";
                            for (var i = 0; i < message.slotPubKeys.length; ++i)
                                if (!(message.slotPubKeys[i] && typeof message.slotPubKeys[i].length === "number" || $util.isString(message.slotPubKeys[i])))
                                    return "slotPubKeys: buffer[] expected";
                        }
                        if (message.slotKeySigs != null && message.hasOwnProperty("slotKeySigs")) {
                            if (!Array.isArray(message.slotKeySigs))
                                return "slotKeySigs: array expected";
                            for (var i = 0; i < message.slotKeySigs.length; ++i)
                                if (!(message.slotKeySigs[i] && typeof message.slotKeySigs[i].length === "number" || $util.isString(message.slotKeySigs[i])))
                                    return "slotKeySigs: buffer[] expected";
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a DirectiveCreateValidator message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.DirectiveCreateValidator} DirectiveCreateValidator
                     */
                    DirectiveCreateValidator.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.DirectiveCreateValidator)
                            return object;
                        var message = new $root.TW.Harmony.Proto.DirectiveCreateValidator();
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.description != null) {
                            if (typeof object.description !== "object")
                                throw TypeError(".TW.Harmony.Proto.DirectiveCreateValidator.description: object expected");
                            message.description = $root.TW.Harmony.Proto.Description.fromObject(object.description);
                        }
                        if (object.commissionRates != null) {
                            if (typeof object.commissionRates !== "object")
                                throw TypeError(".TW.Harmony.Proto.DirectiveCreateValidator.commissionRates: object expected");
                            message.commissionRates = $root.TW.Harmony.Proto.CommissionRate.fromObject(object.commissionRates);
                        }
                        if (object.minSelfDelegation != null)
                            if (typeof object.minSelfDelegation === "string")
                                $util.base64.decode(object.minSelfDelegation, message.minSelfDelegation = $util.newBuffer($util.base64.length(object.minSelfDelegation)), 0);
                            else if (object.minSelfDelegation.length)
                                message.minSelfDelegation = object.minSelfDelegation;
                        if (object.maxTotalDelegation != null)
                            if (typeof object.maxTotalDelegation === "string")
                                $util.base64.decode(object.maxTotalDelegation, message.maxTotalDelegation = $util.newBuffer($util.base64.length(object.maxTotalDelegation)), 0);
                            else if (object.maxTotalDelegation.length)
                                message.maxTotalDelegation = object.maxTotalDelegation;
                        if (object.slotPubKeys) {
                            if (!Array.isArray(object.slotPubKeys))
                                throw TypeError(".TW.Harmony.Proto.DirectiveCreateValidator.slotPubKeys: array expected");
                            message.slotPubKeys = [];
                            for (var i = 0; i < object.slotPubKeys.length; ++i)
                                if (typeof object.slotPubKeys[i] === "string")
                                    $util.base64.decode(object.slotPubKeys[i], message.slotPubKeys[i] = $util.newBuffer($util.base64.length(object.slotPubKeys[i])), 0);
                                else if (object.slotPubKeys[i].length)
                                    message.slotPubKeys[i] = object.slotPubKeys[i];
                        }
                        if (object.slotKeySigs) {
                            if (!Array.isArray(object.slotKeySigs))
                                throw TypeError(".TW.Harmony.Proto.DirectiveCreateValidator.slotKeySigs: array expected");
                            message.slotKeySigs = [];
                            for (var i = 0; i < object.slotKeySigs.length; ++i)
                                if (typeof object.slotKeySigs[i] === "string")
                                    $util.base64.decode(object.slotKeySigs[i], message.slotKeySigs[i] = $util.newBuffer($util.base64.length(object.slotKeySigs[i])), 0);
                                else if (object.slotKeySigs[i].length)
                                    message.slotKeySigs[i] = object.slotKeySigs[i];
                        }
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DirectiveCreateValidator message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @static
                     * @param {TW.Harmony.Proto.DirectiveCreateValidator} message DirectiveCreateValidator
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DirectiveCreateValidator.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.slotPubKeys = [];
                            object.slotKeySigs = [];
                        }
                        if (options.defaults) {
                            object.validatorAddress = "";
                            object.description = null;
                            object.commissionRates = null;
                            if (options.bytes === String)
                                object.minSelfDelegation = "";
                            else {
                                object.minSelfDelegation = [];
                                if (options.bytes !== Array)
                                    object.minSelfDelegation = $util.newBuffer(object.minSelfDelegation);
                            }
                            if (options.bytes === String)
                                object.maxTotalDelegation = "";
                            else {
                                object.maxTotalDelegation = [];
                                if (options.bytes !== Array)
                                    object.maxTotalDelegation = $util.newBuffer(object.maxTotalDelegation);
                            }
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                        }
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = $root.TW.Harmony.Proto.Description.toObject(message.description, options);
                        if (message.commissionRates != null && message.hasOwnProperty("commissionRates"))
                            object.commissionRates = $root.TW.Harmony.Proto.CommissionRate.toObject(message.commissionRates, options);
                        if (message.minSelfDelegation != null && message.hasOwnProperty("minSelfDelegation"))
                            object.minSelfDelegation = options.bytes === String ? $util.base64.encode(message.minSelfDelegation, 0, message.minSelfDelegation.length) : options.bytes === Array ? Array.prototype.slice.call(message.minSelfDelegation) : message.minSelfDelegation;
                        if (message.maxTotalDelegation != null && message.hasOwnProperty("maxTotalDelegation"))
                            object.maxTotalDelegation = options.bytes === String ? $util.base64.encode(message.maxTotalDelegation, 0, message.maxTotalDelegation.length) : options.bytes === Array ? Array.prototype.slice.call(message.maxTotalDelegation) : message.maxTotalDelegation;
                        if (message.slotPubKeys && message.slotPubKeys.length) {
                            object.slotPubKeys = [];
                            for (var j = 0; j < message.slotPubKeys.length; ++j)
                                object.slotPubKeys[j] = options.bytes === String ? $util.base64.encode(message.slotPubKeys[j], 0, message.slotPubKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.slotPubKeys[j]) : message.slotPubKeys[j];
                        }
                        if (message.slotKeySigs && message.slotKeySigs.length) {
                            object.slotKeySigs = [];
                            for (var j = 0; j < message.slotKeySigs.length; ++j)
                                object.slotKeySigs[j] = options.bytes === String ? $util.base64.encode(message.slotKeySigs[j], 0, message.slotKeySigs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.slotKeySigs[j]) : message.slotKeySigs[j];
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this DirectiveCreateValidator to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.DirectiveCreateValidator
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DirectiveCreateValidator.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DirectiveCreateValidator;
                })();
    
                Proto.DirectiveEditValidator = (function() {
    
                    /**
                     * Properties of a DirectiveEditValidator.
                     * @memberof TW.Harmony.Proto
                     * @interface IDirectiveEditValidator
                     * @property {string|null} [validatorAddress] DirectiveEditValidator validatorAddress
                     * @property {TW.Harmony.Proto.IDescription|null} [description] DirectiveEditValidator description
                     * @property {TW.Harmony.Proto.IDecimal|null} [commissionRate] DirectiveEditValidator commissionRate
                     * @property {Uint8Array|null} [minSelfDelegation] DirectiveEditValidator minSelfDelegation
                     * @property {Uint8Array|null} [maxTotalDelegation] DirectiveEditValidator maxTotalDelegation
                     * @property {Uint8Array|null} [slotKeyToRemove] DirectiveEditValidator slotKeyToRemove
                     * @property {Uint8Array|null} [slotKeyToAdd] DirectiveEditValidator slotKeyToAdd
                     * @property {Uint8Array|null} [slotKeyToAddSig] DirectiveEditValidator slotKeyToAddSig
                     * @property {Uint8Array|null} [active] DirectiveEditValidator active
                     */
    
                    /**
                     * Constructs a new DirectiveEditValidator.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a DirectiveEditValidator.
                     * @implements IDirectiveEditValidator
                     * @constructor
                     * @param {TW.Harmony.Proto.IDirectiveEditValidator=} [properties] Properties to set
                     */
                    function DirectiveEditValidator(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DirectiveEditValidator validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.validatorAddress = "";
    
                    /**
                     * DirectiveEditValidator description.
                     * @member {TW.Harmony.Proto.IDescription|null|undefined} description
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.description = null;
    
                    /**
                     * DirectiveEditValidator commissionRate.
                     * @member {TW.Harmony.Proto.IDecimal|null|undefined} commissionRate
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.commissionRate = null;
    
                    /**
                     * DirectiveEditValidator minSelfDelegation.
                     * @member {Uint8Array} minSelfDelegation
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.minSelfDelegation = $util.newBuffer([]);
    
                    /**
                     * DirectiveEditValidator maxTotalDelegation.
                     * @member {Uint8Array} maxTotalDelegation
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.maxTotalDelegation = $util.newBuffer([]);
    
                    /**
                     * DirectiveEditValidator slotKeyToRemove.
                     * @member {Uint8Array} slotKeyToRemove
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.slotKeyToRemove = $util.newBuffer([]);
    
                    /**
                     * DirectiveEditValidator slotKeyToAdd.
                     * @member {Uint8Array} slotKeyToAdd
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.slotKeyToAdd = $util.newBuffer([]);
    
                    /**
                     * DirectiveEditValidator slotKeyToAddSig.
                     * @member {Uint8Array} slotKeyToAddSig
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.slotKeyToAddSig = $util.newBuffer([]);
    
                    /**
                     * DirectiveEditValidator active.
                     * @member {Uint8Array} active
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     */
                    DirectiveEditValidator.prototype.active = $util.newBuffer([]);
    
                    /**
                     * Creates a new DirectiveEditValidator instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveEditValidator=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.DirectiveEditValidator} DirectiveEditValidator instance
                     */
                    DirectiveEditValidator.create = function create(properties) {
                        return new DirectiveEditValidator(properties);
                    };
    
                    /**
                     * Encodes the specified DirectiveEditValidator message. Does not implicitly {@link TW.Harmony.Proto.DirectiveEditValidator.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveEditValidator} message DirectiveEditValidator message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DirectiveEditValidator.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.validatorAddress);
                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                            $root.TW.Harmony.Proto.Description.encode(message.description, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.commissionRate != null && Object.hasOwnProperty.call(message, "commissionRate"))
                            $root.TW.Harmony.Proto.Decimal.encode(message.commissionRate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.minSelfDelegation != null && Object.hasOwnProperty.call(message, "minSelfDelegation"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.minSelfDelegation);
                        if (message.maxTotalDelegation != null && Object.hasOwnProperty.call(message, "maxTotalDelegation"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.maxTotalDelegation);
                        if (message.slotKeyToRemove != null && Object.hasOwnProperty.call(message, "slotKeyToRemove"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.slotKeyToRemove);
                        if (message.slotKeyToAdd != null && Object.hasOwnProperty.call(message, "slotKeyToAdd"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.slotKeyToAdd);
                        if (message.slotKeyToAddSig != null && Object.hasOwnProperty.call(message, "slotKeyToAddSig"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.slotKeyToAddSig);
                        if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.active);
                        return writer;
                    };
    
                    /**
                     * Decodes a DirectiveEditValidator message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.DirectiveEditValidator} DirectiveEditValidator
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DirectiveEditValidator.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.DirectiveEditValidator();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.validatorAddress = reader.string();
                                break;
                            case 2:
                                message.description = $root.TW.Harmony.Proto.Description.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.commissionRate = $root.TW.Harmony.Proto.Decimal.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.minSelfDelegation = reader.bytes();
                                break;
                            case 5:
                                message.maxTotalDelegation = reader.bytes();
                                break;
                            case 6:
                                message.slotKeyToRemove = reader.bytes();
                                break;
                            case 7:
                                message.slotKeyToAdd = reader.bytes();
                                break;
                            case 8:
                                message.slotKeyToAddSig = reader.bytes();
                                break;
                            case 9:
                                message.active = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DirectiveEditValidator message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DirectiveEditValidator.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.description != null && message.hasOwnProperty("description")) {
                            var error = $root.TW.Harmony.Proto.Description.verify(message.description);
                            if (error)
                                return "description." + error;
                        }
                        if (message.commissionRate != null && message.hasOwnProperty("commissionRate")) {
                            var error = $root.TW.Harmony.Proto.Decimal.verify(message.commissionRate);
                            if (error)
                                return "commissionRate." + error;
                        }
                        if (message.minSelfDelegation != null && message.hasOwnProperty("minSelfDelegation"))
                            if (!(message.minSelfDelegation && typeof message.minSelfDelegation.length === "number" || $util.isString(message.minSelfDelegation)))
                                return "minSelfDelegation: buffer expected";
                        if (message.maxTotalDelegation != null && message.hasOwnProperty("maxTotalDelegation"))
                            if (!(message.maxTotalDelegation && typeof message.maxTotalDelegation.length === "number" || $util.isString(message.maxTotalDelegation)))
                                return "maxTotalDelegation: buffer expected";
                        if (message.slotKeyToRemove != null && message.hasOwnProperty("slotKeyToRemove"))
                            if (!(message.slotKeyToRemove && typeof message.slotKeyToRemove.length === "number" || $util.isString(message.slotKeyToRemove)))
                                return "slotKeyToRemove: buffer expected";
                        if (message.slotKeyToAdd != null && message.hasOwnProperty("slotKeyToAdd"))
                            if (!(message.slotKeyToAdd && typeof message.slotKeyToAdd.length === "number" || $util.isString(message.slotKeyToAdd)))
                                return "slotKeyToAdd: buffer expected";
                        if (message.slotKeyToAddSig != null && message.hasOwnProperty("slotKeyToAddSig"))
                            if (!(message.slotKeyToAddSig && typeof message.slotKeyToAddSig.length === "number" || $util.isString(message.slotKeyToAddSig)))
                                return "slotKeyToAddSig: buffer expected";
                        if (message.active != null && message.hasOwnProperty("active"))
                            if (!(message.active && typeof message.active.length === "number" || $util.isString(message.active)))
                                return "active: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a DirectiveEditValidator message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.DirectiveEditValidator} DirectiveEditValidator
                     */
                    DirectiveEditValidator.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.DirectiveEditValidator)
                            return object;
                        var message = new $root.TW.Harmony.Proto.DirectiveEditValidator();
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.description != null) {
                            if (typeof object.description !== "object")
                                throw TypeError(".TW.Harmony.Proto.DirectiveEditValidator.description: object expected");
                            message.description = $root.TW.Harmony.Proto.Description.fromObject(object.description);
                        }
                        if (object.commissionRate != null) {
                            if (typeof object.commissionRate !== "object")
                                throw TypeError(".TW.Harmony.Proto.DirectiveEditValidator.commissionRate: object expected");
                            message.commissionRate = $root.TW.Harmony.Proto.Decimal.fromObject(object.commissionRate);
                        }
                        if (object.minSelfDelegation != null)
                            if (typeof object.minSelfDelegation === "string")
                                $util.base64.decode(object.minSelfDelegation, message.minSelfDelegation = $util.newBuffer($util.base64.length(object.minSelfDelegation)), 0);
                            else if (object.minSelfDelegation.length)
                                message.minSelfDelegation = object.minSelfDelegation;
                        if (object.maxTotalDelegation != null)
                            if (typeof object.maxTotalDelegation === "string")
                                $util.base64.decode(object.maxTotalDelegation, message.maxTotalDelegation = $util.newBuffer($util.base64.length(object.maxTotalDelegation)), 0);
                            else if (object.maxTotalDelegation.length)
                                message.maxTotalDelegation = object.maxTotalDelegation;
                        if (object.slotKeyToRemove != null)
                            if (typeof object.slotKeyToRemove === "string")
                                $util.base64.decode(object.slotKeyToRemove, message.slotKeyToRemove = $util.newBuffer($util.base64.length(object.slotKeyToRemove)), 0);
                            else if (object.slotKeyToRemove.length)
                                message.slotKeyToRemove = object.slotKeyToRemove;
                        if (object.slotKeyToAdd != null)
                            if (typeof object.slotKeyToAdd === "string")
                                $util.base64.decode(object.slotKeyToAdd, message.slotKeyToAdd = $util.newBuffer($util.base64.length(object.slotKeyToAdd)), 0);
                            else if (object.slotKeyToAdd.length)
                                message.slotKeyToAdd = object.slotKeyToAdd;
                        if (object.slotKeyToAddSig != null)
                            if (typeof object.slotKeyToAddSig === "string")
                                $util.base64.decode(object.slotKeyToAddSig, message.slotKeyToAddSig = $util.newBuffer($util.base64.length(object.slotKeyToAddSig)), 0);
                            else if (object.slotKeyToAddSig.length)
                                message.slotKeyToAddSig = object.slotKeyToAddSig;
                        if (object.active != null)
                            if (typeof object.active === "string")
                                $util.base64.decode(object.active, message.active = $util.newBuffer($util.base64.length(object.active)), 0);
                            else if (object.active.length)
                                message.active = object.active;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DirectiveEditValidator message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @static
                     * @param {TW.Harmony.Proto.DirectiveEditValidator} message DirectiveEditValidator
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DirectiveEditValidator.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.validatorAddress = "";
                            object.description = null;
                            object.commissionRate = null;
                            if (options.bytes === String)
                                object.minSelfDelegation = "";
                            else {
                                object.minSelfDelegation = [];
                                if (options.bytes !== Array)
                                    object.minSelfDelegation = $util.newBuffer(object.minSelfDelegation);
                            }
                            if (options.bytes === String)
                                object.maxTotalDelegation = "";
                            else {
                                object.maxTotalDelegation = [];
                                if (options.bytes !== Array)
                                    object.maxTotalDelegation = $util.newBuffer(object.maxTotalDelegation);
                            }
                            if (options.bytes === String)
                                object.slotKeyToRemove = "";
                            else {
                                object.slotKeyToRemove = [];
                                if (options.bytes !== Array)
                                    object.slotKeyToRemove = $util.newBuffer(object.slotKeyToRemove);
                            }
                            if (options.bytes === String)
                                object.slotKeyToAdd = "";
                            else {
                                object.slotKeyToAdd = [];
                                if (options.bytes !== Array)
                                    object.slotKeyToAdd = $util.newBuffer(object.slotKeyToAdd);
                            }
                            if (options.bytes === String)
                                object.slotKeyToAddSig = "";
                            else {
                                object.slotKeyToAddSig = [];
                                if (options.bytes !== Array)
                                    object.slotKeyToAddSig = $util.newBuffer(object.slotKeyToAddSig);
                            }
                            if (options.bytes === String)
                                object.active = "";
                            else {
                                object.active = [];
                                if (options.bytes !== Array)
                                    object.active = $util.newBuffer(object.active);
                            }
                        }
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = $root.TW.Harmony.Proto.Description.toObject(message.description, options);
                        if (message.commissionRate != null && message.hasOwnProperty("commissionRate"))
                            object.commissionRate = $root.TW.Harmony.Proto.Decimal.toObject(message.commissionRate, options);
                        if (message.minSelfDelegation != null && message.hasOwnProperty("minSelfDelegation"))
                            object.minSelfDelegation = options.bytes === String ? $util.base64.encode(message.minSelfDelegation, 0, message.minSelfDelegation.length) : options.bytes === Array ? Array.prototype.slice.call(message.minSelfDelegation) : message.minSelfDelegation;
                        if (message.maxTotalDelegation != null && message.hasOwnProperty("maxTotalDelegation"))
                            object.maxTotalDelegation = options.bytes === String ? $util.base64.encode(message.maxTotalDelegation, 0, message.maxTotalDelegation.length) : options.bytes === Array ? Array.prototype.slice.call(message.maxTotalDelegation) : message.maxTotalDelegation;
                        if (message.slotKeyToRemove != null && message.hasOwnProperty("slotKeyToRemove"))
                            object.slotKeyToRemove = options.bytes === String ? $util.base64.encode(message.slotKeyToRemove, 0, message.slotKeyToRemove.length) : options.bytes === Array ? Array.prototype.slice.call(message.slotKeyToRemove) : message.slotKeyToRemove;
                        if (message.slotKeyToAdd != null && message.hasOwnProperty("slotKeyToAdd"))
                            object.slotKeyToAdd = options.bytes === String ? $util.base64.encode(message.slotKeyToAdd, 0, message.slotKeyToAdd.length) : options.bytes === Array ? Array.prototype.slice.call(message.slotKeyToAdd) : message.slotKeyToAdd;
                        if (message.slotKeyToAddSig != null && message.hasOwnProperty("slotKeyToAddSig"))
                            object.slotKeyToAddSig = options.bytes === String ? $util.base64.encode(message.slotKeyToAddSig, 0, message.slotKeyToAddSig.length) : options.bytes === Array ? Array.prototype.slice.call(message.slotKeyToAddSig) : message.slotKeyToAddSig;
                        if (message.active != null && message.hasOwnProperty("active"))
                            object.active = options.bytes === String ? $util.base64.encode(message.active, 0, message.active.length) : options.bytes === Array ? Array.prototype.slice.call(message.active) : message.active;
                        return object;
                    };
    
                    /**
                     * Converts this DirectiveEditValidator to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.DirectiveEditValidator
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DirectiveEditValidator.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DirectiveEditValidator;
                })();
    
                Proto.DirectiveDelegate = (function() {
    
                    /**
                     * Properties of a DirectiveDelegate.
                     * @memberof TW.Harmony.Proto
                     * @interface IDirectiveDelegate
                     * @property {string|null} [delegatorAddress] DirectiveDelegate delegatorAddress
                     * @property {string|null} [validatorAddress] DirectiveDelegate validatorAddress
                     * @property {Uint8Array|null} [amount] DirectiveDelegate amount
                     */
    
                    /**
                     * Constructs a new DirectiveDelegate.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a DirectiveDelegate.
                     * @implements IDirectiveDelegate
                     * @constructor
                     * @param {TW.Harmony.Proto.IDirectiveDelegate=} [properties] Properties to set
                     */
                    function DirectiveDelegate(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DirectiveDelegate delegatorAddress.
                     * @member {string} delegatorAddress
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @instance
                     */
                    DirectiveDelegate.prototype.delegatorAddress = "";
    
                    /**
                     * DirectiveDelegate validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @instance
                     */
                    DirectiveDelegate.prototype.validatorAddress = "";
    
                    /**
                     * DirectiveDelegate amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @instance
                     */
                    DirectiveDelegate.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * Creates a new DirectiveDelegate instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveDelegate=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.DirectiveDelegate} DirectiveDelegate instance
                     */
                    DirectiveDelegate.create = function create(properties) {
                        return new DirectiveDelegate(properties);
                    };
    
                    /**
                     * Encodes the specified DirectiveDelegate message. Does not implicitly {@link TW.Harmony.Proto.DirectiveDelegate.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveDelegate} message DirectiveDelegate message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DirectiveDelegate.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddress != null && Object.hasOwnProperty.call(message, "delegatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                        if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a DirectiveDelegate message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.DirectiveDelegate} DirectiveDelegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DirectiveDelegate.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.DirectiveDelegate();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddress = reader.string();
                                break;
                            case 2:
                                message.validatorAddress = reader.string();
                                break;
                            case 3:
                                message.amount = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DirectiveDelegate message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DirectiveDelegate.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            if (!$util.isString(message.delegatorAddress))
                                return "delegatorAddress: string expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a DirectiveDelegate message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.DirectiveDelegate} DirectiveDelegate
                     */
                    DirectiveDelegate.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.DirectiveDelegate)
                            return object;
                        var message = new $root.TW.Harmony.Proto.DirectiveDelegate();
                        if (object.delegatorAddress != null)
                            message.delegatorAddress = String(object.delegatorAddress);
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DirectiveDelegate message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @static
                     * @param {TW.Harmony.Proto.DirectiveDelegate} message DirectiveDelegate
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DirectiveDelegate.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.delegatorAddress = "";
                            object.validatorAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                        }
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            object.delegatorAddress = message.delegatorAddress;
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this DirectiveDelegate to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.DirectiveDelegate
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DirectiveDelegate.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DirectiveDelegate;
                })();
    
                Proto.DirectiveUndelegate = (function() {
    
                    /**
                     * Properties of a DirectiveUndelegate.
                     * @memberof TW.Harmony.Proto
                     * @interface IDirectiveUndelegate
                     * @property {string|null} [delegatorAddress] DirectiveUndelegate delegatorAddress
                     * @property {string|null} [validatorAddress] DirectiveUndelegate validatorAddress
                     * @property {Uint8Array|null} [amount] DirectiveUndelegate amount
                     */
    
                    /**
                     * Constructs a new DirectiveUndelegate.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a DirectiveUndelegate.
                     * @implements IDirectiveUndelegate
                     * @constructor
                     * @param {TW.Harmony.Proto.IDirectiveUndelegate=} [properties] Properties to set
                     */
                    function DirectiveUndelegate(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DirectiveUndelegate delegatorAddress.
                     * @member {string} delegatorAddress
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @instance
                     */
                    DirectiveUndelegate.prototype.delegatorAddress = "";
    
                    /**
                     * DirectiveUndelegate validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @instance
                     */
                    DirectiveUndelegate.prototype.validatorAddress = "";
    
                    /**
                     * DirectiveUndelegate amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @instance
                     */
                    DirectiveUndelegate.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * Creates a new DirectiveUndelegate instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveUndelegate=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.DirectiveUndelegate} DirectiveUndelegate instance
                     */
                    DirectiveUndelegate.create = function create(properties) {
                        return new DirectiveUndelegate(properties);
                    };
    
                    /**
                     * Encodes the specified DirectiveUndelegate message. Does not implicitly {@link TW.Harmony.Proto.DirectiveUndelegate.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveUndelegate} message DirectiveUndelegate message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DirectiveUndelegate.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddress != null && Object.hasOwnProperty.call(message, "delegatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                        if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a DirectiveUndelegate message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.DirectiveUndelegate} DirectiveUndelegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DirectiveUndelegate.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.DirectiveUndelegate();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddress = reader.string();
                                break;
                            case 2:
                                message.validatorAddress = reader.string();
                                break;
                            case 3:
                                message.amount = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DirectiveUndelegate message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DirectiveUndelegate.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            if (!$util.isString(message.delegatorAddress))
                                return "delegatorAddress: string expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a DirectiveUndelegate message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.DirectiveUndelegate} DirectiveUndelegate
                     */
                    DirectiveUndelegate.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.DirectiveUndelegate)
                            return object;
                        var message = new $root.TW.Harmony.Proto.DirectiveUndelegate();
                        if (object.delegatorAddress != null)
                            message.delegatorAddress = String(object.delegatorAddress);
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DirectiveUndelegate message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @static
                     * @param {TW.Harmony.Proto.DirectiveUndelegate} message DirectiveUndelegate
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DirectiveUndelegate.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.delegatorAddress = "";
                            object.validatorAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                        }
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            object.delegatorAddress = message.delegatorAddress;
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this DirectiveUndelegate to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.DirectiveUndelegate
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DirectiveUndelegate.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DirectiveUndelegate;
                })();
    
                Proto.DirectiveCollectRewards = (function() {
    
                    /**
                     * Properties of a DirectiveCollectRewards.
                     * @memberof TW.Harmony.Proto
                     * @interface IDirectiveCollectRewards
                     * @property {string|null} [delegatorAddress] DirectiveCollectRewards delegatorAddress
                     */
    
                    /**
                     * Constructs a new DirectiveCollectRewards.
                     * @memberof TW.Harmony.Proto
                     * @classdesc Represents a DirectiveCollectRewards.
                     * @implements IDirectiveCollectRewards
                     * @constructor
                     * @param {TW.Harmony.Proto.IDirectiveCollectRewards=} [properties] Properties to set
                     */
                    function DirectiveCollectRewards(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DirectiveCollectRewards delegatorAddress.
                     * @member {string} delegatorAddress
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @instance
                     */
                    DirectiveCollectRewards.prototype.delegatorAddress = "";
    
                    /**
                     * Creates a new DirectiveCollectRewards instance using the specified properties.
                     * @function create
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveCollectRewards=} [properties] Properties to set
                     * @returns {TW.Harmony.Proto.DirectiveCollectRewards} DirectiveCollectRewards instance
                     */
                    DirectiveCollectRewards.create = function create(properties) {
                        return new DirectiveCollectRewards(properties);
                    };
    
                    /**
                     * Encodes the specified DirectiveCollectRewards message. Does not implicitly {@link TW.Harmony.Proto.DirectiveCollectRewards.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @static
                     * @param {TW.Harmony.Proto.IDirectiveCollectRewards} message DirectiveCollectRewards message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DirectiveCollectRewards.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddress != null && Object.hasOwnProperty.call(message, "delegatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes a DirectiveCollectRewards message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Harmony.Proto.DirectiveCollectRewards} DirectiveCollectRewards
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DirectiveCollectRewards.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Harmony.Proto.DirectiveCollectRewards();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DirectiveCollectRewards message.
                     * @function verify
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DirectiveCollectRewards.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            if (!$util.isString(message.delegatorAddress))
                                return "delegatorAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DirectiveCollectRewards message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Harmony.Proto.DirectiveCollectRewards} DirectiveCollectRewards
                     */
                    DirectiveCollectRewards.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Harmony.Proto.DirectiveCollectRewards)
                            return object;
                        var message = new $root.TW.Harmony.Proto.DirectiveCollectRewards();
                        if (object.delegatorAddress != null)
                            message.delegatorAddress = String(object.delegatorAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DirectiveCollectRewards message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @static
                     * @param {TW.Harmony.Proto.DirectiveCollectRewards} message DirectiveCollectRewards
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DirectiveCollectRewards.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.delegatorAddress = "";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            object.delegatorAddress = message.delegatorAddress;
                        return object;
                    };
    
                    /**
                     * Converts this DirectiveCollectRewards to JSON.
                     * @function toJSON
                     * @memberof TW.Harmony.Proto.DirectiveCollectRewards
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DirectiveCollectRewards.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DirectiveCollectRewards;
                })();
    
                return Proto;
            })();
    
            return Harmony;
        })();
    
        TW.Icon = (function() {
    
            /**
             * Namespace Icon.
             * @memberof TW
             * @namespace
             */
            var Icon = {};
    
            Icon.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Icon
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Icon.Proto
                     * @interface ISigningInput
                     * @property {string|null} [fromAddress] SigningInput fromAddress
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [value] SigningInput value
                     * @property {Uint8Array|null} [stepLimit] SigningInput stepLimit
                     * @property {Long|null} [timestamp] SigningInput timestamp
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [networkId] SigningInput networkId
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Icon.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Icon.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fromAddress = "";
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput value.
                     * @member {Uint8Array} value
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.value = $util.newBuffer([]);
    
                    /**
                     * SigningInput stepLimit.
                     * @member {Uint8Array} stepLimit
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stepLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput networkId.
                     * @member {Uint8Array} networkId
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.networkId = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {TW.Icon.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Icon.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Icon.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {TW.Icon.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                        if (message.stepLimit != null && Object.hasOwnProperty.call(message, "stepLimit"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.stepLimit);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.nonce);
                        if (message.networkId != null && Object.hasOwnProperty.call(message, "networkId"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.networkId);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Icon.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Icon.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.value = reader.bytes();
                                break;
                            case 4:
                                message.stepLimit = reader.bytes();
                                break;
                            case 5:
                                message.timestamp = reader.int64();
                                break;
                            case 6:
                                message.nonce = reader.bytes();
                                break;
                            case 7:
                                message.networkId = reader.bytes();
                                break;
                            case 8:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.stepLimit != null && message.hasOwnProperty("stepLimit"))
                            if (!(message.stepLimit && typeof message.stepLimit.length === "number" || $util.isString(message.stepLimit)))
                                return "stepLimit: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.networkId != null && message.hasOwnProperty("networkId"))
                            if (!(message.networkId && typeof message.networkId.length === "number" || $util.isString(message.networkId)))
                                return "networkId: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Icon.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Icon.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Icon.Proto.SigningInput();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.stepLimit != null)
                            if (typeof object.stepLimit === "string")
                                $util.base64.decode(object.stepLimit, message.stepLimit = $util.newBuffer($util.base64.length(object.stepLimit)), 0);
                            else if (object.stepLimit.length)
                                message.stepLimit = object.stepLimit;
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.networkId != null)
                            if (typeof object.networkId === "string")
                                $util.base64.decode(object.networkId, message.networkId = $util.newBuffer($util.base64.length(object.networkId)), 0);
                            else if (object.networkId.length)
                                message.networkId = object.networkId;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {TW.Icon.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if (options.bytes === String)
                                object.stepLimit = "";
                            else {
                                object.stepLimit = [];
                                if (options.bytes !== Array)
                                    object.stepLimit = $util.newBuffer(object.stepLimit);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.networkId = "";
                            else {
                                object.networkId = [];
                                if (options.bytes !== Array)
                                    object.networkId = $util.newBuffer(object.networkId);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.stepLimit != null && message.hasOwnProperty("stepLimit"))
                            object.stepLimit = options.bytes === String ? $util.base64.encode(message.stepLimit, 0, message.stepLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.stepLimit) : message.stepLimit;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.networkId != null && message.hasOwnProperty("networkId"))
                            object.networkId = options.bytes === String ? $util.base64.encode(message.networkId, 0, message.networkId.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkId) : message.networkId;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Icon.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Icon.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Icon.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {string} encoded
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = "";
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {TW.Icon.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Icon.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Icon.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {TW.Icon.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.encoded);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Icon.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Icon.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.string();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!$util.isString(message.encoded))
                                return "encoded: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Icon.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Icon.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Icon.Proto.SigningOutput();
                        if (object.encoded != null)
                            message.encoded = String(object.encoded);
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {TW.Icon.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.encoded = "";
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Icon;
        })();
    
        TW.IoTeX = (function() {
    
            /**
             * Namespace IoTeX.
             * @memberof TW
             * @namespace
             */
            var IoTeX = {};
    
            IoTeX.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.IoTeX
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transfer = (function() {
    
                    /**
                     * Properties of a Transfer.
                     * @memberof TW.IoTeX.Proto
                     * @interface ITransfer
                     * @property {string|null} [amount] Transfer amount
                     * @property {string|null} [recipient] Transfer recipient
                     * @property {Uint8Array|null} [payload] Transfer payload
                     */
    
                    /**
                     * Constructs a new Transfer.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a Transfer.
                     * @implements ITransfer
                     * @constructor
                     * @param {TW.IoTeX.Proto.ITransfer=} [properties] Properties to set
                     */
                    function Transfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transfer amount.
                     * @member {string} amount
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.amount = "";
    
                    /**
                     * Transfer recipient.
                     * @member {string} recipient
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.recipient = "";
    
                    /**
                     * Transfer payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {TW.IoTeX.Proto.ITransfer=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.Transfer} Transfer instance
                     */
                    Transfer.create = function create(properties) {
                        return new Transfer(properties);
                    };
    
                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.IoTeX.Proto.Transfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {TW.IoTeX.Proto.ITransfer} message Transfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.amount);
                        if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.recipient);
                        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.Transfer} Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Transfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.string();
                                break;
                            case 2:
                                message.recipient = reader.string();
                                break;
                            case 3:
                                message.payload = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transfer message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            if (!$util.isString(message.recipient))
                                return "recipient: string expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.Transfer} Transfer
                     */
                    Transfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.Transfer)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.Transfer();
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        if (object.recipient != null)
                            message.recipient = String(object.recipient);
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {TW.IoTeX.Proto.Transfer} message Transfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.amount = "";
                            object.recipient = "";
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            object.recipient = message.recipient;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        return object;
                    };
    
                    /**
                     * Converts this Transfer to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transfer;
                })();
    
                Proto.Staking = (function() {
    
                    /**
                     * Properties of a Staking.
                     * @memberof TW.IoTeX.Proto
                     * @interface IStaking
                     * @property {TW.IoTeX.Proto.Staking.ICreate|null} [stakeCreate] Staking stakeCreate
                     * @property {TW.IoTeX.Proto.Staking.IReclaim|null} [stakeUnstake] Staking stakeUnstake
                     * @property {TW.IoTeX.Proto.Staking.IReclaim|null} [stakeWithdraw] Staking stakeWithdraw
                     * @property {TW.IoTeX.Proto.Staking.IAddDeposit|null} [stakeAddDeposit] Staking stakeAddDeposit
                     * @property {TW.IoTeX.Proto.Staking.IRestake|null} [stakeRestake] Staking stakeRestake
                     * @property {TW.IoTeX.Proto.Staking.IChangeCandidate|null} [stakeChangeCandidate] Staking stakeChangeCandidate
                     * @property {TW.IoTeX.Proto.Staking.ITransferOwnership|null} [stakeTransferOwnership] Staking stakeTransferOwnership
                     * @property {TW.IoTeX.Proto.Staking.ICandidateRegister|null} [candidateRegister] Staking candidateRegister
                     * @property {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null} [candidateUpdate] Staking candidateUpdate
                     */
    
                    /**
                     * Constructs a new Staking.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a Staking.
                     * @implements IStaking
                     * @constructor
                     * @param {TW.IoTeX.Proto.IStaking=} [properties] Properties to set
                     */
                    function Staking(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Staking stakeCreate.
                     * @member {TW.IoTeX.Proto.Staking.ICreate|null|undefined} stakeCreate
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.stakeCreate = null;
    
                    /**
                     * Staking stakeUnstake.
                     * @member {TW.IoTeX.Proto.Staking.IReclaim|null|undefined} stakeUnstake
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.stakeUnstake = null;
    
                    /**
                     * Staking stakeWithdraw.
                     * @member {TW.IoTeX.Proto.Staking.IReclaim|null|undefined} stakeWithdraw
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.stakeWithdraw = null;
    
                    /**
                     * Staking stakeAddDeposit.
                     * @member {TW.IoTeX.Proto.Staking.IAddDeposit|null|undefined} stakeAddDeposit
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.stakeAddDeposit = null;
    
                    /**
                     * Staking stakeRestake.
                     * @member {TW.IoTeX.Proto.Staking.IRestake|null|undefined} stakeRestake
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.stakeRestake = null;
    
                    /**
                     * Staking stakeChangeCandidate.
                     * @member {TW.IoTeX.Proto.Staking.IChangeCandidate|null|undefined} stakeChangeCandidate
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.stakeChangeCandidate = null;
    
                    /**
                     * Staking stakeTransferOwnership.
                     * @member {TW.IoTeX.Proto.Staking.ITransferOwnership|null|undefined} stakeTransferOwnership
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.stakeTransferOwnership = null;
    
                    /**
                     * Staking candidateRegister.
                     * @member {TW.IoTeX.Proto.Staking.ICandidateRegister|null|undefined} candidateRegister
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.candidateRegister = null;
    
                    /**
                     * Staking candidateUpdate.
                     * @member {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null|undefined} candidateUpdate
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.candidateUpdate = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Staking message.
                     * @member {"stakeCreate"|"stakeUnstake"|"stakeWithdraw"|"stakeAddDeposit"|"stakeRestake"|"stakeChangeCandidate"|"stakeTransferOwnership"|"candidateRegister"|"candidateUpdate"|undefined} message
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     */
                    Object.defineProperty(Staking.prototype, "message", {
                        get: $util.oneOfGetter($oneOfFields = ["stakeCreate", "stakeUnstake", "stakeWithdraw", "stakeAddDeposit", "stakeRestake", "stakeChangeCandidate", "stakeTransferOwnership", "candidateRegister", "candidateUpdate"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Staking instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.Staking
                     * @static
                     * @param {TW.IoTeX.Proto.IStaking=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.Staking} Staking instance
                     */
                    Staking.create = function create(properties) {
                        return new Staking(properties);
                    };
    
                    /**
                     * Encodes the specified Staking message. Does not implicitly {@link TW.IoTeX.Proto.Staking.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.Staking
                     * @static
                     * @param {TW.IoTeX.Proto.IStaking} message Staking message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Staking.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.stakeCreate != null && Object.hasOwnProperty.call(message, "stakeCreate"))
                            $root.TW.IoTeX.Proto.Staking.Create.encode(message.stakeCreate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.stakeUnstake != null && Object.hasOwnProperty.call(message, "stakeUnstake"))
                            $root.TW.IoTeX.Proto.Staking.Reclaim.encode(message.stakeUnstake, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.stakeWithdraw != null && Object.hasOwnProperty.call(message, "stakeWithdraw"))
                            $root.TW.IoTeX.Proto.Staking.Reclaim.encode(message.stakeWithdraw, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.stakeAddDeposit != null && Object.hasOwnProperty.call(message, "stakeAddDeposit"))
                            $root.TW.IoTeX.Proto.Staking.AddDeposit.encode(message.stakeAddDeposit, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.stakeRestake != null && Object.hasOwnProperty.call(message, "stakeRestake"))
                            $root.TW.IoTeX.Proto.Staking.Restake.encode(message.stakeRestake, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.stakeChangeCandidate != null && Object.hasOwnProperty.call(message, "stakeChangeCandidate"))
                            $root.TW.IoTeX.Proto.Staking.ChangeCandidate.encode(message.stakeChangeCandidate, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.stakeTransferOwnership != null && Object.hasOwnProperty.call(message, "stakeTransferOwnership"))
                            $root.TW.IoTeX.Proto.Staking.TransferOwnership.encode(message.stakeTransferOwnership, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.candidateRegister != null && Object.hasOwnProperty.call(message, "candidateRegister"))
                            $root.TW.IoTeX.Proto.Staking.CandidateRegister.encode(message.candidateRegister, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.candidateUpdate != null && Object.hasOwnProperty.call(message, "candidateUpdate"))
                            $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.encode(message.candidateUpdate, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Staking message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.Staking
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.Staking} Staking
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Staking.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Staking message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.Staking
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Staking.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.stakeCreate != null && message.hasOwnProperty("stakeCreate")) {
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Create.verify(message.stakeCreate);
                                if (error)
                                    return "stakeCreate." + error;
                            }
                        }
                        if (message.stakeUnstake != null && message.hasOwnProperty("stakeUnstake")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Reclaim.verify(message.stakeUnstake);
                                if (error)
                                    return "stakeUnstake." + error;
                            }
                        }
                        if (message.stakeWithdraw != null && message.hasOwnProperty("stakeWithdraw")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Reclaim.verify(message.stakeWithdraw);
                                if (error)
                                    return "stakeWithdraw." + error;
                            }
                        }
                        if (message.stakeAddDeposit != null && message.hasOwnProperty("stakeAddDeposit")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.AddDeposit.verify(message.stakeAddDeposit);
                                if (error)
                                    return "stakeAddDeposit." + error;
                            }
                        }
                        if (message.stakeRestake != null && message.hasOwnProperty("stakeRestake")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Restake.verify(message.stakeRestake);
                                if (error)
                                    return "stakeRestake." + error;
                            }
                        }
                        if (message.stakeChangeCandidate != null && message.hasOwnProperty("stakeChangeCandidate")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.verify(message.stakeChangeCandidate);
                                if (error)
                                    return "stakeChangeCandidate." + error;
                            }
                        }
                        if (message.stakeTransferOwnership != null && message.hasOwnProperty("stakeTransferOwnership")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.TransferOwnership.verify(message.stakeTransferOwnership);
                                if (error)
                                    return "stakeTransferOwnership." + error;
                            }
                        }
                        if (message.candidateRegister != null && message.hasOwnProperty("candidateRegister")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.CandidateRegister.verify(message.candidateRegister);
                                if (error)
                                    return "candidateRegister." + error;
                            }
                        }
                        if (message.candidateUpdate != null && message.hasOwnProperty("candidateUpdate")) {
                            if (properties.message === 1)
                                return "message: multiple values";
                            properties.message = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.verify(message.candidateUpdate);
                                if (error)
                                    return "candidateUpdate." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Staking message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.Staking
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.Staking} Staking
                     */
                    Staking.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.Staking)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.Staking();
                        if (object.stakeCreate != null) {
                            if (typeof object.stakeCreate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.stakeCreate: object expected");
                            message.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.fromObject(object.stakeCreate);
                        }
                        if (object.stakeUnstake != null) {
                            if (typeof object.stakeUnstake !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.stakeUnstake: object expected");
                            message.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.fromObject(object.stakeUnstake);
                        }
                        if (object.stakeWithdraw != null) {
                            if (typeof object.stakeWithdraw !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.stakeWithdraw: object expected");
                            message.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.fromObject(object.stakeWithdraw);
                        }
                        if (object.stakeAddDeposit != null) {
                            if (typeof object.stakeAddDeposit !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.stakeAddDeposit: object expected");
                            message.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.fromObject(object.stakeAddDeposit);
                        }
                        if (object.stakeRestake != null) {
                            if (typeof object.stakeRestake !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.stakeRestake: object expected");
                            message.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.fromObject(object.stakeRestake);
                        }
                        if (object.stakeChangeCandidate != null) {
                            if (typeof object.stakeChangeCandidate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.stakeChangeCandidate: object expected");
                            message.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.fromObject(object.stakeChangeCandidate);
                        }
                        if (object.stakeTransferOwnership != null) {
                            if (typeof object.stakeTransferOwnership !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.stakeTransferOwnership: object expected");
                            message.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.fromObject(object.stakeTransferOwnership);
                        }
                        if (object.candidateRegister != null) {
                            if (typeof object.candidateRegister !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.candidateRegister: object expected");
                            message.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.fromObject(object.candidateRegister);
                        }
                        if (object.candidateUpdate != null) {
                            if (typeof object.candidateUpdate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Staking.candidateUpdate: object expected");
                            message.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.fromObject(object.candidateUpdate);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Staking message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.Staking
                     * @static
                     * @param {TW.IoTeX.Proto.Staking} message Staking
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Staking.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.stakeCreate != null && message.hasOwnProperty("stakeCreate")) {
                            object.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.toObject(message.stakeCreate, options);
                            if (options.oneofs)
                                object.message = "stakeCreate";
                        }
                        if (message.stakeUnstake != null && message.hasOwnProperty("stakeUnstake")) {
                            object.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.toObject(message.stakeUnstake, options);
                            if (options.oneofs)
                                object.message = "stakeUnstake";
                        }
                        if (message.stakeWithdraw != null && message.hasOwnProperty("stakeWithdraw")) {
                            object.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.toObject(message.stakeWithdraw, options);
                            if (options.oneofs)
                                object.message = "stakeWithdraw";
                        }
                        if (message.stakeAddDeposit != null && message.hasOwnProperty("stakeAddDeposit")) {
                            object.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.toObject(message.stakeAddDeposit, options);
                            if (options.oneofs)
                                object.message = "stakeAddDeposit";
                        }
                        if (message.stakeRestake != null && message.hasOwnProperty("stakeRestake")) {
                            object.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.toObject(message.stakeRestake, options);
                            if (options.oneofs)
                                object.message = "stakeRestake";
                        }
                        if (message.stakeChangeCandidate != null && message.hasOwnProperty("stakeChangeCandidate")) {
                            object.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.toObject(message.stakeChangeCandidate, options);
                            if (options.oneofs)
                                object.message = "stakeChangeCandidate";
                        }
                        if (message.stakeTransferOwnership != null && message.hasOwnProperty("stakeTransferOwnership")) {
                            object.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.toObject(message.stakeTransferOwnership, options);
                            if (options.oneofs)
                                object.message = "stakeTransferOwnership";
                        }
                        if (message.candidateRegister != null && message.hasOwnProperty("candidateRegister")) {
                            object.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.toObject(message.candidateRegister, options);
                            if (options.oneofs)
                                object.message = "candidateRegister";
                        }
                        if (message.candidateUpdate != null && message.hasOwnProperty("candidateUpdate")) {
                            object.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.toObject(message.candidateUpdate, options);
                            if (options.oneofs)
                                object.message = "candidateUpdate";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Staking to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.Staking
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Staking.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Staking.Create = (function() {
    
                        /**
                         * Properties of a Create.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface ICreate
                         * @property {string|null} [candidateName] Create candidateName
                         * @property {string|null} [stakedAmount] Create stakedAmount
                         * @property {number|null} [stakedDuration] Create stakedDuration
                         * @property {boolean|null} [autoStake] Create autoStake
                         * @property {Uint8Array|null} [payload] Create payload
                         */
    
                        /**
                         * Constructs a new Create.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents a Create.
                         * @implements ICreate
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.ICreate=} [properties] Properties to set
                         */
                        function Create(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Create candidateName.
                         * @member {string} candidateName
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @instance
                         */
                        Create.prototype.candidateName = "";
    
                        /**
                         * Create stakedAmount.
                         * @member {string} stakedAmount
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @instance
                         */
                        Create.prototype.stakedAmount = "";
    
                        /**
                         * Create stakedDuration.
                         * @member {number} stakedDuration
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @instance
                         */
                        Create.prototype.stakedDuration = 0;
    
                        /**
                         * Create autoStake.
                         * @member {boolean} autoStake
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @instance
                         */
                        Create.prototype.autoStake = false;
    
                        /**
                         * Create payload.
                         * @member {Uint8Array} payload
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @instance
                         */
                        Create.prototype.payload = $util.newBuffer([]);
    
                        /**
                         * Creates a new Create instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ICreate=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.Create} Create instance
                         */
                        Create.create = function create(properties) {
                            return new Create(properties);
                        };
    
                        /**
                         * Encodes the specified Create message. Does not implicitly {@link TW.IoTeX.Proto.Staking.Create.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ICreate} message Create message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Create.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.candidateName != null && Object.hasOwnProperty.call(message, "candidateName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.candidateName);
                            if (message.stakedAmount != null && Object.hasOwnProperty.call(message, "stakedAmount"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stakedAmount);
                            if (message.stakedDuration != null && Object.hasOwnProperty.call(message, "stakedDuration"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stakedDuration);
                            if (message.autoStake != null && Object.hasOwnProperty.call(message, "autoStake"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.autoStake);
                            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.payload);
                            return writer;
                        };
    
                        /**
                         * Decodes a Create message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.Create} Create
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Create.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.Create();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.candidateName = reader.string();
                                    break;
                                case 2:
                                    message.stakedAmount = reader.string();
                                    break;
                                case 3:
                                    message.stakedDuration = reader.uint32();
                                    break;
                                case 4:
                                    message.autoStake = reader.bool();
                                    break;
                                case 5:
                                    message.payload = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Create message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Create.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.candidateName != null && message.hasOwnProperty("candidateName"))
                                if (!$util.isString(message.candidateName))
                                    return "candidateName: string expected";
                            if (message.stakedAmount != null && message.hasOwnProperty("stakedAmount"))
                                if (!$util.isString(message.stakedAmount))
                                    return "stakedAmount: string expected";
                            if (message.stakedDuration != null && message.hasOwnProperty("stakedDuration"))
                                if (!$util.isInteger(message.stakedDuration))
                                    return "stakedDuration: integer expected";
                            if (message.autoStake != null && message.hasOwnProperty("autoStake"))
                                if (typeof message.autoStake !== "boolean")
                                    return "autoStake: boolean expected";
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                    return "payload: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a Create message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.Create} Create
                         */
                        Create.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.Create)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.Create();
                            if (object.candidateName != null)
                                message.candidateName = String(object.candidateName);
                            if (object.stakedAmount != null)
                                message.stakedAmount = String(object.stakedAmount);
                            if (object.stakedDuration != null)
                                message.stakedDuration = object.stakedDuration >>> 0;
                            if (object.autoStake != null)
                                message.autoStake = Boolean(object.autoStake);
                            if (object.payload != null)
                                if (typeof object.payload === "string")
                                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                                else if (object.payload.length)
                                    message.payload = object.payload;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Create message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.Create} message Create
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Create.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.candidateName = "";
                                object.stakedAmount = "";
                                object.stakedDuration = 0;
                                object.autoStake = false;
                                if (options.bytes === String)
                                    object.payload = "";
                                else {
                                    object.payload = [];
                                    if (options.bytes !== Array)
                                        object.payload = $util.newBuffer(object.payload);
                                }
                            }
                            if (message.candidateName != null && message.hasOwnProperty("candidateName"))
                                object.candidateName = message.candidateName;
                            if (message.stakedAmount != null && message.hasOwnProperty("stakedAmount"))
                                object.stakedAmount = message.stakedAmount;
                            if (message.stakedDuration != null && message.hasOwnProperty("stakedDuration"))
                                object.stakedDuration = message.stakedDuration;
                            if (message.autoStake != null && message.hasOwnProperty("autoStake"))
                                object.autoStake = message.autoStake;
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                            return object;
                        };
    
                        /**
                         * Converts this Create to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.Create
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Create.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Create;
                    })();
    
                    Staking.Reclaim = (function() {
    
                        /**
                         * Properties of a Reclaim.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface IReclaim
                         * @property {Long|null} [bucketIndex] Reclaim bucketIndex
                         * @property {Uint8Array|null} [payload] Reclaim payload
                         */
    
                        /**
                         * Constructs a new Reclaim.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents a Reclaim.
                         * @implements IReclaim
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.IReclaim=} [properties] Properties to set
                         */
                        function Reclaim(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Reclaim bucketIndex.
                         * @member {Long} bucketIndex
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @instance
                         */
                        Reclaim.prototype.bucketIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Reclaim payload.
                         * @member {Uint8Array} payload
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @instance
                         */
                        Reclaim.prototype.payload = $util.newBuffer([]);
    
                        /**
                         * Creates a new Reclaim instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IReclaim=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.Reclaim} Reclaim instance
                         */
                        Reclaim.create = function create(properties) {
                            return new Reclaim(properties);
                        };
    
                        /**
                         * Encodes the specified Reclaim message. Does not implicitly {@link TW.IoTeX.Proto.Staking.Reclaim.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IReclaim} message Reclaim message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Reclaim.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.bucketIndex != null && Object.hasOwnProperty.call(message, "bucketIndex"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.bucketIndex);
                            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                            return writer;
                        };
    
                        /**
                         * Decodes a Reclaim message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.Reclaim} Reclaim
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Reclaim.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.Reclaim();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.bucketIndex = reader.uint64();
                                    break;
                                case 2:
                                    message.payload = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Reclaim message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Reclaim.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (!$util.isInteger(message.bucketIndex) && !(message.bucketIndex && $util.isInteger(message.bucketIndex.low) && $util.isInteger(message.bucketIndex.high)))
                                    return "bucketIndex: integer|Long expected";
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                    return "payload: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a Reclaim message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.Reclaim} Reclaim
                         */
                        Reclaim.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.Reclaim)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.Reclaim();
                            if (object.bucketIndex != null)
                                if ($util.Long)
                                    (message.bucketIndex = $util.Long.fromValue(object.bucketIndex)).unsigned = true;
                                else if (typeof object.bucketIndex === "string")
                                    message.bucketIndex = parseInt(object.bucketIndex, 10);
                                else if (typeof object.bucketIndex === "number")
                                    message.bucketIndex = object.bucketIndex;
                                else if (typeof object.bucketIndex === "object")
                                    message.bucketIndex = new $util.LongBits(object.bucketIndex.low >>> 0, object.bucketIndex.high >>> 0).toNumber(true);
                            if (object.payload != null)
                                if (typeof object.payload === "string")
                                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                                else if (object.payload.length)
                                    message.payload = object.payload;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Reclaim message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.Reclaim} message Reclaim
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Reclaim.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.bucketIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.bucketIndex = options.longs === String ? "0" : 0;
                                if (options.bytes === String)
                                    object.payload = "";
                                else {
                                    object.payload = [];
                                    if (options.bytes !== Array)
                                        object.payload = $util.newBuffer(object.payload);
                                }
                            }
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (typeof message.bucketIndex === "number")
                                    object.bucketIndex = options.longs === String ? String(message.bucketIndex) : message.bucketIndex;
                                else
                                    object.bucketIndex = options.longs === String ? $util.Long.prototype.toString.call(message.bucketIndex) : options.longs === Number ? new $util.LongBits(message.bucketIndex.low >>> 0, message.bucketIndex.high >>> 0).toNumber(true) : message.bucketIndex;
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                            return object;
                        };
    
                        /**
                         * Converts this Reclaim to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.Reclaim
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Reclaim.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Reclaim;
                    })();
    
                    Staking.AddDeposit = (function() {
    
                        /**
                         * Properties of an AddDeposit.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface IAddDeposit
                         * @property {Long|null} [bucketIndex] AddDeposit bucketIndex
                         * @property {string|null} [amount] AddDeposit amount
                         * @property {Uint8Array|null} [payload] AddDeposit payload
                         */
    
                        /**
                         * Constructs a new AddDeposit.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents an AddDeposit.
                         * @implements IAddDeposit
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.IAddDeposit=} [properties] Properties to set
                         */
                        function AddDeposit(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * AddDeposit bucketIndex.
                         * @member {Long} bucketIndex
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @instance
                         */
                        AddDeposit.prototype.bucketIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * AddDeposit amount.
                         * @member {string} amount
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @instance
                         */
                        AddDeposit.prototype.amount = "";
    
                        /**
                         * AddDeposit payload.
                         * @member {Uint8Array} payload
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @instance
                         */
                        AddDeposit.prototype.payload = $util.newBuffer([]);
    
                        /**
                         * Creates a new AddDeposit instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IAddDeposit=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.AddDeposit} AddDeposit instance
                         */
                        AddDeposit.create = function create(properties) {
                            return new AddDeposit(properties);
                        };
    
                        /**
                         * Encodes the specified AddDeposit message. Does not implicitly {@link TW.IoTeX.Proto.Staking.AddDeposit.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IAddDeposit} message AddDeposit message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AddDeposit.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.bucketIndex != null && Object.hasOwnProperty.call(message, "bucketIndex"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.bucketIndex);
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                            return writer;
                        };
    
                        /**
                         * Decodes an AddDeposit message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.AddDeposit} AddDeposit
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AddDeposit.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.AddDeposit();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.bucketIndex = reader.uint64();
                                    break;
                                case 2:
                                    message.amount = reader.string();
                                    break;
                                case 3:
                                    message.payload = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies an AddDeposit message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AddDeposit.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (!$util.isInteger(message.bucketIndex) && !(message.bucketIndex && $util.isInteger(message.bucketIndex.low) && $util.isInteger(message.bucketIndex.high)))
                                    return "bucketIndex: integer|Long expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!$util.isString(message.amount))
                                    return "amount: string expected";
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                    return "payload: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates an AddDeposit message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.AddDeposit} AddDeposit
                         */
                        AddDeposit.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.AddDeposit)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.AddDeposit();
                            if (object.bucketIndex != null)
                                if ($util.Long)
                                    (message.bucketIndex = $util.Long.fromValue(object.bucketIndex)).unsigned = true;
                                else if (typeof object.bucketIndex === "string")
                                    message.bucketIndex = parseInt(object.bucketIndex, 10);
                                else if (typeof object.bucketIndex === "number")
                                    message.bucketIndex = object.bucketIndex;
                                else if (typeof object.bucketIndex === "object")
                                    message.bucketIndex = new $util.LongBits(object.bucketIndex.low >>> 0, object.bucketIndex.high >>> 0).toNumber(true);
                            if (object.amount != null)
                                message.amount = String(object.amount);
                            if (object.payload != null)
                                if (typeof object.payload === "string")
                                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                                else if (object.payload.length)
                                    message.payload = object.payload;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an AddDeposit message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.AddDeposit} message AddDeposit
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AddDeposit.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.bucketIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.bucketIndex = options.longs === String ? "0" : 0;
                                object.amount = "";
                                if (options.bytes === String)
                                    object.payload = "";
                                else {
                                    object.payload = [];
                                    if (options.bytes !== Array)
                                        object.payload = $util.newBuffer(object.payload);
                                }
                            }
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (typeof message.bucketIndex === "number")
                                    object.bucketIndex = options.longs === String ? String(message.bucketIndex) : message.bucketIndex;
                                else
                                    object.bucketIndex = options.longs === String ? $util.Long.prototype.toString.call(message.bucketIndex) : options.longs === Number ? new $util.LongBits(message.bucketIndex.low >>> 0, message.bucketIndex.high >>> 0).toNumber(true) : message.bucketIndex;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = message.amount;
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                            return object;
                        };
    
                        /**
                         * Converts this AddDeposit to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.AddDeposit
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AddDeposit.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return AddDeposit;
                    })();
    
                    Staking.Restake = (function() {
    
                        /**
                         * Properties of a Restake.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface IRestake
                         * @property {Long|null} [bucketIndex] Restake bucketIndex
                         * @property {number|null} [stakedDuration] Restake stakedDuration
                         * @property {boolean|null} [autoStake] Restake autoStake
                         * @property {Uint8Array|null} [payload] Restake payload
                         */
    
                        /**
                         * Constructs a new Restake.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents a Restake.
                         * @implements IRestake
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.IRestake=} [properties] Properties to set
                         */
                        function Restake(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Restake bucketIndex.
                         * @member {Long} bucketIndex
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @instance
                         */
                        Restake.prototype.bucketIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * Restake stakedDuration.
                         * @member {number} stakedDuration
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @instance
                         */
                        Restake.prototype.stakedDuration = 0;
    
                        /**
                         * Restake autoStake.
                         * @member {boolean} autoStake
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @instance
                         */
                        Restake.prototype.autoStake = false;
    
                        /**
                         * Restake payload.
                         * @member {Uint8Array} payload
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @instance
                         */
                        Restake.prototype.payload = $util.newBuffer([]);
    
                        /**
                         * Creates a new Restake instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IRestake=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.Restake} Restake instance
                         */
                        Restake.create = function create(properties) {
                            return new Restake(properties);
                        };
    
                        /**
                         * Encodes the specified Restake message. Does not implicitly {@link TW.IoTeX.Proto.Staking.Restake.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IRestake} message Restake message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Restake.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.bucketIndex != null && Object.hasOwnProperty.call(message, "bucketIndex"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.bucketIndex);
                            if (message.stakedDuration != null && Object.hasOwnProperty.call(message, "stakedDuration"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stakedDuration);
                            if (message.autoStake != null && Object.hasOwnProperty.call(message, "autoStake"))
                                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.autoStake);
                            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
                            return writer;
                        };
    
                        /**
                         * Decodes a Restake message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.Restake} Restake
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Restake.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.Restake();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.bucketIndex = reader.uint64();
                                    break;
                                case 2:
                                    message.stakedDuration = reader.uint32();
                                    break;
                                case 3:
                                    message.autoStake = reader.bool();
                                    break;
                                case 4:
                                    message.payload = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Restake message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Restake.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (!$util.isInteger(message.bucketIndex) && !(message.bucketIndex && $util.isInteger(message.bucketIndex.low) && $util.isInteger(message.bucketIndex.high)))
                                    return "bucketIndex: integer|Long expected";
                            if (message.stakedDuration != null && message.hasOwnProperty("stakedDuration"))
                                if (!$util.isInteger(message.stakedDuration))
                                    return "stakedDuration: integer expected";
                            if (message.autoStake != null && message.hasOwnProperty("autoStake"))
                                if (typeof message.autoStake !== "boolean")
                                    return "autoStake: boolean expected";
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                    return "payload: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a Restake message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.Restake} Restake
                         */
                        Restake.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.Restake)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.Restake();
                            if (object.bucketIndex != null)
                                if ($util.Long)
                                    (message.bucketIndex = $util.Long.fromValue(object.bucketIndex)).unsigned = true;
                                else if (typeof object.bucketIndex === "string")
                                    message.bucketIndex = parseInt(object.bucketIndex, 10);
                                else if (typeof object.bucketIndex === "number")
                                    message.bucketIndex = object.bucketIndex;
                                else if (typeof object.bucketIndex === "object")
                                    message.bucketIndex = new $util.LongBits(object.bucketIndex.low >>> 0, object.bucketIndex.high >>> 0).toNumber(true);
                            if (object.stakedDuration != null)
                                message.stakedDuration = object.stakedDuration >>> 0;
                            if (object.autoStake != null)
                                message.autoStake = Boolean(object.autoStake);
                            if (object.payload != null)
                                if (typeof object.payload === "string")
                                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                                else if (object.payload.length)
                                    message.payload = object.payload;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Restake message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.Restake} message Restake
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Restake.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.bucketIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.bucketIndex = options.longs === String ? "0" : 0;
                                object.stakedDuration = 0;
                                object.autoStake = false;
                                if (options.bytes === String)
                                    object.payload = "";
                                else {
                                    object.payload = [];
                                    if (options.bytes !== Array)
                                        object.payload = $util.newBuffer(object.payload);
                                }
                            }
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (typeof message.bucketIndex === "number")
                                    object.bucketIndex = options.longs === String ? String(message.bucketIndex) : message.bucketIndex;
                                else
                                    object.bucketIndex = options.longs === String ? $util.Long.prototype.toString.call(message.bucketIndex) : options.longs === Number ? new $util.LongBits(message.bucketIndex.low >>> 0, message.bucketIndex.high >>> 0).toNumber(true) : message.bucketIndex;
                            if (message.stakedDuration != null && message.hasOwnProperty("stakedDuration"))
                                object.stakedDuration = message.stakedDuration;
                            if (message.autoStake != null && message.hasOwnProperty("autoStake"))
                                object.autoStake = message.autoStake;
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                            return object;
                        };
    
                        /**
                         * Converts this Restake to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.Restake
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Restake.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Restake;
                    })();
    
                    Staking.ChangeCandidate = (function() {
    
                        /**
                         * Properties of a ChangeCandidate.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface IChangeCandidate
                         * @property {Long|null} [bucketIndex] ChangeCandidate bucketIndex
                         * @property {string|null} [candidateName] ChangeCandidate candidateName
                         * @property {Uint8Array|null} [payload] ChangeCandidate payload
                         */
    
                        /**
                         * Constructs a new ChangeCandidate.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents a ChangeCandidate.
                         * @implements IChangeCandidate
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.IChangeCandidate=} [properties] Properties to set
                         */
                        function ChangeCandidate(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ChangeCandidate bucketIndex.
                         * @member {Long} bucketIndex
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @instance
                         */
                        ChangeCandidate.prototype.bucketIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * ChangeCandidate candidateName.
                         * @member {string} candidateName
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @instance
                         */
                        ChangeCandidate.prototype.candidateName = "";
    
                        /**
                         * ChangeCandidate payload.
                         * @member {Uint8Array} payload
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @instance
                         */
                        ChangeCandidate.prototype.payload = $util.newBuffer([]);
    
                        /**
                         * Creates a new ChangeCandidate instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IChangeCandidate=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.ChangeCandidate} ChangeCandidate instance
                         */
                        ChangeCandidate.create = function create(properties) {
                            return new ChangeCandidate(properties);
                        };
    
                        /**
                         * Encodes the specified ChangeCandidate message. Does not implicitly {@link TW.IoTeX.Proto.Staking.ChangeCandidate.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.IChangeCandidate} message ChangeCandidate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChangeCandidate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.bucketIndex != null && Object.hasOwnProperty.call(message, "bucketIndex"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.bucketIndex);
                            if (message.candidateName != null && Object.hasOwnProperty.call(message, "candidateName"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.candidateName);
                            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                            return writer;
                        };
    
                        /**
                         * Decodes a ChangeCandidate message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.ChangeCandidate} ChangeCandidate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChangeCandidate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.ChangeCandidate();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.bucketIndex = reader.uint64();
                                    break;
                                case 2:
                                    message.candidateName = reader.string();
                                    break;
                                case 3:
                                    message.payload = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a ChangeCandidate message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ChangeCandidate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (!$util.isInteger(message.bucketIndex) && !(message.bucketIndex && $util.isInteger(message.bucketIndex.low) && $util.isInteger(message.bucketIndex.high)))
                                    return "bucketIndex: integer|Long expected";
                            if (message.candidateName != null && message.hasOwnProperty("candidateName"))
                                if (!$util.isString(message.candidateName))
                                    return "candidateName: string expected";
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                    return "payload: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a ChangeCandidate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.ChangeCandidate} ChangeCandidate
                         */
                        ChangeCandidate.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.ChangeCandidate)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.ChangeCandidate();
                            if (object.bucketIndex != null)
                                if ($util.Long)
                                    (message.bucketIndex = $util.Long.fromValue(object.bucketIndex)).unsigned = true;
                                else if (typeof object.bucketIndex === "string")
                                    message.bucketIndex = parseInt(object.bucketIndex, 10);
                                else if (typeof object.bucketIndex === "number")
                                    message.bucketIndex = object.bucketIndex;
                                else if (typeof object.bucketIndex === "object")
                                    message.bucketIndex = new $util.LongBits(object.bucketIndex.low >>> 0, object.bucketIndex.high >>> 0).toNumber(true);
                            if (object.candidateName != null)
                                message.candidateName = String(object.candidateName);
                            if (object.payload != null)
                                if (typeof object.payload === "string")
                                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                                else if (object.payload.length)
                                    message.payload = object.payload;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a ChangeCandidate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ChangeCandidate} message ChangeCandidate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ChangeCandidate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.bucketIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.bucketIndex = options.longs === String ? "0" : 0;
                                object.candidateName = "";
                                if (options.bytes === String)
                                    object.payload = "";
                                else {
                                    object.payload = [];
                                    if (options.bytes !== Array)
                                        object.payload = $util.newBuffer(object.payload);
                                }
                            }
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (typeof message.bucketIndex === "number")
                                    object.bucketIndex = options.longs === String ? String(message.bucketIndex) : message.bucketIndex;
                                else
                                    object.bucketIndex = options.longs === String ? $util.Long.prototype.toString.call(message.bucketIndex) : options.longs === Number ? new $util.LongBits(message.bucketIndex.low >>> 0, message.bucketIndex.high >>> 0).toNumber(true) : message.bucketIndex;
                            if (message.candidateName != null && message.hasOwnProperty("candidateName"))
                                object.candidateName = message.candidateName;
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                            return object;
                        };
    
                        /**
                         * Converts this ChangeCandidate to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.ChangeCandidate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ChangeCandidate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return ChangeCandidate;
                    })();
    
                    Staking.TransferOwnership = (function() {
    
                        /**
                         * Properties of a TransferOwnership.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface ITransferOwnership
                         * @property {Long|null} [bucketIndex] TransferOwnership bucketIndex
                         * @property {string|null} [voterAddress] TransferOwnership voterAddress
                         * @property {Uint8Array|null} [payload] TransferOwnership payload
                         */
    
                        /**
                         * Constructs a new TransferOwnership.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents a TransferOwnership.
                         * @implements ITransferOwnership
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.ITransferOwnership=} [properties] Properties to set
                         */
                        function TransferOwnership(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * TransferOwnership bucketIndex.
                         * @member {Long} bucketIndex
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @instance
                         */
                        TransferOwnership.prototype.bucketIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * TransferOwnership voterAddress.
                         * @member {string} voterAddress
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @instance
                         */
                        TransferOwnership.prototype.voterAddress = "";
    
                        /**
                         * TransferOwnership payload.
                         * @member {Uint8Array} payload
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @instance
                         */
                        TransferOwnership.prototype.payload = $util.newBuffer([]);
    
                        /**
                         * Creates a new TransferOwnership instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ITransferOwnership=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.TransferOwnership} TransferOwnership instance
                         */
                        TransferOwnership.create = function create(properties) {
                            return new TransferOwnership(properties);
                        };
    
                        /**
                         * Encodes the specified TransferOwnership message. Does not implicitly {@link TW.IoTeX.Proto.Staking.TransferOwnership.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ITransferOwnership} message TransferOwnership message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TransferOwnership.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.bucketIndex != null && Object.hasOwnProperty.call(message, "bucketIndex"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.bucketIndex);
                            if (message.voterAddress != null && Object.hasOwnProperty.call(message, "voterAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.voterAddress);
                            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                            return writer;
                        };
    
                        /**
                         * Decodes a TransferOwnership message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.TransferOwnership} TransferOwnership
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TransferOwnership.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.TransferOwnership();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.bucketIndex = reader.uint64();
                                    break;
                                case 2:
                                    message.voterAddress = reader.string();
                                    break;
                                case 3:
                                    message.payload = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a TransferOwnership message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        TransferOwnership.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (!$util.isInteger(message.bucketIndex) && !(message.bucketIndex && $util.isInteger(message.bucketIndex.low) && $util.isInteger(message.bucketIndex.high)))
                                    return "bucketIndex: integer|Long expected";
                            if (message.voterAddress != null && message.hasOwnProperty("voterAddress"))
                                if (!$util.isString(message.voterAddress))
                                    return "voterAddress: string expected";
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                    return "payload: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a TransferOwnership message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.TransferOwnership} TransferOwnership
                         */
                        TransferOwnership.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.TransferOwnership)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.TransferOwnership();
                            if (object.bucketIndex != null)
                                if ($util.Long)
                                    (message.bucketIndex = $util.Long.fromValue(object.bucketIndex)).unsigned = true;
                                else if (typeof object.bucketIndex === "string")
                                    message.bucketIndex = parseInt(object.bucketIndex, 10);
                                else if (typeof object.bucketIndex === "number")
                                    message.bucketIndex = object.bucketIndex;
                                else if (typeof object.bucketIndex === "object")
                                    message.bucketIndex = new $util.LongBits(object.bucketIndex.low >>> 0, object.bucketIndex.high >>> 0).toNumber(true);
                            if (object.voterAddress != null)
                                message.voterAddress = String(object.voterAddress);
                            if (object.payload != null)
                                if (typeof object.payload === "string")
                                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                                else if (object.payload.length)
                                    message.payload = object.payload;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a TransferOwnership message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.TransferOwnership} message TransferOwnership
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        TransferOwnership.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.bucketIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.bucketIndex = options.longs === String ? "0" : 0;
                                object.voterAddress = "";
                                if (options.bytes === String)
                                    object.payload = "";
                                else {
                                    object.payload = [];
                                    if (options.bytes !== Array)
                                        object.payload = $util.newBuffer(object.payload);
                                }
                            }
                            if (message.bucketIndex != null && message.hasOwnProperty("bucketIndex"))
                                if (typeof message.bucketIndex === "number")
                                    object.bucketIndex = options.longs === String ? String(message.bucketIndex) : message.bucketIndex;
                                else
                                    object.bucketIndex = options.longs === String ? $util.Long.prototype.toString.call(message.bucketIndex) : options.longs === Number ? new $util.LongBits(message.bucketIndex.low >>> 0, message.bucketIndex.high >>> 0).toNumber(true) : message.bucketIndex;
                            if (message.voterAddress != null && message.hasOwnProperty("voterAddress"))
                                object.voterAddress = message.voterAddress;
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                            return object;
                        };
    
                        /**
                         * Converts this TransferOwnership to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.TransferOwnership
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        TransferOwnership.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return TransferOwnership;
                    })();
    
                    Staking.CandidateBasicInfo = (function() {
    
                        /**
                         * Properties of a CandidateBasicInfo.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface ICandidateBasicInfo
                         * @property {string|null} [name] CandidateBasicInfo name
                         * @property {string|null} [operatorAddress] CandidateBasicInfo operatorAddress
                         * @property {string|null} [rewardAddress] CandidateBasicInfo rewardAddress
                         */
    
                        /**
                         * Constructs a new CandidateBasicInfo.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents a CandidateBasicInfo.
                         * @implements ICandidateBasicInfo
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.ICandidateBasicInfo=} [properties] Properties to set
                         */
                        function CandidateBasicInfo(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * CandidateBasicInfo name.
                         * @member {string} name
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @instance
                         */
                        CandidateBasicInfo.prototype.name = "";
    
                        /**
                         * CandidateBasicInfo operatorAddress.
                         * @member {string} operatorAddress
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @instance
                         */
                        CandidateBasicInfo.prototype.operatorAddress = "";
    
                        /**
                         * CandidateBasicInfo rewardAddress.
                         * @member {string} rewardAddress
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @instance
                         */
                        CandidateBasicInfo.prototype.rewardAddress = "";
    
                        /**
                         * Creates a new CandidateBasicInfo instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ICandidateBasicInfo=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.CandidateBasicInfo} CandidateBasicInfo instance
                         */
                        CandidateBasicInfo.create = function create(properties) {
                            return new CandidateBasicInfo(properties);
                        };
    
                        /**
                         * Encodes the specified CandidateBasicInfo message. Does not implicitly {@link TW.IoTeX.Proto.Staking.CandidateBasicInfo.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ICandidateBasicInfo} message CandidateBasicInfo message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CandidateBasicInfo.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            if (message.operatorAddress != null && Object.hasOwnProperty.call(message, "operatorAddress"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorAddress);
                            if (message.rewardAddress != null && Object.hasOwnProperty.call(message, "rewardAddress"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.rewardAddress);
                            return writer;
                        };
    
                        /**
                         * Decodes a CandidateBasicInfo message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.CandidateBasicInfo} CandidateBasicInfo
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CandidateBasicInfo.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.name = reader.string();
                                    break;
                                case 2:
                                    message.operatorAddress = reader.string();
                                    break;
                                case 3:
                                    message.rewardAddress = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a CandidateBasicInfo message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CandidateBasicInfo.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.operatorAddress != null && message.hasOwnProperty("operatorAddress"))
                                if (!$util.isString(message.operatorAddress))
                                    return "operatorAddress: string expected";
                            if (message.rewardAddress != null && message.hasOwnProperty("rewardAddress"))
                                if (!$util.isString(message.rewardAddress))
                                    return "rewardAddress: string expected";
                            return null;
                        };
    
                        /**
                         * Creates a CandidateBasicInfo message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.CandidateBasicInfo} CandidateBasicInfo
                         */
                        CandidateBasicInfo.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.operatorAddress != null)
                                message.operatorAddress = String(object.operatorAddress);
                            if (object.rewardAddress != null)
                                message.rewardAddress = String(object.rewardAddress);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a CandidateBasicInfo message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.CandidateBasicInfo} message CandidateBasicInfo
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CandidateBasicInfo.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.name = "";
                                object.operatorAddress = "";
                                object.rewardAddress = "";
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.operatorAddress != null && message.hasOwnProperty("operatorAddress"))
                                object.operatorAddress = message.operatorAddress;
                            if (message.rewardAddress != null && message.hasOwnProperty("rewardAddress"))
                                object.rewardAddress = message.rewardAddress;
                            return object;
                        };
    
                        /**
                         * Converts this CandidateBasicInfo to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.CandidateBasicInfo
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CandidateBasicInfo.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return CandidateBasicInfo;
                    })();
    
                    Staking.CandidateRegister = (function() {
    
                        /**
                         * Properties of a CandidateRegister.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @interface ICandidateRegister
                         * @property {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null} [candidate] CandidateRegister candidate
                         * @property {string|null} [stakedAmount] CandidateRegister stakedAmount
                         * @property {number|null} [stakedDuration] CandidateRegister stakedDuration
                         * @property {boolean|null} [autoStake] CandidateRegister autoStake
                         * @property {string|null} [ownerAddress] CandidateRegister ownerAddress
                         * @property {Uint8Array|null} [payload] CandidateRegister payload
                         */
    
                        /**
                         * Constructs a new CandidateRegister.
                         * @memberof TW.IoTeX.Proto.Staking
                         * @classdesc Represents a CandidateRegister.
                         * @implements ICandidateRegister
                         * @constructor
                         * @param {TW.IoTeX.Proto.Staking.ICandidateRegister=} [properties] Properties to set
                         */
                        function CandidateRegister(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * CandidateRegister candidate.
                         * @member {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null|undefined} candidate
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @instance
                         */
                        CandidateRegister.prototype.candidate = null;
    
                        /**
                         * CandidateRegister stakedAmount.
                         * @member {string} stakedAmount
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @instance
                         */
                        CandidateRegister.prototype.stakedAmount = "";
    
                        /**
                         * CandidateRegister stakedDuration.
                         * @member {number} stakedDuration
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @instance
                         */
                        CandidateRegister.prototype.stakedDuration = 0;
    
                        /**
                         * CandidateRegister autoStake.
                         * @member {boolean} autoStake
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @instance
                         */
                        CandidateRegister.prototype.autoStake = false;
    
                        /**
                         * CandidateRegister ownerAddress.
                         * @member {string} ownerAddress
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @instance
                         */
                        CandidateRegister.prototype.ownerAddress = "";
    
                        /**
                         * CandidateRegister payload.
                         * @member {Uint8Array} payload
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @instance
                         */
                        CandidateRegister.prototype.payload = $util.newBuffer([]);
    
                        /**
                         * Creates a new CandidateRegister instance using the specified properties.
                         * @function create
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ICandidateRegister=} [properties] Properties to set
                         * @returns {TW.IoTeX.Proto.Staking.CandidateRegister} CandidateRegister instance
                         */
                        CandidateRegister.create = function create(properties) {
                            return new CandidateRegister(properties);
                        };
    
                        /**
                         * Encodes the specified CandidateRegister message. Does not implicitly {@link TW.IoTeX.Proto.Staking.CandidateRegister.verify|verify} messages.
                         * @function encode
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.ICandidateRegister} message CandidateRegister message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CandidateRegister.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.candidate != null && Object.hasOwnProperty.call(message, "candidate"))
                                $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.encode(message.candidate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.stakedAmount != null && Object.hasOwnProperty.call(message, "stakedAmount"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stakedAmount);
                            if (message.stakedDuration != null && Object.hasOwnProperty.call(message, "stakedDuration"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stakedDuration);
                            if (message.autoStake != null && Object.hasOwnProperty.call(message, "autoStake"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.autoStake);
                            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.ownerAddress);
                            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
                            return writer;
                        };
    
                        /**
                         * Decodes a CandidateRegister message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.IoTeX.Proto.Staking.CandidateRegister} CandidateRegister
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CandidateRegister.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Staking.CandidateRegister();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.candidate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.stakedAmount = reader.string();
                                    break;
                                case 3:
                                    message.stakedDuration = reader.uint32();
                                    break;
                                case 4:
                                    message.autoStake = reader.bool();
                                    break;
                                case 5:
                                    message.ownerAddress = reader.string();
                                    break;
                                case 6:
                                    message.payload = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a CandidateRegister message.
                         * @function verify
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CandidateRegister.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.candidate != null && message.hasOwnProperty("candidate")) {
                                var error = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.verify(message.candidate);
                                if (error)
                                    return "candidate." + error;
                            }
                            if (message.stakedAmount != null && message.hasOwnProperty("stakedAmount"))
                                if (!$util.isString(message.stakedAmount))
                                    return "stakedAmount: string expected";
                            if (message.stakedDuration != null && message.hasOwnProperty("stakedDuration"))
                                if (!$util.isInteger(message.stakedDuration))
                                    return "stakedDuration: integer expected";
                            if (message.autoStake != null && message.hasOwnProperty("autoStake"))
                                if (typeof message.autoStake !== "boolean")
                                    return "autoStake: boolean expected";
                            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                                if (!$util.isString(message.ownerAddress))
                                    return "ownerAddress: string expected";
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                    return "payload: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a CandidateRegister message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.IoTeX.Proto.Staking.CandidateRegister} CandidateRegister
                         */
                        CandidateRegister.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.IoTeX.Proto.Staking.CandidateRegister)
                                return object;
                            var message = new $root.TW.IoTeX.Proto.Staking.CandidateRegister();
                            if (object.candidate != null) {
                                if (typeof object.candidate !== "object")
                                    throw TypeError(".TW.IoTeX.Proto.Staking.CandidateRegister.candidate: object expected");
                                message.candidate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.fromObject(object.candidate);
                            }
                            if (object.stakedAmount != null)
                                message.stakedAmount = String(object.stakedAmount);
                            if (object.stakedDuration != null)
                                message.stakedDuration = object.stakedDuration >>> 0;
                            if (object.autoStake != null)
                                message.autoStake = Boolean(object.autoStake);
                            if (object.ownerAddress != null)
                                message.ownerAddress = String(object.ownerAddress);
                            if (object.payload != null)
                                if (typeof object.payload === "string")
                                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                                else if (object.payload.length)
                                    message.payload = object.payload;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a CandidateRegister message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @static
                         * @param {TW.IoTeX.Proto.Staking.CandidateRegister} message CandidateRegister
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CandidateRegister.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.candidate = null;
                                object.stakedAmount = "";
                                object.stakedDuration = 0;
                                object.autoStake = false;
                                object.ownerAddress = "";
                                if (options.bytes === String)
                                    object.payload = "";
                                else {
                                    object.payload = [];
                                    if (options.bytes !== Array)
                                        object.payload = $util.newBuffer(object.payload);
                                }
                            }
                            if (message.candidate != null && message.hasOwnProperty("candidate"))
                                object.candidate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.toObject(message.candidate, options);
                            if (message.stakedAmount != null && message.hasOwnProperty("stakedAmount"))
                                object.stakedAmount = message.stakedAmount;
                            if (message.stakedDuration != null && message.hasOwnProperty("stakedDuration"))
                                object.stakedDuration = message.stakedDuration;
                            if (message.autoStake != null && message.hasOwnProperty("autoStake"))
                                object.autoStake = message.autoStake;
                            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                                object.ownerAddress = message.ownerAddress;
                            if (message.payload != null && message.hasOwnProperty("payload"))
                                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                            return object;
                        };
    
                        /**
                         * Converts this CandidateRegister to JSON.
                         * @function toJSON
                         * @memberof TW.IoTeX.Proto.Staking.CandidateRegister
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CandidateRegister.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return CandidateRegister;
                    })();
    
                    return Staking;
                })();
    
                Proto.ContractCall = (function() {
    
                    /**
                     * Properties of a ContractCall.
                     * @memberof TW.IoTeX.Proto
                     * @interface IContractCall
                     * @property {string|null} [amount] ContractCall amount
                     * @property {string|null} [contract] ContractCall contract
                     * @property {Uint8Array|null} [data] ContractCall data
                     */
    
                    /**
                     * Constructs a new ContractCall.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a ContractCall.
                     * @implements IContractCall
                     * @constructor
                     * @param {TW.IoTeX.Proto.IContractCall=} [properties] Properties to set
                     */
                    function ContractCall(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ContractCall amount.
                     * @member {string} amount
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @instance
                     */
                    ContractCall.prototype.amount = "";
    
                    /**
                     * ContractCall contract.
                     * @member {string} contract
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @instance
                     */
                    ContractCall.prototype.contract = "";
    
                    /**
                     * ContractCall data.
                     * @member {Uint8Array} data
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @instance
                     */
                    ContractCall.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new ContractCall instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @static
                     * @param {TW.IoTeX.Proto.IContractCall=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.ContractCall} ContractCall instance
                     */
                    ContractCall.create = function create(properties) {
                        return new ContractCall(properties);
                    };
    
                    /**
                     * Encodes the specified ContractCall message. Does not implicitly {@link TW.IoTeX.Proto.ContractCall.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @static
                     * @param {TW.IoTeX.Proto.IContractCall} message ContractCall message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ContractCall.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.amount);
                        if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.contract);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Decodes a ContractCall message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.ContractCall} ContractCall
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ContractCall.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.ContractCall();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.string();
                                break;
                            case 2:
                                message.contract = reader.string();
                                break;
                            case 3:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a ContractCall message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ContractCall.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            if (!$util.isString(message.contract))
                                return "contract: string expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a ContractCall message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.ContractCall} ContractCall
                     */
                    ContractCall.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.ContractCall)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.ContractCall();
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        if (object.contract != null)
                            message.contract = String(object.contract);
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ContractCall message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @static
                     * @param {TW.IoTeX.Proto.ContractCall} message ContractCall
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ContractCall.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.amount = "";
                            object.contract = "";
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            object.contract = message.contract;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this ContractCall to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.ContractCall
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ContractCall.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ContractCall;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.IoTeX.Proto
                     * @interface ISigningInput
                     * @property {number|null} [version] SigningInput version
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.IoTeX.Proto.ITransfer|null} [transfer] SigningInput transfer
                     * @property {TW.IoTeX.Proto.IContractCall|null} [call] SigningInput call
                     * @property {TW.IoTeX.Proto.Staking.ICreate|null} [stakeCreate] SigningInput stakeCreate
                     * @property {TW.IoTeX.Proto.Staking.IReclaim|null} [stakeUnstake] SigningInput stakeUnstake
                     * @property {TW.IoTeX.Proto.Staking.IReclaim|null} [stakeWithdraw] SigningInput stakeWithdraw
                     * @property {TW.IoTeX.Proto.Staking.IAddDeposit|null} [stakeAddDeposit] SigningInput stakeAddDeposit
                     * @property {TW.IoTeX.Proto.Staking.IRestake|null} [stakeRestake] SigningInput stakeRestake
                     * @property {TW.IoTeX.Proto.Staking.IChangeCandidate|null} [stakeChangeCandidate] SigningInput stakeChangeCandidate
                     * @property {TW.IoTeX.Proto.Staking.ITransferOwnership|null} [stakeTransferOwnership] SigningInput stakeTransferOwnership
                     * @property {TW.IoTeX.Proto.Staking.ICandidateRegister|null} [candidateRegister] SigningInput candidateRegister
                     * @property {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null} [candidateUpdate] SigningInput candidateUpdate
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.IoTeX.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput version.
                     * @member {number} version
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.version = 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput gasPrice.
                     * @member {string} gasPrice
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput transfer.
                     * @member {TW.IoTeX.Proto.ITransfer|null|undefined} transfer
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transfer = null;
    
                    /**
                     * SigningInput call.
                     * @member {TW.IoTeX.Proto.IContractCall|null|undefined} call
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.call = null;
    
                    /**
                     * SigningInput stakeCreate.
                     * @member {TW.IoTeX.Proto.Staking.ICreate|null|undefined} stakeCreate
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeCreate = null;
    
                    /**
                     * SigningInput stakeUnstake.
                     * @member {TW.IoTeX.Proto.Staking.IReclaim|null|undefined} stakeUnstake
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeUnstake = null;
    
                    /**
                     * SigningInput stakeWithdraw.
                     * @member {TW.IoTeX.Proto.Staking.IReclaim|null|undefined} stakeWithdraw
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeWithdraw = null;
    
                    /**
                     * SigningInput stakeAddDeposit.
                     * @member {TW.IoTeX.Proto.Staking.IAddDeposit|null|undefined} stakeAddDeposit
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeAddDeposit = null;
    
                    /**
                     * SigningInput stakeRestake.
                     * @member {TW.IoTeX.Proto.Staking.IRestake|null|undefined} stakeRestake
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeRestake = null;
    
                    /**
                     * SigningInput stakeChangeCandidate.
                     * @member {TW.IoTeX.Proto.Staking.IChangeCandidate|null|undefined} stakeChangeCandidate
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeChangeCandidate = null;
    
                    /**
                     * SigningInput stakeTransferOwnership.
                     * @member {TW.IoTeX.Proto.Staking.ITransferOwnership|null|undefined} stakeTransferOwnership
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeTransferOwnership = null;
    
                    /**
                     * SigningInput candidateRegister.
                     * @member {TW.IoTeX.Proto.Staking.ICandidateRegister|null|undefined} candidateRegister
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.candidateRegister = null;
    
                    /**
                     * SigningInput candidateUpdate.
                     * @member {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null|undefined} candidateUpdate
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.candidateUpdate = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput action.
                     * @member {"transfer"|"call"|"stakeCreate"|"stakeUnstake"|"stakeWithdraw"|"stakeAddDeposit"|"stakeRestake"|"stakeChangeCandidate"|"stakeTransferOwnership"|"candidateRegister"|"candidateUpdate"|undefined} action
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "action", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "call", "stakeCreate", "stakeUnstake", "stakeWithdraw", "stakeAddDeposit", "stakeRestake", "stakeChangeCandidate", "stakeTransferOwnership", "candidateRegister", "candidateUpdate"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.IoTeX.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.gasLimit);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.gasPrice);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.privateKey);
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.IoTeX.Proto.Transfer.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.call != null && Object.hasOwnProperty.call(message, "call"))
                            $root.TW.IoTeX.Proto.ContractCall.encode(message.call, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.stakeCreate != null && Object.hasOwnProperty.call(message, "stakeCreate"))
                            $root.TW.IoTeX.Proto.Staking.Create.encode(message.stakeCreate, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                        if (message.stakeUnstake != null && Object.hasOwnProperty.call(message, "stakeUnstake"))
                            $root.TW.IoTeX.Proto.Staking.Reclaim.encode(message.stakeUnstake, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                        if (message.stakeWithdraw != null && Object.hasOwnProperty.call(message, "stakeWithdraw"))
                            $root.TW.IoTeX.Proto.Staking.Reclaim.encode(message.stakeWithdraw, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
                        if (message.stakeAddDeposit != null && Object.hasOwnProperty.call(message, "stakeAddDeposit"))
                            $root.TW.IoTeX.Proto.Staking.AddDeposit.encode(message.stakeAddDeposit, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
                        if (message.stakeRestake != null && Object.hasOwnProperty.call(message, "stakeRestake"))
                            $root.TW.IoTeX.Proto.Staking.Restake.encode(message.stakeRestake, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
                        if (message.stakeChangeCandidate != null && Object.hasOwnProperty.call(message, "stakeChangeCandidate"))
                            $root.TW.IoTeX.Proto.Staking.ChangeCandidate.encode(message.stakeChangeCandidate, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
                        if (message.stakeTransferOwnership != null && Object.hasOwnProperty.call(message, "stakeTransferOwnership"))
                            $root.TW.IoTeX.Proto.Staking.TransferOwnership.encode(message.stakeTransferOwnership, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
                        if (message.candidateRegister != null && Object.hasOwnProperty.call(message, "candidateRegister"))
                            $root.TW.IoTeX.Proto.Staking.CandidateRegister.encode(message.candidateRegister, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
                        if (message.candidateUpdate != null && Object.hasOwnProperty.call(message, "candidateUpdate"))
                            $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.encode(message.candidateUpdate, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            case 2:
                                message.nonce = reader.uint64();
                                break;
                            case 3:
                                message.gasLimit = reader.uint64();
                                break;
                            case 4:
                                message.gasPrice = reader.string();
                                break;
                            case 5:
                                message.privateKey = reader.bytes();
                                break;
                            case 10:
                                message.transfer = $root.TW.IoTeX.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.call = $root.TW.IoTeX.Proto.ContractCall.decode(reader, reader.uint32());
                                break;
                            case 40:
                                message.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.decode(reader, reader.uint32());
                                break;
                            case 41:
                                message.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.decode(reader, reader.uint32());
                                break;
                            case 42:
                                message.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.decode(reader, reader.uint32());
                                break;
                            case 43:
                                message.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.decode(reader, reader.uint32());
                                break;
                            case 44:
                                message.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.decode(reader, reader.uint32());
                                break;
                            case 45:
                                message.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.decode(reader, reader.uint32());
                                break;
                            case 46:
                                message.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.decode(reader, reader.uint32());
                                break;
                            case 47:
                                message.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.decode(reader, reader.uint32());
                                break;
                            case 48:
                                message.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isString(message.gasPrice))
                                return "gasPrice: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.call != null && message.hasOwnProperty("call")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.ContractCall.verify(message.call);
                                if (error)
                                    return "call." + error;
                            }
                        }
                        if (message.stakeCreate != null && message.hasOwnProperty("stakeCreate")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Create.verify(message.stakeCreate);
                                if (error)
                                    return "stakeCreate." + error;
                            }
                        }
                        if (message.stakeUnstake != null && message.hasOwnProperty("stakeUnstake")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Reclaim.verify(message.stakeUnstake);
                                if (error)
                                    return "stakeUnstake." + error;
                            }
                        }
                        if (message.stakeWithdraw != null && message.hasOwnProperty("stakeWithdraw")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Reclaim.verify(message.stakeWithdraw);
                                if (error)
                                    return "stakeWithdraw." + error;
                            }
                        }
                        if (message.stakeAddDeposit != null && message.hasOwnProperty("stakeAddDeposit")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.AddDeposit.verify(message.stakeAddDeposit);
                                if (error)
                                    return "stakeAddDeposit." + error;
                            }
                        }
                        if (message.stakeRestake != null && message.hasOwnProperty("stakeRestake")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Restake.verify(message.stakeRestake);
                                if (error)
                                    return "stakeRestake." + error;
                            }
                        }
                        if (message.stakeChangeCandidate != null && message.hasOwnProperty("stakeChangeCandidate")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.verify(message.stakeChangeCandidate);
                                if (error)
                                    return "stakeChangeCandidate." + error;
                            }
                        }
                        if (message.stakeTransferOwnership != null && message.hasOwnProperty("stakeTransferOwnership")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.TransferOwnership.verify(message.stakeTransferOwnership);
                                if (error)
                                    return "stakeTransferOwnership." + error;
                            }
                        }
                        if (message.candidateRegister != null && message.hasOwnProperty("candidateRegister")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.CandidateRegister.verify(message.candidateRegister);
                                if (error)
                                    return "candidateRegister." + error;
                            }
                        }
                        if (message.candidateUpdate != null && message.hasOwnProperty("candidateUpdate")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.verify(message.candidateUpdate);
                                if (error)
                                    return "candidateUpdate." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.SigningInput();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.gasPrice != null)
                            message.gasPrice = String(object.gasPrice);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.transfer: object expected");
                            message.transfer = $root.TW.IoTeX.Proto.Transfer.fromObject(object.transfer);
                        }
                        if (object.call != null) {
                            if (typeof object.call !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.call: object expected");
                            message.call = $root.TW.IoTeX.Proto.ContractCall.fromObject(object.call);
                        }
                        if (object.stakeCreate != null) {
                            if (typeof object.stakeCreate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.stakeCreate: object expected");
                            message.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.fromObject(object.stakeCreate);
                        }
                        if (object.stakeUnstake != null) {
                            if (typeof object.stakeUnstake !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.stakeUnstake: object expected");
                            message.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.fromObject(object.stakeUnstake);
                        }
                        if (object.stakeWithdraw != null) {
                            if (typeof object.stakeWithdraw !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.stakeWithdraw: object expected");
                            message.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.fromObject(object.stakeWithdraw);
                        }
                        if (object.stakeAddDeposit != null) {
                            if (typeof object.stakeAddDeposit !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.stakeAddDeposit: object expected");
                            message.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.fromObject(object.stakeAddDeposit);
                        }
                        if (object.stakeRestake != null) {
                            if (typeof object.stakeRestake !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.stakeRestake: object expected");
                            message.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.fromObject(object.stakeRestake);
                        }
                        if (object.stakeChangeCandidate != null) {
                            if (typeof object.stakeChangeCandidate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.stakeChangeCandidate: object expected");
                            message.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.fromObject(object.stakeChangeCandidate);
                        }
                        if (object.stakeTransferOwnership != null) {
                            if (typeof object.stakeTransferOwnership !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.stakeTransferOwnership: object expected");
                            message.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.fromObject(object.stakeTransferOwnership);
                        }
                        if (object.candidateRegister != null) {
                            if (typeof object.candidateRegister !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.candidateRegister: object expected");
                            message.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.fromObject(object.candidateRegister);
                        }
                        if (object.candidateUpdate != null) {
                            if (typeof object.candidateUpdate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.candidateUpdate: object expected");
                            message.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.fromObject(object.candidateUpdate);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {TW.IoTeX.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.version = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            object.gasPrice = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = message.gasPrice;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.IoTeX.Proto.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.action = "transfer";
                        }
                        if (message.call != null && message.hasOwnProperty("call")) {
                            object.call = $root.TW.IoTeX.Proto.ContractCall.toObject(message.call, options);
                            if (options.oneofs)
                                object.action = "call";
                        }
                        if (message.stakeCreate != null && message.hasOwnProperty("stakeCreate")) {
                            object.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.toObject(message.stakeCreate, options);
                            if (options.oneofs)
                                object.action = "stakeCreate";
                        }
                        if (message.stakeUnstake != null && message.hasOwnProperty("stakeUnstake")) {
                            object.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.toObject(message.stakeUnstake, options);
                            if (options.oneofs)
                                object.action = "stakeUnstake";
                        }
                        if (message.stakeWithdraw != null && message.hasOwnProperty("stakeWithdraw")) {
                            object.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.toObject(message.stakeWithdraw, options);
                            if (options.oneofs)
                                object.action = "stakeWithdraw";
                        }
                        if (message.stakeAddDeposit != null && message.hasOwnProperty("stakeAddDeposit")) {
                            object.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.toObject(message.stakeAddDeposit, options);
                            if (options.oneofs)
                                object.action = "stakeAddDeposit";
                        }
                        if (message.stakeRestake != null && message.hasOwnProperty("stakeRestake")) {
                            object.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.toObject(message.stakeRestake, options);
                            if (options.oneofs)
                                object.action = "stakeRestake";
                        }
                        if (message.stakeChangeCandidate != null && message.hasOwnProperty("stakeChangeCandidate")) {
                            object.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.toObject(message.stakeChangeCandidate, options);
                            if (options.oneofs)
                                object.action = "stakeChangeCandidate";
                        }
                        if (message.stakeTransferOwnership != null && message.hasOwnProperty("stakeTransferOwnership")) {
                            object.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.toObject(message.stakeTransferOwnership, options);
                            if (options.oneofs)
                                object.action = "stakeTransferOwnership";
                        }
                        if (message.candidateRegister != null && message.hasOwnProperty("candidateRegister")) {
                            object.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.toObject(message.candidateRegister, options);
                            if (options.oneofs)
                                object.action = "candidateRegister";
                        }
                        if (message.candidateUpdate != null && message.hasOwnProperty("candidateUpdate")) {
                            object.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.toObject(message.candidateUpdate, options);
                            if (options.oneofs)
                                object.action = "candidateUpdate";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.IoTeX.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [hash] SigningOutput hash
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.IoTeX.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.IoTeX.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.hash = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {TW.IoTeX.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.ActionCore = (function() {
    
                    /**
                     * Properties of an ActionCore.
                     * @memberof TW.IoTeX.Proto
                     * @interface IActionCore
                     * @property {number|null} [version] ActionCore version
                     * @property {Long|null} [nonce] ActionCore nonce
                     * @property {Long|null} [gasLimit] ActionCore gasLimit
                     * @property {string|null} [gasPrice] ActionCore gasPrice
                     * @property {TW.IoTeX.Proto.ITransfer|null} [transfer] ActionCore transfer
                     * @property {TW.IoTeX.Proto.IContractCall|null} [execution] ActionCore execution
                     * @property {TW.IoTeX.Proto.Staking.ICreate|null} [stakeCreate] ActionCore stakeCreate
                     * @property {TW.IoTeX.Proto.Staking.IReclaim|null} [stakeUnstake] ActionCore stakeUnstake
                     * @property {TW.IoTeX.Proto.Staking.IReclaim|null} [stakeWithdraw] ActionCore stakeWithdraw
                     * @property {TW.IoTeX.Proto.Staking.IAddDeposit|null} [stakeAddDeposit] ActionCore stakeAddDeposit
                     * @property {TW.IoTeX.Proto.Staking.IRestake|null} [stakeRestake] ActionCore stakeRestake
                     * @property {TW.IoTeX.Proto.Staking.IChangeCandidate|null} [stakeChangeCandidate] ActionCore stakeChangeCandidate
                     * @property {TW.IoTeX.Proto.Staking.ITransferOwnership|null} [stakeTransferOwnership] ActionCore stakeTransferOwnership
                     * @property {TW.IoTeX.Proto.Staking.ICandidateRegister|null} [candidateRegister] ActionCore candidateRegister
                     * @property {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null} [candidateUpdate] ActionCore candidateUpdate
                     */
    
                    /**
                     * Constructs a new ActionCore.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents an ActionCore.
                     * @implements IActionCore
                     * @constructor
                     * @param {TW.IoTeX.Proto.IActionCore=} [properties] Properties to set
                     */
                    function ActionCore(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ActionCore version.
                     * @member {number} version
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.version = 0;
    
                    /**
                     * ActionCore nonce.
                     * @member {Long} nonce
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ActionCore gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ActionCore gasPrice.
                     * @member {string} gasPrice
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.gasPrice = "";
    
                    /**
                     * ActionCore transfer.
                     * @member {TW.IoTeX.Proto.ITransfer|null|undefined} transfer
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.transfer = null;
    
                    /**
                     * ActionCore execution.
                     * @member {TW.IoTeX.Proto.IContractCall|null|undefined} execution
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.execution = null;
    
                    /**
                     * ActionCore stakeCreate.
                     * @member {TW.IoTeX.Proto.Staking.ICreate|null|undefined} stakeCreate
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.stakeCreate = null;
    
                    /**
                     * ActionCore stakeUnstake.
                     * @member {TW.IoTeX.Proto.Staking.IReclaim|null|undefined} stakeUnstake
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.stakeUnstake = null;
    
                    /**
                     * ActionCore stakeWithdraw.
                     * @member {TW.IoTeX.Proto.Staking.IReclaim|null|undefined} stakeWithdraw
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.stakeWithdraw = null;
    
                    /**
                     * ActionCore stakeAddDeposit.
                     * @member {TW.IoTeX.Proto.Staking.IAddDeposit|null|undefined} stakeAddDeposit
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.stakeAddDeposit = null;
    
                    /**
                     * ActionCore stakeRestake.
                     * @member {TW.IoTeX.Proto.Staking.IRestake|null|undefined} stakeRestake
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.stakeRestake = null;
    
                    /**
                     * ActionCore stakeChangeCandidate.
                     * @member {TW.IoTeX.Proto.Staking.IChangeCandidate|null|undefined} stakeChangeCandidate
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.stakeChangeCandidate = null;
    
                    /**
                     * ActionCore stakeTransferOwnership.
                     * @member {TW.IoTeX.Proto.Staking.ITransferOwnership|null|undefined} stakeTransferOwnership
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.stakeTransferOwnership = null;
    
                    /**
                     * ActionCore candidateRegister.
                     * @member {TW.IoTeX.Proto.Staking.ICandidateRegister|null|undefined} candidateRegister
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.candidateRegister = null;
    
                    /**
                     * ActionCore candidateUpdate.
                     * @member {TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null|undefined} candidateUpdate
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.candidateUpdate = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * ActionCore action.
                     * @member {"transfer"|"execution"|"stakeCreate"|"stakeUnstake"|"stakeWithdraw"|"stakeAddDeposit"|"stakeRestake"|"stakeChangeCandidate"|"stakeTransferOwnership"|"candidateRegister"|"candidateUpdate"|undefined} action
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    Object.defineProperty(ActionCore.prototype, "action", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "execution", "stakeCreate", "stakeUnstake", "stakeWithdraw", "stakeAddDeposit", "stakeRestake", "stakeChangeCandidate", "stakeTransferOwnership", "candidateRegister", "candidateUpdate"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new ActionCore instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {TW.IoTeX.Proto.IActionCore=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.ActionCore} ActionCore instance
                     */
                    ActionCore.create = function create(properties) {
                        return new ActionCore(properties);
                    };
    
                    /**
                     * Encodes the specified ActionCore message. Does not implicitly {@link TW.IoTeX.Proto.ActionCore.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {TW.IoTeX.Proto.IActionCore} message ActionCore message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ActionCore.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.gasLimit);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.gasPrice);
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.IoTeX.Proto.Transfer.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.execution != null && Object.hasOwnProperty.call(message, "execution"))
                            $root.TW.IoTeX.Proto.ContractCall.encode(message.execution, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.stakeCreate != null && Object.hasOwnProperty.call(message, "stakeCreate"))
                            $root.TW.IoTeX.Proto.Staking.Create.encode(message.stakeCreate, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                        if (message.stakeUnstake != null && Object.hasOwnProperty.call(message, "stakeUnstake"))
                            $root.TW.IoTeX.Proto.Staking.Reclaim.encode(message.stakeUnstake, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                        if (message.stakeWithdraw != null && Object.hasOwnProperty.call(message, "stakeWithdraw"))
                            $root.TW.IoTeX.Proto.Staking.Reclaim.encode(message.stakeWithdraw, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
                        if (message.stakeAddDeposit != null && Object.hasOwnProperty.call(message, "stakeAddDeposit"))
                            $root.TW.IoTeX.Proto.Staking.AddDeposit.encode(message.stakeAddDeposit, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
                        if (message.stakeRestake != null && Object.hasOwnProperty.call(message, "stakeRestake"))
                            $root.TW.IoTeX.Proto.Staking.Restake.encode(message.stakeRestake, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
                        if (message.stakeChangeCandidate != null && Object.hasOwnProperty.call(message, "stakeChangeCandidate"))
                            $root.TW.IoTeX.Proto.Staking.ChangeCandidate.encode(message.stakeChangeCandidate, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
                        if (message.stakeTransferOwnership != null && Object.hasOwnProperty.call(message, "stakeTransferOwnership"))
                            $root.TW.IoTeX.Proto.Staking.TransferOwnership.encode(message.stakeTransferOwnership, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
                        if (message.candidateRegister != null && Object.hasOwnProperty.call(message, "candidateRegister"))
                            $root.TW.IoTeX.Proto.Staking.CandidateRegister.encode(message.candidateRegister, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
                        if (message.candidateUpdate != null && Object.hasOwnProperty.call(message, "candidateUpdate"))
                            $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.encode(message.candidateUpdate, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an ActionCore message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.ActionCore} ActionCore
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ActionCore.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.ActionCore();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            case 2:
                                message.nonce = reader.uint64();
                                break;
                            case 3:
                                message.gasLimit = reader.uint64();
                                break;
                            case 4:
                                message.gasPrice = reader.string();
                                break;
                            case 10:
                                message.transfer = $root.TW.IoTeX.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.execution = $root.TW.IoTeX.Proto.ContractCall.decode(reader, reader.uint32());
                                break;
                            case 40:
                                message.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.decode(reader, reader.uint32());
                                break;
                            case 41:
                                message.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.decode(reader, reader.uint32());
                                break;
                            case 42:
                                message.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.decode(reader, reader.uint32());
                                break;
                            case 43:
                                message.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.decode(reader, reader.uint32());
                                break;
                            case 44:
                                message.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.decode(reader, reader.uint32());
                                break;
                            case 45:
                                message.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.decode(reader, reader.uint32());
                                break;
                            case 46:
                                message.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.decode(reader, reader.uint32());
                                break;
                            case 47:
                                message.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.decode(reader, reader.uint32());
                                break;
                            case 48:
                                message.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an ActionCore message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ActionCore.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isString(message.gasPrice))
                                return "gasPrice: string expected";
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.execution != null && message.hasOwnProperty("execution")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.ContractCall.verify(message.execution);
                                if (error)
                                    return "execution." + error;
                            }
                        }
                        if (message.stakeCreate != null && message.hasOwnProperty("stakeCreate")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Create.verify(message.stakeCreate);
                                if (error)
                                    return "stakeCreate." + error;
                            }
                        }
                        if (message.stakeUnstake != null && message.hasOwnProperty("stakeUnstake")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Reclaim.verify(message.stakeUnstake);
                                if (error)
                                    return "stakeUnstake." + error;
                            }
                        }
                        if (message.stakeWithdraw != null && message.hasOwnProperty("stakeWithdraw")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Reclaim.verify(message.stakeWithdraw);
                                if (error)
                                    return "stakeWithdraw." + error;
                            }
                        }
                        if (message.stakeAddDeposit != null && message.hasOwnProperty("stakeAddDeposit")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.AddDeposit.verify(message.stakeAddDeposit);
                                if (error)
                                    return "stakeAddDeposit." + error;
                            }
                        }
                        if (message.stakeRestake != null && message.hasOwnProperty("stakeRestake")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.Restake.verify(message.stakeRestake);
                                if (error)
                                    return "stakeRestake." + error;
                            }
                        }
                        if (message.stakeChangeCandidate != null && message.hasOwnProperty("stakeChangeCandidate")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.verify(message.stakeChangeCandidate);
                                if (error)
                                    return "stakeChangeCandidate." + error;
                            }
                        }
                        if (message.stakeTransferOwnership != null && message.hasOwnProperty("stakeTransferOwnership")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.TransferOwnership.verify(message.stakeTransferOwnership);
                                if (error)
                                    return "stakeTransferOwnership." + error;
                            }
                        }
                        if (message.candidateRegister != null && message.hasOwnProperty("candidateRegister")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.CandidateRegister.verify(message.candidateRegister);
                                if (error)
                                    return "candidateRegister." + error;
                            }
                        }
                        if (message.candidateUpdate != null && message.hasOwnProperty("candidateUpdate")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.verify(message.candidateUpdate);
                                if (error)
                                    return "candidateUpdate." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an ActionCore message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.ActionCore} ActionCore
                     */
                    ActionCore.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.ActionCore)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.ActionCore();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.gasPrice != null)
                            message.gasPrice = String(object.gasPrice);
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.transfer: object expected");
                            message.transfer = $root.TW.IoTeX.Proto.Transfer.fromObject(object.transfer);
                        }
                        if (object.execution != null) {
                            if (typeof object.execution !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.execution: object expected");
                            message.execution = $root.TW.IoTeX.Proto.ContractCall.fromObject(object.execution);
                        }
                        if (object.stakeCreate != null) {
                            if (typeof object.stakeCreate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.stakeCreate: object expected");
                            message.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.fromObject(object.stakeCreate);
                        }
                        if (object.stakeUnstake != null) {
                            if (typeof object.stakeUnstake !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.stakeUnstake: object expected");
                            message.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.fromObject(object.stakeUnstake);
                        }
                        if (object.stakeWithdraw != null) {
                            if (typeof object.stakeWithdraw !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.stakeWithdraw: object expected");
                            message.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.fromObject(object.stakeWithdraw);
                        }
                        if (object.stakeAddDeposit != null) {
                            if (typeof object.stakeAddDeposit !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.stakeAddDeposit: object expected");
                            message.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.fromObject(object.stakeAddDeposit);
                        }
                        if (object.stakeRestake != null) {
                            if (typeof object.stakeRestake !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.stakeRestake: object expected");
                            message.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.fromObject(object.stakeRestake);
                        }
                        if (object.stakeChangeCandidate != null) {
                            if (typeof object.stakeChangeCandidate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.stakeChangeCandidate: object expected");
                            message.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.fromObject(object.stakeChangeCandidate);
                        }
                        if (object.stakeTransferOwnership != null) {
                            if (typeof object.stakeTransferOwnership !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.stakeTransferOwnership: object expected");
                            message.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.fromObject(object.stakeTransferOwnership);
                        }
                        if (object.candidateRegister != null) {
                            if (typeof object.candidateRegister !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.candidateRegister: object expected");
                            message.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.fromObject(object.candidateRegister);
                        }
                        if (object.candidateUpdate != null) {
                            if (typeof object.candidateUpdate !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.candidateUpdate: object expected");
                            message.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.fromObject(object.candidateUpdate);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ActionCore message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {TW.IoTeX.Proto.ActionCore} message ActionCore
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ActionCore.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.version = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            object.gasPrice = "";
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = message.gasPrice;
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.IoTeX.Proto.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.action = "transfer";
                        }
                        if (message.execution != null && message.hasOwnProperty("execution")) {
                            object.execution = $root.TW.IoTeX.Proto.ContractCall.toObject(message.execution, options);
                            if (options.oneofs)
                                object.action = "execution";
                        }
                        if (message.stakeCreate != null && message.hasOwnProperty("stakeCreate")) {
                            object.stakeCreate = $root.TW.IoTeX.Proto.Staking.Create.toObject(message.stakeCreate, options);
                            if (options.oneofs)
                                object.action = "stakeCreate";
                        }
                        if (message.stakeUnstake != null && message.hasOwnProperty("stakeUnstake")) {
                            object.stakeUnstake = $root.TW.IoTeX.Proto.Staking.Reclaim.toObject(message.stakeUnstake, options);
                            if (options.oneofs)
                                object.action = "stakeUnstake";
                        }
                        if (message.stakeWithdraw != null && message.hasOwnProperty("stakeWithdraw")) {
                            object.stakeWithdraw = $root.TW.IoTeX.Proto.Staking.Reclaim.toObject(message.stakeWithdraw, options);
                            if (options.oneofs)
                                object.action = "stakeWithdraw";
                        }
                        if (message.stakeAddDeposit != null && message.hasOwnProperty("stakeAddDeposit")) {
                            object.stakeAddDeposit = $root.TW.IoTeX.Proto.Staking.AddDeposit.toObject(message.stakeAddDeposit, options);
                            if (options.oneofs)
                                object.action = "stakeAddDeposit";
                        }
                        if (message.stakeRestake != null && message.hasOwnProperty("stakeRestake")) {
                            object.stakeRestake = $root.TW.IoTeX.Proto.Staking.Restake.toObject(message.stakeRestake, options);
                            if (options.oneofs)
                                object.action = "stakeRestake";
                        }
                        if (message.stakeChangeCandidate != null && message.hasOwnProperty("stakeChangeCandidate")) {
                            object.stakeChangeCandidate = $root.TW.IoTeX.Proto.Staking.ChangeCandidate.toObject(message.stakeChangeCandidate, options);
                            if (options.oneofs)
                                object.action = "stakeChangeCandidate";
                        }
                        if (message.stakeTransferOwnership != null && message.hasOwnProperty("stakeTransferOwnership")) {
                            object.stakeTransferOwnership = $root.TW.IoTeX.Proto.Staking.TransferOwnership.toObject(message.stakeTransferOwnership, options);
                            if (options.oneofs)
                                object.action = "stakeTransferOwnership";
                        }
                        if (message.candidateRegister != null && message.hasOwnProperty("candidateRegister")) {
                            object.candidateRegister = $root.TW.IoTeX.Proto.Staking.CandidateRegister.toObject(message.candidateRegister, options);
                            if (options.oneofs)
                                object.action = "candidateRegister";
                        }
                        if (message.candidateUpdate != null && message.hasOwnProperty("candidateUpdate")) {
                            object.candidateUpdate = $root.TW.IoTeX.Proto.Staking.CandidateBasicInfo.toObject(message.candidateUpdate, options);
                            if (options.oneofs)
                                object.action = "candidateUpdate";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this ActionCore to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ActionCore.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ActionCore;
                })();
    
                Proto.Action = (function() {
    
                    /**
                     * Properties of an Action.
                     * @memberof TW.IoTeX.Proto
                     * @interface IAction
                     * @property {TW.IoTeX.Proto.IActionCore|null} [core] Action core
                     * @property {Uint8Array|null} [senderPubKey] Action senderPubKey
                     * @property {Uint8Array|null} [signature] Action signature
                     */
    
                    /**
                     * Constructs a new Action.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents an Action.
                     * @implements IAction
                     * @constructor
                     * @param {TW.IoTeX.Proto.IAction=} [properties] Properties to set
                     */
                    function Action(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Action core.
                     * @member {TW.IoTeX.Proto.IActionCore|null|undefined} core
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     */
                    Action.prototype.core = null;
    
                    /**
                     * Action senderPubKey.
                     * @member {Uint8Array} senderPubKey
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     */
                    Action.prototype.senderPubKey = $util.newBuffer([]);
    
                    /**
                     * Action signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     */
                    Action.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new Action instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {TW.IoTeX.Proto.IAction=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.Action} Action instance
                     */
                    Action.create = function create(properties) {
                        return new Action(properties);
                    };
    
                    /**
                     * Encodes the specified Action message. Does not implicitly {@link TW.IoTeX.Proto.Action.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {TW.IoTeX.Proto.IAction} message Action message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Action.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.core != null && Object.hasOwnProperty.call(message, "core"))
                            $root.TW.IoTeX.Proto.ActionCore.encode(message.core, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.senderPubKey != null && Object.hasOwnProperty.call(message, "senderPubKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPubKey);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes an Action message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.Action} Action
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Action.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Action();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.core = $root.TW.IoTeX.Proto.ActionCore.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.senderPubKey = reader.bytes();
                                break;
                            case 3:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Action message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Action.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.core != null && message.hasOwnProperty("core")) {
                            var error = $root.TW.IoTeX.Proto.ActionCore.verify(message.core);
                            if (error)
                                return "core." + error;
                        }
                        if (message.senderPubKey != null && message.hasOwnProperty("senderPubKey"))
                            if (!(message.senderPubKey && typeof message.senderPubKey.length === "number" || $util.isString(message.senderPubKey)))
                                return "senderPubKey: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates an Action message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.Action} Action
                     */
                    Action.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.Action)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.Action();
                        if (object.core != null) {
                            if (typeof object.core !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Action.core: object expected");
                            message.core = $root.TW.IoTeX.Proto.ActionCore.fromObject(object.core);
                        }
                        if (object.senderPubKey != null)
                            if (typeof object.senderPubKey === "string")
                                $util.base64.decode(object.senderPubKey, message.senderPubKey = $util.newBuffer($util.base64.length(object.senderPubKey)), 0);
                            else if (object.senderPubKey.length)
                                message.senderPubKey = object.senderPubKey;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Action message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {TW.IoTeX.Proto.Action} message Action
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Action.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.core = null;
                            if (options.bytes === String)
                                object.senderPubKey = "";
                            else {
                                object.senderPubKey = [];
                                if (options.bytes !== Array)
                                    object.senderPubKey = $util.newBuffer(object.senderPubKey);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.core != null && message.hasOwnProperty("core"))
                            object.core = $root.TW.IoTeX.Proto.ActionCore.toObject(message.core, options);
                        if (message.senderPubKey != null && message.hasOwnProperty("senderPubKey"))
                            object.senderPubKey = options.bytes === String ? $util.base64.encode(message.senderPubKey, 0, message.senderPubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPubKey) : message.senderPubKey;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this Action to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Action.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Action;
                })();
    
                return Proto;
            })();
    
            return IoTeX;
        })();
    
        TW.Nano = (function() {
    
            /**
             * Namespace Nano.
             * @memberof TW
             * @namespace
             */
            var Nano = {};
    
            Nano.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Nano
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Nano.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {Uint8Array|null} [parentBlock] SigningInput parentBlock
                     * @property {Uint8Array|null} [linkBlock] SigningInput linkBlock
                     * @property {string|null} [linkRecipient] SigningInput linkRecipient
                     * @property {string|null} [representative] SigningInput representative
                     * @property {string|null} [balance] SigningInput balance
                     * @property {string|null} [work] SigningInput work
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Nano.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Nano.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput parentBlock.
                     * @member {Uint8Array} parentBlock
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.parentBlock = $util.newBuffer([]);
    
                    /**
                     * SigningInput linkBlock.
                     * @member {Uint8Array|null|undefined} linkBlock
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.linkBlock = null;
    
                    /**
                     * SigningInput linkRecipient.
                     * @member {string|null|undefined} linkRecipient
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.linkRecipient = null;
    
                    /**
                     * SigningInput representative.
                     * @member {string} representative
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.representative = "";
    
                    /**
                     * SigningInput balance.
                     * @member {string} balance
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.balance = "";
    
                    /**
                     * SigningInput work.
                     * @member {string} work
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.work = "";
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput linkOneof.
                     * @member {"linkBlock"|"linkRecipient"|undefined} linkOneof
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "linkOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["linkBlock", "linkRecipient"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {TW.Nano.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Nano.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nano.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {TW.Nano.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.parentBlock != null && Object.hasOwnProperty.call(message, "parentBlock"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.parentBlock);
                        if (message.linkBlock != null && Object.hasOwnProperty.call(message, "linkBlock"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.linkBlock);
                        if (message.linkRecipient != null && Object.hasOwnProperty.call(message, "linkRecipient"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.linkRecipient);
                        if (message.representative != null && Object.hasOwnProperty.call(message, "representative"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.representative);
                        if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.balance);
                        if (message.work != null && Object.hasOwnProperty.call(message, "work"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.work);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nano.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nano.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.parentBlock = reader.bytes();
                                break;
                            case 3:
                                message.linkBlock = reader.bytes();
                                break;
                            case 4:
                                message.linkRecipient = reader.string();
                                break;
                            case 5:
                                message.representative = reader.string();
                                break;
                            case 6:
                                message.balance = reader.string();
                                break;
                            case 7:
                                message.work = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.parentBlock != null && message.hasOwnProperty("parentBlock"))
                            if (!(message.parentBlock && typeof message.parentBlock.length === "number" || $util.isString(message.parentBlock)))
                                return "parentBlock: buffer expected";
                        if (message.linkBlock != null && message.hasOwnProperty("linkBlock")) {
                            properties.linkOneof = 1;
                            if (!(message.linkBlock && typeof message.linkBlock.length === "number" || $util.isString(message.linkBlock)))
                                return "linkBlock: buffer expected";
                        }
                        if (message.linkRecipient != null && message.hasOwnProperty("linkRecipient")) {
                            if (properties.linkOneof === 1)
                                return "linkOneof: multiple values";
                            properties.linkOneof = 1;
                            if (!$util.isString(message.linkRecipient))
                                return "linkRecipient: string expected";
                        }
                        if (message.representative != null && message.hasOwnProperty("representative"))
                            if (!$util.isString(message.representative))
                                return "representative: string expected";
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            if (!$util.isString(message.balance))
                                return "balance: string expected";
                        if (message.work != null && message.hasOwnProperty("work"))
                            if (!$util.isString(message.work))
                                return "work: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nano.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nano.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Nano.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.parentBlock != null)
                            if (typeof object.parentBlock === "string")
                                $util.base64.decode(object.parentBlock, message.parentBlock = $util.newBuffer($util.base64.length(object.parentBlock)), 0);
                            else if (object.parentBlock.length)
                                message.parentBlock = object.parentBlock;
                        if (object.linkBlock != null)
                            if (typeof object.linkBlock === "string")
                                $util.base64.decode(object.linkBlock, message.linkBlock = $util.newBuffer($util.base64.length(object.linkBlock)), 0);
                            else if (object.linkBlock.length)
                                message.linkBlock = object.linkBlock;
                        if (object.linkRecipient != null)
                            message.linkRecipient = String(object.linkRecipient);
                        if (object.representative != null)
                            message.representative = String(object.representative);
                        if (object.balance != null)
                            message.balance = String(object.balance);
                        if (object.work != null)
                            message.work = String(object.work);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {TW.Nano.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            if (options.bytes === String)
                                object.parentBlock = "";
                            else {
                                object.parentBlock = [];
                                if (options.bytes !== Array)
                                    object.parentBlock = $util.newBuffer(object.parentBlock);
                            }
                            object.representative = "";
                            object.balance = "";
                            object.work = "";
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.parentBlock != null && message.hasOwnProperty("parentBlock"))
                            object.parentBlock = options.bytes === String ? $util.base64.encode(message.parentBlock, 0, message.parentBlock.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentBlock) : message.parentBlock;
                        if (message.linkBlock != null && message.hasOwnProperty("linkBlock")) {
                            object.linkBlock = options.bytes === String ? $util.base64.encode(message.linkBlock, 0, message.linkBlock.length) : options.bytes === Array ? Array.prototype.slice.call(message.linkBlock) : message.linkBlock;
                            if (options.oneofs)
                                object.linkOneof = "linkBlock";
                        }
                        if (message.linkRecipient != null && message.hasOwnProperty("linkRecipient")) {
                            object.linkRecipient = message.linkRecipient;
                            if (options.oneofs)
                                object.linkOneof = "linkRecipient";
                        }
                        if (message.representative != null && message.hasOwnProperty("representative"))
                            object.representative = message.representative;
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            object.balance = message.balance;
                        if (message.work != null && message.hasOwnProperty("work"))
                            object.work = message.work;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Nano.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {Uint8Array|null} [blockHash] SigningOutput blockHash
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Nano.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Nano.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput blockHash.
                     * @member {Uint8Array} blockHash
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.blockHash = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {TW.Nano.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Nano.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nano.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {TW.Nano.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.blockHash != null && Object.hasOwnProperty.call(message, "blockHash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blockHash);
                        if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nano.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nano.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.blockHash = reader.bytes();
                                break;
                            case 3:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                                return "blockHash: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nano.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nano.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Nano.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.blockHash != null)
                            if (typeof object.blockHash === "string")
                                $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                            else if (object.blockHash.length)
                                message.blockHash = object.blockHash;
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {TW.Nano.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            if (options.bytes === String)
                                object.blockHash = "";
                            else {
                                object.blockHash = [];
                                if (options.bytes !== Array)
                                    object.blockHash = $util.newBuffer(object.blockHash);
                            }
                            object.json = "";
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Nano;
        })();
    
        TW.NEAR = (function() {
    
            /**
             * Namespace NEAR.
             * @memberof TW
             * @namespace
             */
            var NEAR = {};
    
            NEAR.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.NEAR
                 * @namespace
                 */
                var Proto = {};
    
                Proto.PublicKey = (function() {
    
                    /**
                     * Properties of a PublicKey.
                     * @memberof TW.NEAR.Proto
                     * @interface IPublicKey
                     * @property {number|null} [keyType] PublicKey keyType
                     * @property {Uint8Array|null} [data] PublicKey data
                     */
    
                    /**
                     * Constructs a new PublicKey.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a PublicKey.
                     * @implements IPublicKey
                     * @constructor
                     * @param {TW.NEAR.Proto.IPublicKey=} [properties] Properties to set
                     */
                    function PublicKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * PublicKey keyType.
                     * @member {number} keyType
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @instance
                     */
                    PublicKey.prototype.keyType = 0;
    
                    /**
                     * PublicKey data.
                     * @member {Uint8Array} data
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @instance
                     */
                    PublicKey.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new PublicKey instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @static
                     * @param {TW.NEAR.Proto.IPublicKey=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.PublicKey} PublicKey instance
                     */
                    PublicKey.create = function create(properties) {
                        return new PublicKey(properties);
                    };
    
                    /**
                     * Encodes the specified PublicKey message. Does not implicitly {@link TW.NEAR.Proto.PublicKey.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @static
                     * @param {TW.NEAR.Proto.IPublicKey} message PublicKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PublicKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.keyType);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Decodes a PublicKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.PublicKey} PublicKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PublicKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.PublicKey();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.keyType = reader.uint32();
                                break;
                            case 2:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a PublicKey message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PublicKey.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.keyType != null && message.hasOwnProperty("keyType"))
                            if (!$util.isInteger(message.keyType))
                                return "keyType: integer expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.PublicKey} PublicKey
                     */
                    PublicKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.PublicKey)
                            return object;
                        var message = new $root.TW.NEAR.Proto.PublicKey();
                        if (object.keyType != null)
                            message.keyType = object.keyType >>> 0;
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a PublicKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @static
                     * @param {TW.NEAR.Proto.PublicKey} message PublicKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PublicKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.keyType = 0;
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.keyType != null && message.hasOwnProperty("keyType"))
                            object.keyType = message.keyType;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this PublicKey to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.PublicKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PublicKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PublicKey;
                })();
    
                Proto.FunctionCallPermission = (function() {
    
                    /**
                     * Properties of a FunctionCallPermission.
                     * @memberof TW.NEAR.Proto
                     * @interface IFunctionCallPermission
                     * @property {Uint8Array|null} [allowance] FunctionCallPermission allowance
                     * @property {string|null} [receiverId] FunctionCallPermission receiverId
                     */
    
                    /**
                     * Constructs a new FunctionCallPermission.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a FunctionCallPermission.
                     * @implements IFunctionCallPermission
                     * @constructor
                     * @param {TW.NEAR.Proto.IFunctionCallPermission=} [properties] Properties to set
                     */
                    function FunctionCallPermission(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * FunctionCallPermission allowance.
                     * @member {Uint8Array} allowance
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @instance
                     */
                    FunctionCallPermission.prototype.allowance = $util.newBuffer([]);
    
                    /**
                     * FunctionCallPermission receiverId.
                     * @member {string} receiverId
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @instance
                     */
                    FunctionCallPermission.prototype.receiverId = "";
    
                    /**
                     * Creates a new FunctionCallPermission instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @static
                     * @param {TW.NEAR.Proto.IFunctionCallPermission=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.FunctionCallPermission} FunctionCallPermission instance
                     */
                    FunctionCallPermission.create = function create(properties) {
                        return new FunctionCallPermission(properties);
                    };
    
                    /**
                     * Encodes the specified FunctionCallPermission message. Does not implicitly {@link TW.NEAR.Proto.FunctionCallPermission.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @static
                     * @param {TW.NEAR.Proto.IFunctionCallPermission} message FunctionCallPermission message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FunctionCallPermission.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.allowance != null && Object.hasOwnProperty.call(message, "allowance"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.allowance);
                        if (message.receiverId != null && Object.hasOwnProperty.call(message, "receiverId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.receiverId);
                        return writer;
                    };
    
                    /**
                     * Decodes a FunctionCallPermission message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.FunctionCallPermission} FunctionCallPermission
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FunctionCallPermission.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.FunctionCallPermission();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.allowance = reader.bytes();
                                break;
                            case 2:
                                message.receiverId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a FunctionCallPermission message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FunctionCallPermission.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.allowance != null && message.hasOwnProperty("allowance"))
                            if (!(message.allowance && typeof message.allowance.length === "number" || $util.isString(message.allowance)))
                                return "allowance: buffer expected";
                        if (message.receiverId != null && message.hasOwnProperty("receiverId"))
                            if (!$util.isString(message.receiverId))
                                return "receiverId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a FunctionCallPermission message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.FunctionCallPermission} FunctionCallPermission
                     */
                    FunctionCallPermission.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.FunctionCallPermission)
                            return object;
                        var message = new $root.TW.NEAR.Proto.FunctionCallPermission();
                        if (object.allowance != null)
                            if (typeof object.allowance === "string")
                                $util.base64.decode(object.allowance, message.allowance = $util.newBuffer($util.base64.length(object.allowance)), 0);
                            else if (object.allowance.length)
                                message.allowance = object.allowance;
                        if (object.receiverId != null)
                            message.receiverId = String(object.receiverId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a FunctionCallPermission message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @static
                     * @param {TW.NEAR.Proto.FunctionCallPermission} message FunctionCallPermission
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FunctionCallPermission.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.allowance = "";
                            else {
                                object.allowance = [];
                                if (options.bytes !== Array)
                                    object.allowance = $util.newBuffer(object.allowance);
                            }
                            object.receiverId = "";
                        }
                        if (message.allowance != null && message.hasOwnProperty("allowance"))
                            object.allowance = options.bytes === String ? $util.base64.encode(message.allowance, 0, message.allowance.length) : options.bytes === Array ? Array.prototype.slice.call(message.allowance) : message.allowance;
                        if (message.receiverId != null && message.hasOwnProperty("receiverId"))
                            object.receiverId = message.receiverId;
                        return object;
                    };
    
                    /**
                     * Converts this FunctionCallPermission to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.FunctionCallPermission
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FunctionCallPermission.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return FunctionCallPermission;
                })();
    
                Proto.FullAccessPermission = (function() {
    
                    /**
                     * Properties of a FullAccessPermission.
                     * @memberof TW.NEAR.Proto
                     * @interface IFullAccessPermission
                     */
    
                    /**
                     * Constructs a new FullAccessPermission.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a FullAccessPermission.
                     * @implements IFullAccessPermission
                     * @constructor
                     * @param {TW.NEAR.Proto.IFullAccessPermission=} [properties] Properties to set
                     */
                    function FullAccessPermission(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new FullAccessPermission instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.FullAccessPermission
                     * @static
                     * @param {TW.NEAR.Proto.IFullAccessPermission=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.FullAccessPermission} FullAccessPermission instance
                     */
                    FullAccessPermission.create = function create(properties) {
                        return new FullAccessPermission(properties);
                    };
    
                    /**
                     * Encodes the specified FullAccessPermission message. Does not implicitly {@link TW.NEAR.Proto.FullAccessPermission.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.FullAccessPermission
                     * @static
                     * @param {TW.NEAR.Proto.IFullAccessPermission} message FullAccessPermission message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FullAccessPermission.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a FullAccessPermission message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.FullAccessPermission
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.FullAccessPermission} FullAccessPermission
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FullAccessPermission.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.FullAccessPermission();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a FullAccessPermission message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.FullAccessPermission
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FullAccessPermission.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a FullAccessPermission message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.FullAccessPermission
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.FullAccessPermission} FullAccessPermission
                     */
                    FullAccessPermission.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.FullAccessPermission)
                            return object;
                        return new $root.TW.NEAR.Proto.FullAccessPermission();
                    };
    
                    /**
                     * Creates a plain object from a FullAccessPermission message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.FullAccessPermission
                     * @static
                     * @param {TW.NEAR.Proto.FullAccessPermission} message FullAccessPermission
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FullAccessPermission.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this FullAccessPermission to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.FullAccessPermission
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FullAccessPermission.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return FullAccessPermission;
                })();
    
                Proto.AccessKey = (function() {
    
                    /**
                     * Properties of an AccessKey.
                     * @memberof TW.NEAR.Proto
                     * @interface IAccessKey
                     * @property {Long|null} [nonce] AccessKey nonce
                     * @property {TW.NEAR.Proto.IFunctionCallPermission|null} [functionCall] AccessKey functionCall
                     * @property {TW.NEAR.Proto.IFullAccessPermission|null} [fullAccess] AccessKey fullAccess
                     */
    
                    /**
                     * Constructs a new AccessKey.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents an AccessKey.
                     * @implements IAccessKey
                     * @constructor
                     * @param {TW.NEAR.Proto.IAccessKey=} [properties] Properties to set
                     */
                    function AccessKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AccessKey nonce.
                     * @member {Long} nonce
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @instance
                     */
                    AccessKey.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * AccessKey functionCall.
                     * @member {TW.NEAR.Proto.IFunctionCallPermission|null|undefined} functionCall
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @instance
                     */
                    AccessKey.prototype.functionCall = null;
    
                    /**
                     * AccessKey fullAccess.
                     * @member {TW.NEAR.Proto.IFullAccessPermission|null|undefined} fullAccess
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @instance
                     */
                    AccessKey.prototype.fullAccess = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * AccessKey permission.
                     * @member {"functionCall"|"fullAccess"|undefined} permission
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @instance
                     */
                    Object.defineProperty(AccessKey.prototype, "permission", {
                        get: $util.oneOfGetter($oneOfFields = ["functionCall", "fullAccess"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new AccessKey instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @static
                     * @param {TW.NEAR.Proto.IAccessKey=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.AccessKey} AccessKey instance
                     */
                    AccessKey.create = function create(properties) {
                        return new AccessKey(properties);
                    };
    
                    /**
                     * Encodes the specified AccessKey message. Does not implicitly {@link TW.NEAR.Proto.AccessKey.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @static
                     * @param {TW.NEAR.Proto.IAccessKey} message AccessKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AccessKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                        if (message.functionCall != null && Object.hasOwnProperty.call(message, "functionCall"))
                            $root.TW.NEAR.Proto.FunctionCallPermission.encode(message.functionCall, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.fullAccess != null && Object.hasOwnProperty.call(message, "fullAccess"))
                            $root.TW.NEAR.Proto.FullAccessPermission.encode(message.fullAccess, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an AccessKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.AccessKey} AccessKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AccessKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.AccessKey();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nonce = reader.uint64();
                                break;
                            case 2:
                                message.functionCall = $root.TW.NEAR.Proto.FunctionCallPermission.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.fullAccess = $root.TW.NEAR.Proto.FullAccessPermission.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an AccessKey message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AccessKey.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.functionCall != null && message.hasOwnProperty("functionCall")) {
                            properties.permission = 1;
                            {
                                var error = $root.TW.NEAR.Proto.FunctionCallPermission.verify(message.functionCall);
                                if (error)
                                    return "functionCall." + error;
                            }
                        }
                        if (message.fullAccess != null && message.hasOwnProperty("fullAccess")) {
                            if (properties.permission === 1)
                                return "permission: multiple values";
                            properties.permission = 1;
                            {
                                var error = $root.TW.NEAR.Proto.FullAccessPermission.verify(message.fullAccess);
                                if (error)
                                    return "fullAccess." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an AccessKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.AccessKey} AccessKey
                     */
                    AccessKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.AccessKey)
                            return object;
                        var message = new $root.TW.NEAR.Proto.AccessKey();
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.functionCall != null) {
                            if (typeof object.functionCall !== "object")
                                throw TypeError(".TW.NEAR.Proto.AccessKey.functionCall: object expected");
                            message.functionCall = $root.TW.NEAR.Proto.FunctionCallPermission.fromObject(object.functionCall);
                        }
                        if (object.fullAccess != null) {
                            if (typeof object.fullAccess !== "object")
                                throw TypeError(".TW.NEAR.Proto.AccessKey.fullAccess: object expected");
                            message.fullAccess = $root.TW.NEAR.Proto.FullAccessPermission.fromObject(object.fullAccess);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an AccessKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @static
                     * @param {TW.NEAR.Proto.AccessKey} message AccessKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AccessKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.functionCall != null && message.hasOwnProperty("functionCall")) {
                            object.functionCall = $root.TW.NEAR.Proto.FunctionCallPermission.toObject(message.functionCall, options);
                            if (options.oneofs)
                                object.permission = "functionCall";
                        }
                        if (message.fullAccess != null && message.hasOwnProperty("fullAccess")) {
                            object.fullAccess = $root.TW.NEAR.Proto.FullAccessPermission.toObject(message.fullAccess, options);
                            if (options.oneofs)
                                object.permission = "fullAccess";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this AccessKey to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.AccessKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AccessKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return AccessKey;
                })();
    
                Proto.CreateAccount = (function() {
    
                    /**
                     * Properties of a CreateAccount.
                     * @memberof TW.NEAR.Proto
                     * @interface ICreateAccount
                     */
    
                    /**
                     * Constructs a new CreateAccount.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a CreateAccount.
                     * @implements ICreateAccount
                     * @constructor
                     * @param {TW.NEAR.Proto.ICreateAccount=} [properties] Properties to set
                     */
                    function CreateAccount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new CreateAccount instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.CreateAccount
                     * @static
                     * @param {TW.NEAR.Proto.ICreateAccount=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.CreateAccount} CreateAccount instance
                     */
                    CreateAccount.create = function create(properties) {
                        return new CreateAccount(properties);
                    };
    
                    /**
                     * Encodes the specified CreateAccount message. Does not implicitly {@link TW.NEAR.Proto.CreateAccount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.CreateAccount
                     * @static
                     * @param {TW.NEAR.Proto.ICreateAccount} message CreateAccount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateAccount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a CreateAccount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.CreateAccount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.CreateAccount} CreateAccount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateAccount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.CreateAccount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a CreateAccount message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.CreateAccount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateAccount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a CreateAccount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.CreateAccount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.CreateAccount} CreateAccount
                     */
                    CreateAccount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.CreateAccount)
                            return object;
                        return new $root.TW.NEAR.Proto.CreateAccount();
                    };
    
                    /**
                     * Creates a plain object from a CreateAccount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.CreateAccount
                     * @static
                     * @param {TW.NEAR.Proto.CreateAccount} message CreateAccount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateAccount.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this CreateAccount to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.CreateAccount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateAccount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CreateAccount;
                })();
    
                Proto.DeployContract = (function() {
    
                    /**
                     * Properties of a DeployContract.
                     * @memberof TW.NEAR.Proto
                     * @interface IDeployContract
                     * @property {Uint8Array|null} [code] DeployContract code
                     */
    
                    /**
                     * Constructs a new DeployContract.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a DeployContract.
                     * @implements IDeployContract
                     * @constructor
                     * @param {TW.NEAR.Proto.IDeployContract=} [properties] Properties to set
                     */
                    function DeployContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DeployContract code.
                     * @member {Uint8Array} code
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @instance
                     */
                    DeployContract.prototype.code = $util.newBuffer([]);
    
                    /**
                     * Creates a new DeployContract instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @static
                     * @param {TW.NEAR.Proto.IDeployContract=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.DeployContract} DeployContract instance
                     */
                    DeployContract.create = function create(properties) {
                        return new DeployContract(properties);
                    };
    
                    /**
                     * Encodes the specified DeployContract message. Does not implicitly {@link TW.NEAR.Proto.DeployContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @static
                     * @param {TW.NEAR.Proto.IDeployContract} message DeployContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DeployContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.code);
                        return writer;
                    };
    
                    /**
                     * Decodes a DeployContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.DeployContract} DeployContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DeployContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.DeployContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.code = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DeployContract message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DeployContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.code != null && message.hasOwnProperty("code"))
                            if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
                                return "code: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a DeployContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.DeployContract} DeployContract
                     */
                    DeployContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.DeployContract)
                            return object;
                        var message = new $root.TW.NEAR.Proto.DeployContract();
                        if (object.code != null)
                            if (typeof object.code === "string")
                                $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
                            else if (object.code.length)
                                message.code = object.code;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DeployContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @static
                     * @param {TW.NEAR.Proto.DeployContract} message DeployContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DeployContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.code = "";
                            else {
                                object.code = [];
                                if (options.bytes !== Array)
                                    object.code = $util.newBuffer(object.code);
                            }
                        if (message.code != null && message.hasOwnProperty("code"))
                            object.code = options.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
                        return object;
                    };
    
                    /**
                     * Converts this DeployContract to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.DeployContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DeployContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DeployContract;
                })();
    
                Proto.FunctionCall = (function() {
    
                    /**
                     * Properties of a FunctionCall.
                     * @memberof TW.NEAR.Proto
                     * @interface IFunctionCall
                     * @property {string|null} [methodName] FunctionCall methodName
                     * @property {Uint8Array|null} [args] FunctionCall args
                     * @property {Long|null} [gas] FunctionCall gas
                     * @property {Uint8Array|null} [deposit] FunctionCall deposit
                     */
    
                    /**
                     * Constructs a new FunctionCall.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a FunctionCall.
                     * @implements IFunctionCall
                     * @constructor
                     * @param {TW.NEAR.Proto.IFunctionCall=} [properties] Properties to set
                     */
                    function FunctionCall(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * FunctionCall methodName.
                     * @member {string} methodName
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @instance
                     */
                    FunctionCall.prototype.methodName = "";
    
                    /**
                     * FunctionCall args.
                     * @member {Uint8Array} args
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @instance
                     */
                    FunctionCall.prototype.args = $util.newBuffer([]);
    
                    /**
                     * FunctionCall gas.
                     * @member {Long} gas
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @instance
                     */
                    FunctionCall.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * FunctionCall deposit.
                     * @member {Uint8Array} deposit
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @instance
                     */
                    FunctionCall.prototype.deposit = $util.newBuffer([]);
    
                    /**
                     * Creates a new FunctionCall instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @static
                     * @param {TW.NEAR.Proto.IFunctionCall=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.FunctionCall} FunctionCall instance
                     */
                    FunctionCall.create = function create(properties) {
                        return new FunctionCall(properties);
                    };
    
                    /**
                     * Encodes the specified FunctionCall message. Does not implicitly {@link TW.NEAR.Proto.FunctionCall.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @static
                     * @param {TW.NEAR.Proto.IFunctionCall} message FunctionCall message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FunctionCall.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.methodName != null && Object.hasOwnProperty.call(message, "methodName"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.methodName);
                        if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.args);
                        if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.gas);
                        if (message.deposit != null && Object.hasOwnProperty.call(message, "deposit"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.deposit);
                        return writer;
                    };
    
                    /**
                     * Decodes a FunctionCall message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.FunctionCall} FunctionCall
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FunctionCall.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.FunctionCall();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.methodName = reader.string();
                                break;
                            case 2:
                                message.args = reader.bytes();
                                break;
                            case 3:
                                message.gas = reader.uint64();
                                break;
                            case 4:
                                message.deposit = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a FunctionCall message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FunctionCall.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.methodName != null && message.hasOwnProperty("methodName"))
                            if (!$util.isString(message.methodName))
                                return "methodName: string expected";
                        if (message.args != null && message.hasOwnProperty("args"))
                            if (!(message.args && typeof message.args.length === "number" || $util.isString(message.args)))
                                return "args: buffer expected";
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
                                return "gas: integer|Long expected";
                        if (message.deposit != null && message.hasOwnProperty("deposit"))
                            if (!(message.deposit && typeof message.deposit.length === "number" || $util.isString(message.deposit)))
                                return "deposit: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a FunctionCall message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.FunctionCall} FunctionCall
                     */
                    FunctionCall.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.FunctionCall)
                            return object;
                        var message = new $root.TW.NEAR.Proto.FunctionCall();
                        if (object.methodName != null)
                            message.methodName = String(object.methodName);
                        if (object.args != null)
                            if (typeof object.args === "string")
                                $util.base64.decode(object.args, message.args = $util.newBuffer($util.base64.length(object.args)), 0);
                            else if (object.args.length)
                                message.args = object.args;
                        if (object.gas != null)
                            if ($util.Long)
                                (message.gas = $util.Long.fromValue(object.gas)).unsigned = true;
                            else if (typeof object.gas === "string")
                                message.gas = parseInt(object.gas, 10);
                            else if (typeof object.gas === "number")
                                message.gas = object.gas;
                            else if (typeof object.gas === "object")
                                message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber(true);
                        if (object.deposit != null)
                            if (typeof object.deposit === "string")
                                $util.base64.decode(object.deposit, message.deposit = $util.newBuffer($util.base64.length(object.deposit)), 0);
                            else if (object.deposit.length)
                                message.deposit = object.deposit;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a FunctionCall message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @static
                     * @param {TW.NEAR.Proto.FunctionCall} message FunctionCall
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FunctionCall.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.methodName = "";
                            if (options.bytes === String)
                                object.args = "";
                            else {
                                object.args = [];
                                if (options.bytes !== Array)
                                    object.args = $util.newBuffer(object.args);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gas = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.deposit = "";
                            else {
                                object.deposit = [];
                                if (options.bytes !== Array)
                                    object.deposit = $util.newBuffer(object.deposit);
                            }
                        }
                        if (message.methodName != null && message.hasOwnProperty("methodName"))
                            object.methodName = message.methodName;
                        if (message.args != null && message.hasOwnProperty("args"))
                            object.args = options.bytes === String ? $util.base64.encode(message.args, 0, message.args.length) : options.bytes === Array ? Array.prototype.slice.call(message.args) : message.args;
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (typeof message.gas === "number")
                                object.gas = options.longs === String ? String(message.gas) : message.gas;
                            else
                                object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber(true) : message.gas;
                        if (message.deposit != null && message.hasOwnProperty("deposit"))
                            object.deposit = options.bytes === String ? $util.base64.encode(message.deposit, 0, message.deposit.length) : options.bytes === Array ? Array.prototype.slice.call(message.deposit) : message.deposit;
                        return object;
                    };
    
                    /**
                     * Converts this FunctionCall to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.FunctionCall
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FunctionCall.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return FunctionCall;
                })();
    
                Proto.Transfer = (function() {
    
                    /**
                     * Properties of a Transfer.
                     * @memberof TW.NEAR.Proto
                     * @interface ITransfer
                     * @property {Uint8Array|null} [deposit] Transfer deposit
                     */
    
                    /**
                     * Constructs a new Transfer.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a Transfer.
                     * @implements ITransfer
                     * @constructor
                     * @param {TW.NEAR.Proto.ITransfer=} [properties] Properties to set
                     */
                    function Transfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transfer deposit.
                     * @member {Uint8Array} deposit
                     * @memberof TW.NEAR.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.deposit = $util.newBuffer([]);
    
                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.Transfer
                     * @static
                     * @param {TW.NEAR.Proto.ITransfer=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.Transfer} Transfer instance
                     */
                    Transfer.create = function create(properties) {
                        return new Transfer(properties);
                    };
    
                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.NEAR.Proto.Transfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.Transfer
                     * @static
                     * @param {TW.NEAR.Proto.ITransfer} message Transfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.deposit != null && Object.hasOwnProperty.call(message, "deposit"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deposit);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.Transfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.Transfer} Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.Transfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.deposit = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transfer message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.deposit != null && message.hasOwnProperty("deposit"))
                            if (!(message.deposit && typeof message.deposit.length === "number" || $util.isString(message.deposit)))
                                return "deposit: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.Transfer} Transfer
                     */
                    Transfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.Transfer)
                            return object;
                        var message = new $root.TW.NEAR.Proto.Transfer();
                        if (object.deposit != null)
                            if (typeof object.deposit === "string")
                                $util.base64.decode(object.deposit, message.deposit = $util.newBuffer($util.base64.length(object.deposit)), 0);
                            else if (object.deposit.length)
                                message.deposit = object.deposit;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.Transfer
                     * @static
                     * @param {TW.NEAR.Proto.Transfer} message Transfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.deposit = "";
                            else {
                                object.deposit = [];
                                if (options.bytes !== Array)
                                    object.deposit = $util.newBuffer(object.deposit);
                            }
                        if (message.deposit != null && message.hasOwnProperty("deposit"))
                            object.deposit = options.bytes === String ? $util.base64.encode(message.deposit, 0, message.deposit.length) : options.bytes === Array ? Array.prototype.slice.call(message.deposit) : message.deposit;
                        return object;
                    };
    
                    /**
                     * Converts this Transfer to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.Transfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transfer;
                })();
    
                Proto.Stake = (function() {
    
                    /**
                     * Properties of a Stake.
                     * @memberof TW.NEAR.Proto
                     * @interface IStake
                     * @property {Uint8Array|null} [stake] Stake stake
                     * @property {string|null} [publicKey] Stake publicKey
                     */
    
                    /**
                     * Constructs a new Stake.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a Stake.
                     * @implements IStake
                     * @constructor
                     * @param {TW.NEAR.Proto.IStake=} [properties] Properties to set
                     */
                    function Stake(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Stake stake.
                     * @member {Uint8Array} stake
                     * @memberof TW.NEAR.Proto.Stake
                     * @instance
                     */
                    Stake.prototype.stake = $util.newBuffer([]);
    
                    /**
                     * Stake publicKey.
                     * @member {string} publicKey
                     * @memberof TW.NEAR.Proto.Stake
                     * @instance
                     */
                    Stake.prototype.publicKey = "";
    
                    /**
                     * Creates a new Stake instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.Stake
                     * @static
                     * @param {TW.NEAR.Proto.IStake=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.Stake} Stake instance
                     */
                    Stake.create = function create(properties) {
                        return new Stake(properties);
                    };
    
                    /**
                     * Encodes the specified Stake message. Does not implicitly {@link TW.NEAR.Proto.Stake.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.Stake
                     * @static
                     * @param {TW.NEAR.Proto.IStake} message Stake message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Stake.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.stake != null && Object.hasOwnProperty.call(message, "stake"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stake);
                        if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.publicKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a Stake message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.Stake
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.Stake} Stake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Stake.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.Stake();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.stake = reader.bytes();
                                break;
                            case 2:
                                message.publicKey = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Stake message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.Stake
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Stake.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stake != null && message.hasOwnProperty("stake"))
                            if (!(message.stake && typeof message.stake.length === "number" || $util.isString(message.stake)))
                                return "stake: buffer expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            if (!$util.isString(message.publicKey))
                                return "publicKey: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a Stake message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.Stake
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.Stake} Stake
                     */
                    Stake.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.Stake)
                            return object;
                        var message = new $root.TW.NEAR.Proto.Stake();
                        if (object.stake != null)
                            if (typeof object.stake === "string")
                                $util.base64.decode(object.stake, message.stake = $util.newBuffer($util.base64.length(object.stake)), 0);
                            else if (object.stake.length)
                                message.stake = object.stake;
                        if (object.publicKey != null)
                            message.publicKey = String(object.publicKey);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Stake message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.Stake
                     * @static
                     * @param {TW.NEAR.Proto.Stake} message Stake
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Stake.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.stake = "";
                            else {
                                object.stake = [];
                                if (options.bytes !== Array)
                                    object.stake = $util.newBuffer(object.stake);
                            }
                            object.publicKey = "";
                        }
                        if (message.stake != null && message.hasOwnProperty("stake"))
                            object.stake = options.bytes === String ? $util.base64.encode(message.stake, 0, message.stake.length) : options.bytes === Array ? Array.prototype.slice.call(message.stake) : message.stake;
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = message.publicKey;
                        return object;
                    };
    
                    /**
                     * Converts this Stake to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.Stake
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Stake.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Stake;
                })();
    
                Proto.AddKey = (function() {
    
                    /**
                     * Properties of an AddKey.
                     * @memberof TW.NEAR.Proto
                     * @interface IAddKey
                     * @property {TW.NEAR.Proto.IPublicKey|null} [publicKey] AddKey publicKey
                     * @property {TW.NEAR.Proto.IAccessKey|null} [accessKey] AddKey accessKey
                     */
    
                    /**
                     * Constructs a new AddKey.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents an AddKey.
                     * @implements IAddKey
                     * @constructor
                     * @param {TW.NEAR.Proto.IAddKey=} [properties] Properties to set
                     */
                    function AddKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AddKey publicKey.
                     * @member {TW.NEAR.Proto.IPublicKey|null|undefined} publicKey
                     * @memberof TW.NEAR.Proto.AddKey
                     * @instance
                     */
                    AddKey.prototype.publicKey = null;
    
                    /**
                     * AddKey accessKey.
                     * @member {TW.NEAR.Proto.IAccessKey|null|undefined} accessKey
                     * @memberof TW.NEAR.Proto.AddKey
                     * @instance
                     */
                    AddKey.prototype.accessKey = null;
    
                    /**
                     * Creates a new AddKey instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.AddKey
                     * @static
                     * @param {TW.NEAR.Proto.IAddKey=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.AddKey} AddKey instance
                     */
                    AddKey.create = function create(properties) {
                        return new AddKey(properties);
                    };
    
                    /**
                     * Encodes the specified AddKey message. Does not implicitly {@link TW.NEAR.Proto.AddKey.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.AddKey
                     * @static
                     * @param {TW.NEAR.Proto.IAddKey} message AddKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AddKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                            $root.TW.NEAR.Proto.PublicKey.encode(message.publicKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.accessKey != null && Object.hasOwnProperty.call(message, "accessKey"))
                            $root.TW.NEAR.Proto.AccessKey.encode(message.accessKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an AddKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.AddKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.AddKey} AddKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AddKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.AddKey();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.publicKey = $root.TW.NEAR.Proto.PublicKey.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.accessKey = $root.TW.NEAR.Proto.AccessKey.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an AddKey message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.AddKey
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AddKey.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                            var error = $root.TW.NEAR.Proto.PublicKey.verify(message.publicKey);
                            if (error)
                                return "publicKey." + error;
                        }
                        if (message.accessKey != null && message.hasOwnProperty("accessKey")) {
                            var error = $root.TW.NEAR.Proto.AccessKey.verify(message.accessKey);
                            if (error)
                                return "accessKey." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates an AddKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.AddKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.AddKey} AddKey
                     */
                    AddKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.AddKey)
                            return object;
                        var message = new $root.TW.NEAR.Proto.AddKey();
                        if (object.publicKey != null) {
                            if (typeof object.publicKey !== "object")
                                throw TypeError(".TW.NEAR.Proto.AddKey.publicKey: object expected");
                            message.publicKey = $root.TW.NEAR.Proto.PublicKey.fromObject(object.publicKey);
                        }
                        if (object.accessKey != null) {
                            if (typeof object.accessKey !== "object")
                                throw TypeError(".TW.NEAR.Proto.AddKey.accessKey: object expected");
                            message.accessKey = $root.TW.NEAR.Proto.AccessKey.fromObject(object.accessKey);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an AddKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.AddKey
                     * @static
                     * @param {TW.NEAR.Proto.AddKey} message AddKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AddKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.publicKey = null;
                            object.accessKey = null;
                        }
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = $root.TW.NEAR.Proto.PublicKey.toObject(message.publicKey, options);
                        if (message.accessKey != null && message.hasOwnProperty("accessKey"))
                            object.accessKey = $root.TW.NEAR.Proto.AccessKey.toObject(message.accessKey, options);
                        return object;
                    };
    
                    /**
                     * Converts this AddKey to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.AddKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AddKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return AddKey;
                })();
    
                Proto.DeleteKey = (function() {
    
                    /**
                     * Properties of a DeleteKey.
                     * @memberof TW.NEAR.Proto
                     * @interface IDeleteKey
                     * @property {TW.NEAR.Proto.IPublicKey|null} [publicKey] DeleteKey publicKey
                     */
    
                    /**
                     * Constructs a new DeleteKey.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a DeleteKey.
                     * @implements IDeleteKey
                     * @constructor
                     * @param {TW.NEAR.Proto.IDeleteKey=} [properties] Properties to set
                     */
                    function DeleteKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DeleteKey publicKey.
                     * @member {TW.NEAR.Proto.IPublicKey|null|undefined} publicKey
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @instance
                     */
                    DeleteKey.prototype.publicKey = null;
    
                    /**
                     * Creates a new DeleteKey instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @static
                     * @param {TW.NEAR.Proto.IDeleteKey=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.DeleteKey} DeleteKey instance
                     */
                    DeleteKey.create = function create(properties) {
                        return new DeleteKey(properties);
                    };
    
                    /**
                     * Encodes the specified DeleteKey message. Does not implicitly {@link TW.NEAR.Proto.DeleteKey.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @static
                     * @param {TW.NEAR.Proto.IDeleteKey} message DeleteKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DeleteKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                            $root.TW.NEAR.Proto.PublicKey.encode(message.publicKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a DeleteKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.DeleteKey} DeleteKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DeleteKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.DeleteKey();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.publicKey = $root.TW.NEAR.Proto.PublicKey.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DeleteKey message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DeleteKey.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                            var error = $root.TW.NEAR.Proto.PublicKey.verify(message.publicKey);
                            if (error)
                                return "publicKey." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a DeleteKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.DeleteKey} DeleteKey
                     */
                    DeleteKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.DeleteKey)
                            return object;
                        var message = new $root.TW.NEAR.Proto.DeleteKey();
                        if (object.publicKey != null) {
                            if (typeof object.publicKey !== "object")
                                throw TypeError(".TW.NEAR.Proto.DeleteKey.publicKey: object expected");
                            message.publicKey = $root.TW.NEAR.Proto.PublicKey.fromObject(object.publicKey);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DeleteKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @static
                     * @param {TW.NEAR.Proto.DeleteKey} message DeleteKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DeleteKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.publicKey = null;
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = $root.TW.NEAR.Proto.PublicKey.toObject(message.publicKey, options);
                        return object;
                    };
    
                    /**
                     * Converts this DeleteKey to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.DeleteKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DeleteKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DeleteKey;
                })();
    
                Proto.DeleteAccount = (function() {
    
                    /**
                     * Properties of a DeleteAccount.
                     * @memberof TW.NEAR.Proto
                     * @interface IDeleteAccount
                     * @property {string|null} [beneficiaryId] DeleteAccount beneficiaryId
                     */
    
                    /**
                     * Constructs a new DeleteAccount.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a DeleteAccount.
                     * @implements IDeleteAccount
                     * @constructor
                     * @param {TW.NEAR.Proto.IDeleteAccount=} [properties] Properties to set
                     */
                    function DeleteAccount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DeleteAccount beneficiaryId.
                     * @member {string} beneficiaryId
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @instance
                     */
                    DeleteAccount.prototype.beneficiaryId = "";
    
                    /**
                     * Creates a new DeleteAccount instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @static
                     * @param {TW.NEAR.Proto.IDeleteAccount=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.DeleteAccount} DeleteAccount instance
                     */
                    DeleteAccount.create = function create(properties) {
                        return new DeleteAccount(properties);
                    };
    
                    /**
                     * Encodes the specified DeleteAccount message. Does not implicitly {@link TW.NEAR.Proto.DeleteAccount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @static
                     * @param {TW.NEAR.Proto.IDeleteAccount} message DeleteAccount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DeleteAccount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.beneficiaryId != null && Object.hasOwnProperty.call(message, "beneficiaryId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.beneficiaryId);
                        return writer;
                    };
    
                    /**
                     * Decodes a DeleteAccount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.DeleteAccount} DeleteAccount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DeleteAccount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.DeleteAccount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.beneficiaryId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DeleteAccount message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DeleteAccount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.beneficiaryId != null && message.hasOwnProperty("beneficiaryId"))
                            if (!$util.isString(message.beneficiaryId))
                                return "beneficiaryId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DeleteAccount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.DeleteAccount} DeleteAccount
                     */
                    DeleteAccount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.DeleteAccount)
                            return object;
                        var message = new $root.TW.NEAR.Proto.DeleteAccount();
                        if (object.beneficiaryId != null)
                            message.beneficiaryId = String(object.beneficiaryId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DeleteAccount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @static
                     * @param {TW.NEAR.Proto.DeleteAccount} message DeleteAccount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DeleteAccount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.beneficiaryId = "";
                        if (message.beneficiaryId != null && message.hasOwnProperty("beneficiaryId"))
                            object.beneficiaryId = message.beneficiaryId;
                        return object;
                    };
    
                    /**
                     * Converts this DeleteAccount to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.DeleteAccount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DeleteAccount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DeleteAccount;
                })();
    
                Proto.Action = (function() {
    
                    /**
                     * Properties of an Action.
                     * @memberof TW.NEAR.Proto
                     * @interface IAction
                     * @property {TW.NEAR.Proto.ICreateAccount|null} [createAccount] Action createAccount
                     * @property {TW.NEAR.Proto.IDeployContract|null} [deployContract] Action deployContract
                     * @property {TW.NEAR.Proto.IFunctionCall|null} [functionCall] Action functionCall
                     * @property {TW.NEAR.Proto.ITransfer|null} [transfer] Action transfer
                     * @property {TW.NEAR.Proto.IStake|null} [stake] Action stake
                     * @property {TW.NEAR.Proto.IAddKey|null} [addKey] Action addKey
                     * @property {TW.NEAR.Proto.IDeleteKey|null} [deleteKey] Action deleteKey
                     * @property {TW.NEAR.Proto.IDeleteAccount|null} [deleteAccount] Action deleteAccount
                     */
    
                    /**
                     * Constructs a new Action.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents an Action.
                     * @implements IAction
                     * @constructor
                     * @param {TW.NEAR.Proto.IAction=} [properties] Properties to set
                     */
                    function Action(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Action createAccount.
                     * @member {TW.NEAR.Proto.ICreateAccount|null|undefined} createAccount
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.createAccount = null;
    
                    /**
                     * Action deployContract.
                     * @member {TW.NEAR.Proto.IDeployContract|null|undefined} deployContract
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.deployContract = null;
    
                    /**
                     * Action functionCall.
                     * @member {TW.NEAR.Proto.IFunctionCall|null|undefined} functionCall
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.functionCall = null;
    
                    /**
                     * Action transfer.
                     * @member {TW.NEAR.Proto.ITransfer|null|undefined} transfer
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.transfer = null;
    
                    /**
                     * Action stake.
                     * @member {TW.NEAR.Proto.IStake|null|undefined} stake
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.stake = null;
    
                    /**
                     * Action addKey.
                     * @member {TW.NEAR.Proto.IAddKey|null|undefined} addKey
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.addKey = null;
    
                    /**
                     * Action deleteKey.
                     * @member {TW.NEAR.Proto.IDeleteKey|null|undefined} deleteKey
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.deleteKey = null;
    
                    /**
                     * Action deleteAccount.
                     * @member {TW.NEAR.Proto.IDeleteAccount|null|undefined} deleteAccount
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Action.prototype.deleteAccount = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Action payload.
                     * @member {"createAccount"|"deployContract"|"functionCall"|"transfer"|"stake"|"addKey"|"deleteKey"|"deleteAccount"|undefined} payload
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     */
                    Object.defineProperty(Action.prototype, "payload", {
                        get: $util.oneOfGetter($oneOfFields = ["createAccount", "deployContract", "functionCall", "transfer", "stake", "addKey", "deleteKey", "deleteAccount"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Action instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.Action
                     * @static
                     * @param {TW.NEAR.Proto.IAction=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.Action} Action instance
                     */
                    Action.create = function create(properties) {
                        return new Action(properties);
                    };
    
                    /**
                     * Encodes the specified Action message. Does not implicitly {@link TW.NEAR.Proto.Action.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.Action
                     * @static
                     * @param {TW.NEAR.Proto.IAction} message Action message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Action.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.createAccount != null && Object.hasOwnProperty.call(message, "createAccount"))
                            $root.TW.NEAR.Proto.CreateAccount.encode(message.createAccount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.deployContract != null && Object.hasOwnProperty.call(message, "deployContract"))
                            $root.TW.NEAR.Proto.DeployContract.encode(message.deployContract, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.functionCall != null && Object.hasOwnProperty.call(message, "functionCall"))
                            $root.TW.NEAR.Proto.FunctionCall.encode(message.functionCall, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.NEAR.Proto.Transfer.encode(message.transfer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.stake != null && Object.hasOwnProperty.call(message, "stake"))
                            $root.TW.NEAR.Proto.Stake.encode(message.stake, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.addKey != null && Object.hasOwnProperty.call(message, "addKey"))
                            $root.TW.NEAR.Proto.AddKey.encode(message.addKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.deleteKey != null && Object.hasOwnProperty.call(message, "deleteKey"))
                            $root.TW.NEAR.Proto.DeleteKey.encode(message.deleteKey, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.deleteAccount != null && Object.hasOwnProperty.call(message, "deleteAccount"))
                            $root.TW.NEAR.Proto.DeleteAccount.encode(message.deleteAccount, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an Action message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.Action
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.Action} Action
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Action.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.Action();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.createAccount = $root.TW.NEAR.Proto.CreateAccount.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.deployContract = $root.TW.NEAR.Proto.DeployContract.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.functionCall = $root.TW.NEAR.Proto.FunctionCall.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.transfer = $root.TW.NEAR.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.stake = $root.TW.NEAR.Proto.Stake.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.addKey = $root.TW.NEAR.Proto.AddKey.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.deleteKey = $root.TW.NEAR.Proto.DeleteKey.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.deleteAccount = $root.TW.NEAR.Proto.DeleteAccount.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Action message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.Action
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Action.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.createAccount != null && message.hasOwnProperty("createAccount")) {
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.CreateAccount.verify(message.createAccount);
                                if (error)
                                    return "createAccount." + error;
                            }
                        }
                        if (message.deployContract != null && message.hasOwnProperty("deployContract")) {
                            if (properties.payload === 1)
                                return "payload: multiple values";
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.DeployContract.verify(message.deployContract);
                                if (error)
                                    return "deployContract." + error;
                            }
                        }
                        if (message.functionCall != null && message.hasOwnProperty("functionCall")) {
                            if (properties.payload === 1)
                                return "payload: multiple values";
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.FunctionCall.verify(message.functionCall);
                                if (error)
                                    return "functionCall." + error;
                            }
                        }
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            if (properties.payload === 1)
                                return "payload: multiple values";
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.stake != null && message.hasOwnProperty("stake")) {
                            if (properties.payload === 1)
                                return "payload: multiple values";
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.Stake.verify(message.stake);
                                if (error)
                                    return "stake." + error;
                            }
                        }
                        if (message.addKey != null && message.hasOwnProperty("addKey")) {
                            if (properties.payload === 1)
                                return "payload: multiple values";
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.AddKey.verify(message.addKey);
                                if (error)
                                    return "addKey." + error;
                            }
                        }
                        if (message.deleteKey != null && message.hasOwnProperty("deleteKey")) {
                            if (properties.payload === 1)
                                return "payload: multiple values";
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.DeleteKey.verify(message.deleteKey);
                                if (error)
                                    return "deleteKey." + error;
                            }
                        }
                        if (message.deleteAccount != null && message.hasOwnProperty("deleteAccount")) {
                            if (properties.payload === 1)
                                return "payload: multiple values";
                            properties.payload = 1;
                            {
                                var error = $root.TW.NEAR.Proto.DeleteAccount.verify(message.deleteAccount);
                                if (error)
                                    return "deleteAccount." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an Action message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.Action
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.Action} Action
                     */
                    Action.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.Action)
                            return object;
                        var message = new $root.TW.NEAR.Proto.Action();
                        if (object.createAccount != null) {
                            if (typeof object.createAccount !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.createAccount: object expected");
                            message.createAccount = $root.TW.NEAR.Proto.CreateAccount.fromObject(object.createAccount);
                        }
                        if (object.deployContract != null) {
                            if (typeof object.deployContract !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.deployContract: object expected");
                            message.deployContract = $root.TW.NEAR.Proto.DeployContract.fromObject(object.deployContract);
                        }
                        if (object.functionCall != null) {
                            if (typeof object.functionCall !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.functionCall: object expected");
                            message.functionCall = $root.TW.NEAR.Proto.FunctionCall.fromObject(object.functionCall);
                        }
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.transfer: object expected");
                            message.transfer = $root.TW.NEAR.Proto.Transfer.fromObject(object.transfer);
                        }
                        if (object.stake != null) {
                            if (typeof object.stake !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.stake: object expected");
                            message.stake = $root.TW.NEAR.Proto.Stake.fromObject(object.stake);
                        }
                        if (object.addKey != null) {
                            if (typeof object.addKey !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.addKey: object expected");
                            message.addKey = $root.TW.NEAR.Proto.AddKey.fromObject(object.addKey);
                        }
                        if (object.deleteKey != null) {
                            if (typeof object.deleteKey !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.deleteKey: object expected");
                            message.deleteKey = $root.TW.NEAR.Proto.DeleteKey.fromObject(object.deleteKey);
                        }
                        if (object.deleteAccount != null) {
                            if (typeof object.deleteAccount !== "object")
                                throw TypeError(".TW.NEAR.Proto.Action.deleteAccount: object expected");
                            message.deleteAccount = $root.TW.NEAR.Proto.DeleteAccount.fromObject(object.deleteAccount);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Action message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.Action
                     * @static
                     * @param {TW.NEAR.Proto.Action} message Action
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Action.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.createAccount != null && message.hasOwnProperty("createAccount")) {
                            object.createAccount = $root.TW.NEAR.Proto.CreateAccount.toObject(message.createAccount, options);
                            if (options.oneofs)
                                object.payload = "createAccount";
                        }
                        if (message.deployContract != null && message.hasOwnProperty("deployContract")) {
                            object.deployContract = $root.TW.NEAR.Proto.DeployContract.toObject(message.deployContract, options);
                            if (options.oneofs)
                                object.payload = "deployContract";
                        }
                        if (message.functionCall != null && message.hasOwnProperty("functionCall")) {
                            object.functionCall = $root.TW.NEAR.Proto.FunctionCall.toObject(message.functionCall, options);
                            if (options.oneofs)
                                object.payload = "functionCall";
                        }
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.NEAR.Proto.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.payload = "transfer";
                        }
                        if (message.stake != null && message.hasOwnProperty("stake")) {
                            object.stake = $root.TW.NEAR.Proto.Stake.toObject(message.stake, options);
                            if (options.oneofs)
                                object.payload = "stake";
                        }
                        if (message.addKey != null && message.hasOwnProperty("addKey")) {
                            object.addKey = $root.TW.NEAR.Proto.AddKey.toObject(message.addKey, options);
                            if (options.oneofs)
                                object.payload = "addKey";
                        }
                        if (message.deleteKey != null && message.hasOwnProperty("deleteKey")) {
                            object.deleteKey = $root.TW.NEAR.Proto.DeleteKey.toObject(message.deleteKey, options);
                            if (options.oneofs)
                                object.payload = "deleteKey";
                        }
                        if (message.deleteAccount != null && message.hasOwnProperty("deleteAccount")) {
                            object.deleteAccount = $root.TW.NEAR.Proto.DeleteAccount.toObject(message.deleteAccount, options);
                            if (options.oneofs)
                                object.payload = "deleteAccount";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Action to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.Action
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Action.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Action;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.NEAR.Proto
                     * @interface ISigningInput
                     * @property {string|null} [signerId] SigningInput signerId
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {string|null} [receiverId] SigningInput receiverId
                     * @property {Uint8Array|null} [blockHash] SigningInput blockHash
                     * @property {Array.<TW.NEAR.Proto.IAction>|null} [actions] SigningInput actions
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.NEAR.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.actions = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput signerId.
                     * @member {string} signerId
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.signerId = "";
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput receiverId.
                     * @member {string} receiverId
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.receiverId = "";
    
                    /**
                     * SigningInput blockHash.
                     * @member {Uint8Array} blockHash
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.blockHash = $util.newBuffer([]);
    
                    /**
                     * SigningInput actions.
                     * @member {Array.<TW.NEAR.Proto.IAction>} actions
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.actions = $util.emptyArray;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @static
                     * @param {TW.NEAR.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.NEAR.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @static
                     * @param {TW.NEAR.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signerId != null && Object.hasOwnProperty.call(message, "signerId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signerId);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                        if (message.receiverId != null && Object.hasOwnProperty.call(message, "receiverId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.receiverId);
                        if (message.blockHash != null && Object.hasOwnProperty.call(message, "blockHash"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.blockHash);
                        if (message.actions != null && message.actions.length)
                            for (var i = 0; i < message.actions.length; ++i)
                                $root.TW.NEAR.Proto.Action.encode(message.actions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signerId = reader.string();
                                break;
                            case 2:
                                message.nonce = reader.uint64();
                                break;
                            case 3:
                                message.receiverId = reader.string();
                                break;
                            case 4:
                                message.blockHash = reader.bytes();
                                break;
                            case 5:
                                if (!(message.actions && message.actions.length))
                                    message.actions = [];
                                message.actions.push($root.TW.NEAR.Proto.Action.decode(reader, reader.uint32()));
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signerId != null && message.hasOwnProperty("signerId"))
                            if (!$util.isString(message.signerId))
                                return "signerId: string expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.receiverId != null && message.hasOwnProperty("receiverId"))
                            if (!$util.isString(message.receiverId))
                                return "receiverId: string expected";
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                                return "blockHash: buffer expected";
                        if (message.actions != null && message.hasOwnProperty("actions")) {
                            if (!Array.isArray(message.actions))
                                return "actions: array expected";
                            for (var i = 0; i < message.actions.length; ++i) {
                                var error = $root.TW.NEAR.Proto.Action.verify(message.actions[i]);
                                if (error)
                                    return "actions." + error;
                            }
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.NEAR.Proto.SigningInput();
                        if (object.signerId != null)
                            message.signerId = String(object.signerId);
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.receiverId != null)
                            message.receiverId = String(object.receiverId);
                        if (object.blockHash != null)
                            if (typeof object.blockHash === "string")
                                $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                            else if (object.blockHash.length)
                                message.blockHash = object.blockHash;
                        if (object.actions) {
                            if (!Array.isArray(object.actions))
                                throw TypeError(".TW.NEAR.Proto.SigningInput.actions: array expected");
                            message.actions = [];
                            for (var i = 0; i < object.actions.length; ++i) {
                                if (typeof object.actions[i] !== "object")
                                    throw TypeError(".TW.NEAR.Proto.SigningInput.actions: object expected");
                                message.actions[i] = $root.TW.NEAR.Proto.Action.fromObject(object.actions[i]);
                            }
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @static
                     * @param {TW.NEAR.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.actions = [];
                        if (options.defaults) {
                            object.signerId = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            object.receiverId = "";
                            if (options.bytes === String)
                                object.blockHash = "";
                            else {
                                object.blockHash = [];
                                if (options.bytes !== Array)
                                    object.blockHash = $util.newBuffer(object.blockHash);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.signerId != null && message.hasOwnProperty("signerId"))
                            object.signerId = message.signerId;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.receiverId != null && message.hasOwnProperty("receiverId"))
                            object.receiverId = message.receiverId;
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
                        if (message.actions && message.actions.length) {
                            object.actions = [];
                            for (var j = 0; j < message.actions.length; ++j)
                                object.actions[j] = $root.TW.NEAR.Proto.Action.toObject(message.actions[j], options);
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.NEAR.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signedTransaction] SigningOutput signedTransaction
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.NEAR.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.NEAR.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signedTransaction.
                     * @member {Uint8Array} signedTransaction
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signedTransaction = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @static
                     * @param {TW.NEAR.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.NEAR.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.NEAR.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @static
                     * @param {TW.NEAR.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signedTransaction != null && Object.hasOwnProperty.call(message, "signedTransaction"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signedTransaction);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEAR.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEAR.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signedTransaction = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signedTransaction != null && message.hasOwnProperty("signedTransaction"))
                            if (!(message.signedTransaction && typeof message.signedTransaction.length === "number" || $util.isString(message.signedTransaction)))
                                return "signedTransaction: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEAR.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEAR.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.NEAR.Proto.SigningOutput();
                        if (object.signedTransaction != null)
                            if (typeof object.signedTransaction === "string")
                                $util.base64.decode(object.signedTransaction, message.signedTransaction = $util.newBuffer($util.base64.length(object.signedTransaction)), 0);
                            else if (object.signedTransaction.length)
                                message.signedTransaction = object.signedTransaction;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @static
                     * @param {TW.NEAR.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.signedTransaction = "";
                            else {
                                object.signedTransaction = [];
                                if (options.bytes !== Array)
                                    object.signedTransaction = $util.newBuffer(object.signedTransaction);
                            }
                        if (message.signedTransaction != null && message.hasOwnProperty("signedTransaction"))
                            object.signedTransaction = options.bytes === String ? $util.base64.encode(message.signedTransaction, 0, message.signedTransaction.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedTransaction) : message.signedTransaction;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.NEAR.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return NEAR;
        })();
    
        TW.Nebulas = (function() {
    
            /**
             * Namespace Nebulas.
             * @memberof TW
             * @namespace
             */
            var Nebulas = {};
    
            Nebulas.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Nebulas
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Nebulas.Proto
                     * @interface ISigningInput
                     * @property {string|null} [fromAddress] SigningInput fromAddress
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [timestamp] SigningInput timestamp
                     * @property {string|null} [payload] SigningInput payload
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Nebulas.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fromAddress = "";
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput timestamp.
                     * @member {Uint8Array} timestamp
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.newBuffer([]);
    
                    /**
                     * SigningInput payload.
                     * @member {string} payload
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payload = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nebulas.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.chainId);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.gasLimit);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.amount);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.timestamp);
                        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.payload);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.chainId = reader.bytes();
                                break;
                            case 3:
                                message.nonce = reader.bytes();
                                break;
                            case 4:
                                message.gasPrice = reader.bytes();
                                break;
                            case 5:
                                message.gasLimit = reader.bytes();
                                break;
                            case 6:
                                message.toAddress = reader.string();
                                break;
                            case 7:
                                message.amount = reader.bytes();
                                break;
                            case 8:
                                message.timestamp = reader.bytes();
                                break;
                            case 9:
                                message.payload = reader.string();
                                break;
                            case 10:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!(message.timestamp && typeof message.timestamp.length === "number" || $util.isString(message.timestamp)))
                                return "timestamp: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!$util.isString(message.payload))
                                return "payload: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.SigningInput();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.timestamp != null)
                            if (typeof object.timestamp === "string")
                                $util.base64.decode(object.timestamp, message.timestamp = $util.newBuffer($util.base64.length(object.timestamp)), 0);
                            else if (object.timestamp.length)
                                message.timestamp = object.timestamp;
                        if (object.payload != null)
                            message.payload = String(object.payload);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {TW.Nebulas.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromAddress = "";
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.timestamp = "";
                            else {
                                object.timestamp = [];
                                if (options.bytes !== Array)
                                    object.timestamp = $util.newBuffer(object.timestamp);
                            }
                            object.payload = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = options.bytes === String ? $util.base64.encode(message.timestamp, 0, message.timestamp.length) : options.bytes === Array ? Array.prototype.slice.call(message.timestamp) : message.timestamp;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = message.payload;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Nebulas.Proto
                     * @interface ISigningOutput
                     * @property {number|null} [algorithm] SigningOutput algorithm
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [raw] SigningOutput raw
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Nebulas.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput algorithm.
                     * @member {number} algorithm
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.algorithm = 0;
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput raw.
                     * @member {string} raw
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.raw = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nebulas.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.algorithm != null && Object.hasOwnProperty.call(message, "algorithm"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.algorithm);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        if (message.raw != null && Object.hasOwnProperty.call(message, "raw"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.raw);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.algorithm = reader.uint32();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            case 3:
                                message.raw = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            if (!$util.isInteger(message.algorithm))
                                return "algorithm: integer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.raw != null && message.hasOwnProperty("raw"))
                            if (!$util.isString(message.raw))
                                return "raw: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.SigningOutput();
                        if (object.algorithm != null)
                            message.algorithm = object.algorithm >>> 0;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.raw != null)
                            message.raw = String(object.raw);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {TW.Nebulas.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.algorithm = 0;
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.raw = "";
                        }
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            object.algorithm = message.algorithm;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.raw != null && message.hasOwnProperty("raw"))
                            object.raw = message.raw;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.Data = (function() {
    
                    /**
                     * Properties of a Data.
                     * @memberof TW.Nebulas.Proto
                     * @interface IData
                     * @property {string|null} [type] Data type
                     * @property {Uint8Array|null} [payload] Data payload
                     */
    
                    /**
                     * Constructs a new Data.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a Data.
                     * @implements IData
                     * @constructor
                     * @param {TW.Nebulas.Proto.IData=} [properties] Properties to set
                     */
                    function Data(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Data type.
                     * @member {string} type
                     * @memberof TW.Nebulas.Proto.Data
                     * @instance
                     */
                    Data.prototype.type = "";
    
                    /**
                     * Data payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.Nebulas.Proto.Data
                     * @instance
                     */
                    Data.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * Creates a new Data instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {TW.Nebulas.Proto.IData=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.Data} Data instance
                     */
                    Data.create = function create(properties) {
                        return new Data(properties);
                    };
    
                    /**
                     * Encodes the specified Data message. Does not implicitly {@link TW.Nebulas.Proto.Data.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {TW.Nebulas.Proto.IData} message Data message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Data.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                        return writer;
                    };
    
                    /**
                     * Decodes a Data message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.Data} Data
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Data.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.Data();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.string();
                                break;
                            case 2:
                                message.payload = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Data message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Data.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Data message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.Data} Data
                     */
                    Data.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.Data)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.Data();
                        if (object.type != null)
                            message.type = String(object.type);
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Data message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {TW.Nebulas.Proto.Data} message Data
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Data.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.type = "";
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        return object;
                    };
    
                    /**
                     * Converts this Data to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.Data
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Data.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Data;
                })();
    
                Proto.RawTransaction = (function() {
    
                    /**
                     * Properties of a RawTransaction.
                     * @memberof TW.Nebulas.Proto
                     * @interface IRawTransaction
                     * @property {Uint8Array|null} [hash] RawTransaction hash
                     * @property {Uint8Array|null} [from] RawTransaction from
                     * @property {Uint8Array|null} [to] RawTransaction to
                     * @property {Uint8Array|null} [value] RawTransaction value
                     * @property {Long|null} [nonce] RawTransaction nonce
                     * @property {Long|null} [timestamp] RawTransaction timestamp
                     * @property {TW.Nebulas.Proto.IData|null} [data] RawTransaction data
                     * @property {number|null} [chainId] RawTransaction chainId
                     * @property {Uint8Array|null} [gasPrice] RawTransaction gasPrice
                     * @property {Uint8Array|null} [gasLimit] RawTransaction gasLimit
                     * @property {number|null} [alg] RawTransaction alg
                     * @property {Uint8Array|null} [sign] RawTransaction sign
                     */
    
                    /**
                     * Constructs a new RawTransaction.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a RawTransaction.
                     * @implements IRawTransaction
                     * @constructor
                     * @param {TW.Nebulas.Proto.IRawTransaction=} [properties] Properties to set
                     */
                    function RawTransaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RawTransaction hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * RawTransaction from.
                     * @member {Uint8Array} from
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.from = $util.newBuffer([]);
    
                    /**
                     * RawTransaction to.
                     * @member {Uint8Array} to
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.to = $util.newBuffer([]);
    
                    /**
                     * RawTransaction value.
                     * @member {Uint8Array} value
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.value = $util.newBuffer([]);
    
                    /**
                     * RawTransaction nonce.
                     * @member {Long} nonce
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * RawTransaction timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * RawTransaction data.
                     * @member {TW.Nebulas.Proto.IData|null|undefined} data
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.data = null;
    
                    /**
                     * RawTransaction chainId.
                     * @member {number} chainId
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.chainId = 0;
    
                    /**
                     * RawTransaction gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * RawTransaction gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * RawTransaction alg.
                     * @member {number} alg
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.alg = 0;
    
                    /**
                     * RawTransaction sign.
                     * @member {Uint8Array} sign
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.sign = $util.newBuffer([]);
    
                    /**
                     * Creates a new RawTransaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {TW.Nebulas.Proto.IRawTransaction=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.RawTransaction} RawTransaction instance
                     */
                    RawTransaction.create = function create(properties) {
                        return new RawTransaction(properties);
                    };
    
                    /**
                     * Encodes the specified RawTransaction message. Does not implicitly {@link TW.Nebulas.Proto.RawTransaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {TW.Nebulas.Proto.IRawTransaction} message RawTransaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RawTransaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.from);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.to);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.nonce);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            $root.TW.Nebulas.Proto.Data.encode(message.data, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.chainId);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.gasLimit);
                        if (message.alg != null && Object.hasOwnProperty.call(message, "alg"))
                            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.alg);
                        if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                            writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.sign);
                        return writer;
                    };
    
                    /**
                     * Decodes a RawTransaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.RawTransaction} RawTransaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RawTransaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.RawTransaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hash = reader.bytes();
                                break;
                            case 2:
                                message.from = reader.bytes();
                                break;
                            case 3:
                                message.to = reader.bytes();
                                break;
                            case 4:
                                message.value = reader.bytes();
                                break;
                            case 5:
                                message.nonce = reader.uint64();
                                break;
                            case 6:
                                message.timestamp = reader.int64();
                                break;
                            case 7:
                                message.data = $root.TW.Nebulas.Proto.Data.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.chainId = reader.uint32();
                                break;
                            case 9:
                                message.gasPrice = reader.bytes();
                                break;
                            case 10:
                                message.gasLimit = reader.bytes();
                                break;
                            case 11:
                                message.alg = reader.uint32();
                                break;
                            case 12:
                                message.sign = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a RawTransaction message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RawTransaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.data != null && message.hasOwnProperty("data")) {
                            var error = $root.TW.Nebulas.Proto.Data.verify(message.data);
                            if (error)
                                return "data." + error;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isInteger(message.chainId))
                                return "chainId: integer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.alg != null && message.hasOwnProperty("alg"))
                            if (!$util.isInteger(message.alg))
                                return "alg: integer expected";
                        if (message.sign != null && message.hasOwnProperty("sign"))
                            if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                                return "sign: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a RawTransaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.RawTransaction} RawTransaction
                     */
                    RawTransaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.RawTransaction)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.RawTransaction();
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.data != null) {
                            if (typeof object.data !== "object")
                                throw TypeError(".TW.Nebulas.Proto.RawTransaction.data: object expected");
                            message.data = $root.TW.Nebulas.Proto.Data.fromObject(object.data);
                        }
                        if (object.chainId != null)
                            message.chainId = object.chainId >>> 0;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.alg != null)
                            message.alg = object.alg >>> 0;
                        if (object.sign != null)
                            if (typeof object.sign === "string")
                                $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                            else if (object.sign.length)
                                message.sign = object.sign;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a RawTransaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {TW.Nebulas.Proto.RawTransaction} message RawTransaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RawTransaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            object.data = null;
                            object.chainId = 0;
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.alg = 0;
                            if (options.bytes === String)
                                object.sign = "";
                            else {
                                object.sign = [];
                                if (options.bytes !== Array)
                                    object.sign = $util.newBuffer(object.sign);
                            }
                        }
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = $root.TW.Nebulas.Proto.Data.toObject(message.data, options);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.alg != null && message.hasOwnProperty("alg"))
                            object.alg = message.alg;
                        if (message.sign != null && message.hasOwnProperty("sign"))
                            object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
                        return object;
                    };
    
                    /**
                     * Converts this RawTransaction to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RawTransaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return RawTransaction;
                })();
    
                return Proto;
            })();
    
            return Nebulas;
        })();
    
        TW.NEO = (function() {
    
            /**
             * Namespace NEO.
             * @memberof TW
             * @namespace
             */
            var NEO = {};
    
            NEO.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.NEO
                 * @namespace
                 */
                var Proto = {};
    
                Proto.TransactionInput = (function() {
    
                    /**
                     * Properties of a TransactionInput.
                     * @memberof TW.NEO.Proto
                     * @interface ITransactionInput
                     * @property {Uint8Array|null} [prevHash] TransactionInput prevHash
                     * @property {number|null} [prevIndex] TransactionInput prevIndex
                     * @property {Long|null} [value] TransactionInput value
                     * @property {string|null} [assetId] TransactionInput assetId
                     */
    
                    /**
                     * Constructs a new TransactionInput.
                     * @memberof TW.NEO.Proto
                     * @classdesc Represents a TransactionInput.
                     * @implements ITransactionInput
                     * @constructor
                     * @param {TW.NEO.Proto.ITransactionInput=} [properties] Properties to set
                     */
                    function TransactionInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionInput prevHash.
                     * @member {Uint8Array} prevHash
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.prevHash = $util.newBuffer([]);
    
                    /**
                     * TransactionInput prevIndex.
                     * @member {number} prevIndex
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.prevIndex = 0;
    
                    /**
                     * TransactionInput value.
                     * @member {Long} value
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionInput assetId.
                     * @member {string} assetId
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.assetId = "";
    
                    /**
                     * Creates a new TransactionInput instance using the specified properties.
                     * @function create
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @static
                     * @param {TW.NEO.Proto.ITransactionInput=} [properties] Properties to set
                     * @returns {TW.NEO.Proto.TransactionInput} TransactionInput instance
                     */
                    TransactionInput.create = function create(properties) {
                        return new TransactionInput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionInput message. Does not implicitly {@link TW.NEO.Proto.TransactionInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @static
                     * @param {TW.NEO.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.prevHash != null && Object.hasOwnProperty.call(message, "prevHash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.prevHash);
                        if (message.prevIndex != null && Object.hasOwnProperty.call(message, "prevIndex"))
                            writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.prevIndex);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.value);
                        if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.assetId);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEO.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEO.Proto.TransactionInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.prevHash = reader.bytes();
                                break;
                            case 2:
                                message.prevIndex = reader.fixed32();
                                break;
                            case 3:
                                message.value = reader.int64();
                                break;
                            case 4:
                                message.assetId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionInput message.
                     * @function verify
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.prevHash != null && message.hasOwnProperty("prevHash"))
                            if (!(message.prevHash && typeof message.prevHash.length === "number" || $util.isString(message.prevHash)))
                                return "prevHash: buffer expected";
                        if (message.prevIndex != null && message.hasOwnProperty("prevIndex"))
                            if (!$util.isInteger(message.prevIndex))
                                return "prevIndex: integer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            if (!$util.isString(message.assetId))
                                return "assetId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEO.Proto.TransactionInput} TransactionInput
                     */
                    TransactionInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEO.Proto.TransactionInput)
                            return object;
                        var message = new $root.TW.NEO.Proto.TransactionInput();
                        if (object.prevHash != null)
                            if (typeof object.prevHash === "string")
                                $util.base64.decode(object.prevHash, message.prevHash = $util.newBuffer($util.base64.length(object.prevHash)), 0);
                            else if (object.prevHash.length)
                                message.prevHash = object.prevHash;
                        if (object.prevIndex != null)
                            message.prevIndex = object.prevIndex >>> 0;
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                        if (object.assetId != null)
                            message.assetId = String(object.assetId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @static
                     * @param {TW.NEO.Proto.TransactionInput} message TransactionInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.prevHash = "";
                            else {
                                object.prevHash = [];
                                if (options.bytes !== Array)
                                    object.prevHash = $util.newBuffer(object.prevHash);
                            }
                            object.prevIndex = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            object.assetId = "";
                        }
                        if (message.prevHash != null && message.hasOwnProperty("prevHash"))
                            object.prevHash = options.bytes === String ? $util.base64.encode(message.prevHash, 0, message.prevHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.prevHash) : message.prevHash;
                        if (message.prevIndex != null && message.hasOwnProperty("prevIndex"))
                            object.prevIndex = message.prevIndex;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            object.assetId = message.assetId;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionInput to JSON.
                     * @function toJSON
                     * @memberof TW.NEO.Proto.TransactionInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionInput;
                })();
    
                Proto.TransactionOutput = (function() {
    
                    /**
                     * Properties of a TransactionOutput.
                     * @memberof TW.NEO.Proto
                     * @interface ITransactionOutput
                     * @property {string|null} [assetId] TransactionOutput assetId
                     * @property {Long|null} [amount] TransactionOutput amount
                     * @property {string|null} [toAddress] TransactionOutput toAddress
                     * @property {string|null} [changeAddress] TransactionOutput changeAddress
                     */
    
                    /**
                     * Constructs a new TransactionOutput.
                     * @memberof TW.NEO.Proto
                     * @classdesc Represents a TransactionOutput.
                     * @implements ITransactionOutput
                     * @constructor
                     * @param {TW.NEO.Proto.ITransactionOutput=} [properties] Properties to set
                     */
                    function TransactionOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOutput assetId.
                     * @member {string} assetId
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.assetId = "";
    
                    /**
                     * TransactionOutput amount.
                     * @member {Long} amount
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.toAddress = "";
    
                    /**
                     * TransactionOutput changeAddress.
                     * @member {string} changeAddress
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.changeAddress = "";
    
                    /**
                     * Creates a new TransactionOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @static
                     * @param {TW.NEO.Proto.ITransactionOutput=} [properties] Properties to set
                     * @returns {TW.NEO.Proto.TransactionOutput} TransactionOutput instance
                     */
                    TransactionOutput.create = function create(properties) {
                        return new TransactionOutput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.NEO.Proto.TransactionOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @static
                     * @param {TW.NEO.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.assetId);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.amount);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.changeAddress != null && Object.hasOwnProperty.call(message, "changeAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.changeAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEO.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEO.Proto.TransactionOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.assetId = reader.string();
                                break;
                            case 2:
                                message.amount = reader.sint64();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.changeAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionOutput message.
                     * @function verify
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            if (!$util.isString(message.assetId))
                                return "assetId: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            if (!$util.isString(message.changeAddress))
                                return "changeAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEO.Proto.TransactionOutput} TransactionOutput
                     */
                    TransactionOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEO.Proto.TransactionOutput)
                            return object;
                        var message = new $root.TW.NEO.Proto.TransactionOutput();
                        if (object.assetId != null)
                            message.assetId = String(object.assetId);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.changeAddress != null)
                            message.changeAddress = String(object.changeAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @static
                     * @param {TW.NEO.Proto.TransactionOutput} message TransactionOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.assetId = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.toAddress = "";
                            object.changeAddress = "";
                        }
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            object.assetId = message.assetId;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            object.changeAddress = message.changeAddress;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOutput to JSON.
                     * @function toJSON
                     * @memberof TW.NEO.Proto.TransactionOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOutput;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.NEO.Proto
                     * @interface ISigningInput
                     * @property {Array.<TW.NEO.Proto.ITransactionInput>|null} [inputs] SigningInput inputs
                     * @property {Array.<TW.NEO.Proto.ITransactionOutput>|null} [outputs] SigningInput outputs
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {string|null} [gasAssetId] SigningInput gasAssetId
                     * @property {string|null} [gasChangeAddress] SigningInput gasChangeAddress
                     * @property {TW.NEO.Proto.ITransactionPlan|null} [plan] SigningInput plan
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.NEO.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.NEO.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput inputs.
                     * @member {Array.<TW.NEO.Proto.ITransactionInput>} inputs
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.inputs = $util.emptyArray;
    
                    /**
                     * SigningInput outputs.
                     * @member {Array.<TW.NEO.Proto.ITransactionOutput>} outputs
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.outputs = $util.emptyArray;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput gasAssetId.
                     * @member {string} gasAssetId
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasAssetId = "";
    
                    /**
                     * SigningInput gasChangeAddress.
                     * @member {string} gasChangeAddress
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasChangeAddress = "";
    
                    /**
                     * SigningInput plan.
                     * @member {TW.NEO.Proto.ITransactionPlan|null|undefined} plan
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.plan = null;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.NEO.Proto.SigningInput
                     * @static
                     * @param {TW.NEO.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.NEO.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.NEO.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEO.Proto.SigningInput
                     * @static
                     * @param {TW.NEO.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.NEO.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.NEO.Proto.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
                        if (message.gasAssetId != null && Object.hasOwnProperty.call(message, "gasAssetId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.gasAssetId);
                        if (message.gasChangeAddress != null && Object.hasOwnProperty.call(message, "gasChangeAddress"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.gasChangeAddress);
                        if (message.plan != null && Object.hasOwnProperty.call(message, "plan"))
                            $root.TW.NEO.Proto.TransactionPlan.encode(message.plan, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEO.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEO.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEO.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.NEO.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.NEO.Proto.TransactionOutput.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.privateKey = reader.bytes();
                                break;
                            case 4:
                                message.fee = reader.int64();
                                break;
                            case 5:
                                message.gasAssetId = reader.string();
                                break;
                            case 6:
                                message.gasChangeAddress = reader.string();
                                break;
                            case 7:
                                message.plan = $root.TW.NEO.Proto.TransactionPlan.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.NEO.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.NEO.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.NEO.Proto.TransactionOutput.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.gasAssetId != null && message.hasOwnProperty("gasAssetId"))
                            if (!$util.isString(message.gasAssetId))
                                return "gasAssetId: string expected";
                        if (message.gasChangeAddress != null && message.hasOwnProperty("gasChangeAddress"))
                            if (!$util.isString(message.gasChangeAddress))
                                return "gasChangeAddress: string expected";
                        if (message.plan != null && message.hasOwnProperty("plan")) {
                            var error = $root.TW.NEO.Proto.TransactionPlan.verify(message.plan);
                            if (error)
                                return "plan." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEO.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEO.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEO.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.NEO.Proto.SigningInput();
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.NEO.Proto.SigningInput.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.NEO.Proto.SigningInput.inputs: object expected");
                                message.inputs[i] = $root.TW.NEO.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.NEO.Proto.SigningInput.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.NEO.Proto.SigningInput.outputs: object expected");
                                message.outputs[i] = $root.TW.NEO.Proto.TransactionOutput.fromObject(object.outputs[i]);
                            }
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.gasAssetId != null)
                            message.gasAssetId = String(object.gasAssetId);
                        if (object.gasChangeAddress != null)
                            message.gasChangeAddress = String(object.gasChangeAddress);
                        if (object.plan != null) {
                            if (typeof object.plan !== "object")
                                throw TypeError(".TW.NEO.Proto.SigningInput.plan: object expected");
                            message.plan = $root.TW.NEO.Proto.TransactionPlan.fromObject(object.plan);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEO.Proto.SigningInput
                     * @static
                     * @param {TW.NEO.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.gasAssetId = "";
                            object.gasChangeAddress = "";
                            object.plan = null;
                        }
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.NEO.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.NEO.Proto.TransactionOutput.toObject(message.outputs[j], options);
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.gasAssetId != null && message.hasOwnProperty("gasAssetId"))
                            object.gasAssetId = message.gasAssetId;
                        if (message.gasChangeAddress != null && message.hasOwnProperty("gasChangeAddress"))
                            object.gasChangeAddress = message.gasChangeAddress;
                        if (message.plan != null && message.hasOwnProperty("plan"))
                            object.plan = $root.TW.NEO.Proto.TransactionPlan.toObject(message.plan, options);
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.NEO.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.NEO.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {TW.Common.Proto.SigningError|null} [error] SigningOutput error
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.NEO.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.NEO.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @static
                     * @param {TW.NEO.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.NEO.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.NEO.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @static
                     * @param {TW.NEO.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEO.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEO.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEO.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEO.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.NEO.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @static
                     * @param {TW.NEO.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.NEO.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.TransactionOutputPlan = (function() {
    
                    /**
                     * Properties of a TransactionOutputPlan.
                     * @memberof TW.NEO.Proto
                     * @interface ITransactionOutputPlan
                     * @property {Long|null} [amount] TransactionOutputPlan amount
                     * @property {Long|null} [availableAmount] TransactionOutputPlan availableAmount
                     * @property {Long|null} [change] TransactionOutputPlan change
                     * @property {string|null} [assetId] TransactionOutputPlan assetId
                     * @property {string|null} [toAddress] TransactionOutputPlan toAddress
                     * @property {string|null} [changeAddress] TransactionOutputPlan changeAddress
                     */
    
                    /**
                     * Constructs a new TransactionOutputPlan.
                     * @memberof TW.NEO.Proto
                     * @classdesc Represents a TransactionOutputPlan.
                     * @implements ITransactionOutputPlan
                     * @constructor
                     * @param {TW.NEO.Proto.ITransactionOutputPlan=} [properties] Properties to set
                     */
                    function TransactionOutputPlan(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOutputPlan amount.
                     * @member {Long} amount
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @instance
                     */
                    TransactionOutputPlan.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutputPlan availableAmount.
                     * @member {Long} availableAmount
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @instance
                     */
                    TransactionOutputPlan.prototype.availableAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutputPlan change.
                     * @member {Long} change
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @instance
                     */
                    TransactionOutputPlan.prototype.change = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutputPlan assetId.
                     * @member {string} assetId
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @instance
                     */
                    TransactionOutputPlan.prototype.assetId = "";
    
                    /**
                     * TransactionOutputPlan toAddress.
                     * @member {string} toAddress
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @instance
                     */
                    TransactionOutputPlan.prototype.toAddress = "";
    
                    /**
                     * TransactionOutputPlan changeAddress.
                     * @member {string} changeAddress
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @instance
                     */
                    TransactionOutputPlan.prototype.changeAddress = "";
    
                    /**
                     * Creates a new TransactionOutputPlan instance using the specified properties.
                     * @function create
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @static
                     * @param {TW.NEO.Proto.ITransactionOutputPlan=} [properties] Properties to set
                     * @returns {TW.NEO.Proto.TransactionOutputPlan} TransactionOutputPlan instance
                     */
                    TransactionOutputPlan.create = function create(properties) {
                        return new TransactionOutputPlan(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOutputPlan message. Does not implicitly {@link TW.NEO.Proto.TransactionOutputPlan.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @static
                     * @param {TW.NEO.Proto.ITransactionOutputPlan} message TransactionOutputPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutputPlan.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.availableAmount != null && Object.hasOwnProperty.call(message, "availableAmount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.availableAmount);
                        if (message.change != null && Object.hasOwnProperty.call(message, "change"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.change);
                        if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.assetId);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.toAddress);
                        if (message.changeAddress != null && Object.hasOwnProperty.call(message, "changeAddress"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.changeAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionOutputPlan message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEO.Proto.TransactionOutputPlan} TransactionOutputPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutputPlan.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEO.Proto.TransactionOutputPlan();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.availableAmount = reader.int64();
                                break;
                            case 3:
                                message.change = reader.int64();
                                break;
                            case 4:
                                message.assetId = reader.string();
                                break;
                            case 5:
                                message.toAddress = reader.string();
                                break;
                            case 6:
                                message.changeAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionOutputPlan message.
                     * @function verify
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOutputPlan.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (!$util.isInteger(message.availableAmount) && !(message.availableAmount && $util.isInteger(message.availableAmount.low) && $util.isInteger(message.availableAmount.high)))
                                return "availableAmount: integer|Long expected";
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (!$util.isInteger(message.change) && !(message.change && $util.isInteger(message.change.low) && $util.isInteger(message.change.high)))
                                return "change: integer|Long expected";
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            if (!$util.isString(message.assetId))
                                return "assetId: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            if (!$util.isString(message.changeAddress))
                                return "changeAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOutputPlan message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEO.Proto.TransactionOutputPlan} TransactionOutputPlan
                     */
                    TransactionOutputPlan.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEO.Proto.TransactionOutputPlan)
                            return object;
                        var message = new $root.TW.NEO.Proto.TransactionOutputPlan();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.availableAmount != null)
                            if ($util.Long)
                                (message.availableAmount = $util.Long.fromValue(object.availableAmount)).unsigned = false;
                            else if (typeof object.availableAmount === "string")
                                message.availableAmount = parseInt(object.availableAmount, 10);
                            else if (typeof object.availableAmount === "number")
                                message.availableAmount = object.availableAmount;
                            else if (typeof object.availableAmount === "object")
                                message.availableAmount = new $util.LongBits(object.availableAmount.low >>> 0, object.availableAmount.high >>> 0).toNumber();
                        if (object.change != null)
                            if ($util.Long)
                                (message.change = $util.Long.fromValue(object.change)).unsigned = false;
                            else if (typeof object.change === "string")
                                message.change = parseInt(object.change, 10);
                            else if (typeof object.change === "number")
                                message.change = object.change;
                            else if (typeof object.change === "object")
                                message.change = new $util.LongBits(object.change.low >>> 0, object.change.high >>> 0).toNumber();
                        if (object.assetId != null)
                            message.assetId = String(object.assetId);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.changeAddress != null)
                            message.changeAddress = String(object.changeAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOutputPlan message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @static
                     * @param {TW.NEO.Proto.TransactionOutputPlan} message TransactionOutputPlan
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOutputPlan.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.availableAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.availableAmount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.change = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.change = options.longs === String ? "0" : 0;
                            object.assetId = "";
                            object.toAddress = "";
                            object.changeAddress = "";
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (typeof message.availableAmount === "number")
                                object.availableAmount = options.longs === String ? String(message.availableAmount) : message.availableAmount;
                            else
                                object.availableAmount = options.longs === String ? $util.Long.prototype.toString.call(message.availableAmount) : options.longs === Number ? new $util.LongBits(message.availableAmount.low >>> 0, message.availableAmount.high >>> 0).toNumber() : message.availableAmount;
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (typeof message.change === "number")
                                object.change = options.longs === String ? String(message.change) : message.change;
                            else
                                object.change = options.longs === String ? $util.Long.prototype.toString.call(message.change) : options.longs === Number ? new $util.LongBits(message.change.low >>> 0, message.change.high >>> 0).toNumber() : message.change;
                        if (message.assetId != null && message.hasOwnProperty("assetId"))
                            object.assetId = message.assetId;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            object.changeAddress = message.changeAddress;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOutputPlan to JSON.
                     * @function toJSON
                     * @memberof TW.NEO.Proto.TransactionOutputPlan
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOutputPlan.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOutputPlan;
                })();
    
                Proto.TransactionPlan = (function() {
    
                    /**
                     * Properties of a TransactionPlan.
                     * @memberof TW.NEO.Proto
                     * @interface ITransactionPlan
                     * @property {Array.<TW.NEO.Proto.ITransactionOutputPlan>|null} [outputs] TransactionPlan outputs
                     * @property {Array.<TW.NEO.Proto.ITransactionInput>|null} [inputs] TransactionPlan inputs
                     * @property {Long|null} [fee] TransactionPlan fee
                     * @property {TW.Common.Proto.SigningError|null} [error] TransactionPlan error
                     */
    
                    /**
                     * Constructs a new TransactionPlan.
                     * @memberof TW.NEO.Proto
                     * @classdesc Represents a TransactionPlan.
                     * @implements ITransactionPlan
                     * @constructor
                     * @param {TW.NEO.Proto.ITransactionPlan=} [properties] Properties to set
                     */
                    function TransactionPlan(properties) {
                        this.outputs = [];
                        this.inputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionPlan outputs.
                     * @member {Array.<TW.NEO.Proto.ITransactionOutputPlan>} outputs
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.outputs = $util.emptyArray;
    
                    /**
                     * TransactionPlan inputs.
                     * @member {Array.<TW.NEO.Proto.ITransactionInput>} inputs
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.inputs = $util.emptyArray;
    
                    /**
                     * TransactionPlan fee.
                     * @member {Long} fee
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.error = 0;
    
                    /**
                     * Creates a new TransactionPlan instance using the specified properties.
                     * @function create
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @static
                     * @param {TW.NEO.Proto.ITransactionPlan=} [properties] Properties to set
                     * @returns {TW.NEO.Proto.TransactionPlan} TransactionPlan instance
                     */
                    TransactionPlan.create = function create(properties) {
                        return new TransactionPlan(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.NEO.Proto.TransactionPlan.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @static
                     * @param {TW.NEO.Proto.ITransactionPlan} message TransactionPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPlan.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.NEO.Proto.TransactionOutputPlan.encode(message.outputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.NEO.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionPlan message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NEO.Proto.TransactionPlan} TransactionPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPlan.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NEO.Proto.TransactionPlan();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.NEO.Proto.TransactionOutputPlan.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.NEO.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionPlan message.
                     * @function verify
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionPlan.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.NEO.Proto.TransactionOutputPlan.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.NEO.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NEO.Proto.TransactionPlan} TransactionPlan
                     */
                    TransactionPlan.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NEO.Proto.TransactionPlan)
                            return object;
                        var message = new $root.TW.NEO.Proto.TransactionPlan();
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.NEO.Proto.TransactionPlan.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.NEO.Proto.TransactionPlan.outputs: object expected");
                                message.outputs[i] = $root.TW.NEO.Proto.TransactionOutputPlan.fromObject(object.outputs[i]);
                            }
                        }
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.NEO.Proto.TransactionPlan.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.NEO.Proto.TransactionPlan.inputs: object expected");
                                message.inputs[i] = $root.TW.NEO.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @static
                     * @param {TW.NEO.Proto.TransactionPlan} message TransactionPlan
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionPlan.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.outputs = [];
                            object.inputs = [];
                        }
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.NEO.Proto.TransactionOutputPlan.toObject(message.outputs[j], options);
                        }
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.NEO.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionPlan to JSON.
                     * @function toJSON
                     * @memberof TW.NEO.Proto.TransactionPlan
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionPlan.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionPlan;
                })();
    
                return Proto;
            })();
    
            return NEO;
        })();
    
        TW.Nimiq = (function() {
    
            /**
             * Namespace Nimiq.
             * @memberof TW
             * @namespace
             */
            var Nimiq = {};
    
            Nimiq.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Nimiq
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Nimiq.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [destination] SigningInput destination
                     * @property {Long|null} [value] SigningInput value
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {number|null} [validityStartHeight] SigningInput validityStartHeight
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Nimiq.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Nimiq.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput destination.
                     * @member {string} destination
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destination = "";
    
                    /**
                     * SigningInput value.
                     * @member {Long} value
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput validityStartHeight.
                     * @member {number} validityStartHeight
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.validityStartHeight = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Nimiq.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nimiq.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.destination);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.value);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fee);
                        if (message.validityStartHeight != null && Object.hasOwnProperty.call(message, "validityStartHeight"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.validityStartHeight);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nimiq.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nimiq.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.destination = reader.string();
                                break;
                            case 3:
                                message.value = reader.uint64();
                                break;
                            case 4:
                                message.fee = reader.uint64();
                                break;
                            case 5:
                                message.validityStartHeight = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.validityStartHeight != null && message.hasOwnProperty("validityStartHeight"))
                            if (!$util.isInteger(message.validityStartHeight))
                                return "validityStartHeight: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nimiq.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nimiq.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Nimiq.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        if (object.validityStartHeight != null)
                            message.validityStartHeight = object.validityStartHeight >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {TW.Nimiq.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.validityStartHeight = 0;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        if (message.validityStartHeight != null && message.hasOwnProperty("validityStartHeight"))
                            object.validityStartHeight = message.validityStartHeight;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Nimiq.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Nimiq.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Nimiq.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Nimiq.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nimiq.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nimiq.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nimiq.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nimiq.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nimiq.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Nimiq.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {TW.Nimiq.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Nimiq;
        })();
    
        TW.NULS = (function() {
    
            /**
             * Namespace NULS.
             * @memberof TW
             * @namespace
             */
            var NULS = {};
    
            NULS.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.NULS
                 * @namespace
                 */
                var Proto = {};
    
                Proto.TransactionCoinFrom = (function() {
    
                    /**
                     * Properties of a TransactionCoinFrom.
                     * @memberof TW.NULS.Proto
                     * @interface ITransactionCoinFrom
                     * @property {string|null} [fromAddress] TransactionCoinFrom fromAddress
                     * @property {number|null} [assetsChainid] TransactionCoinFrom assetsChainid
                     * @property {number|null} [assetsId] TransactionCoinFrom assetsId
                     * @property {Uint8Array|null} [idAmount] TransactionCoinFrom idAmount
                     * @property {Uint8Array|null} [nonce] TransactionCoinFrom nonce
                     * @property {number|null} [locked] TransactionCoinFrom locked
                     */
    
                    /**
                     * Constructs a new TransactionCoinFrom.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a TransactionCoinFrom.
                     * @implements ITransactionCoinFrom
                     * @constructor
                     * @param {TW.NULS.Proto.ITransactionCoinFrom=} [properties] Properties to set
                     */
                    function TransactionCoinFrom(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionCoinFrom fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @instance
                     */
                    TransactionCoinFrom.prototype.fromAddress = "";
    
                    /**
                     * TransactionCoinFrom assetsChainid.
                     * @member {number} assetsChainid
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @instance
                     */
                    TransactionCoinFrom.prototype.assetsChainid = 0;
    
                    /**
                     * TransactionCoinFrom assetsId.
                     * @member {number} assetsId
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @instance
                     */
                    TransactionCoinFrom.prototype.assetsId = 0;
    
                    /**
                     * TransactionCoinFrom idAmount.
                     * @member {Uint8Array} idAmount
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @instance
                     */
                    TransactionCoinFrom.prototype.idAmount = $util.newBuffer([]);
    
                    /**
                     * TransactionCoinFrom nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @instance
                     */
                    TransactionCoinFrom.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * TransactionCoinFrom locked.
                     * @member {number} locked
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @instance
                     */
                    TransactionCoinFrom.prototype.locked = 0;
    
                    /**
                     * Creates a new TransactionCoinFrom instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @static
                     * @param {TW.NULS.Proto.ITransactionCoinFrom=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.TransactionCoinFrom} TransactionCoinFrom instance
                     */
                    TransactionCoinFrom.create = function create(properties) {
                        return new TransactionCoinFrom(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionCoinFrom message. Does not implicitly {@link TW.NULS.Proto.TransactionCoinFrom.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @static
                     * @param {TW.NULS.Proto.ITransactionCoinFrom} message TransactionCoinFrom message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionCoinFrom.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.assetsChainid != null && Object.hasOwnProperty.call(message, "assetsChainid"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.assetsChainid);
                        if (message.assetsId != null && Object.hasOwnProperty.call(message, "assetsId"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.assetsId);
                        if (message.idAmount != null && Object.hasOwnProperty.call(message, "idAmount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.idAmount);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.nonce);
                        if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.locked);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionCoinFrom message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.TransactionCoinFrom} TransactionCoinFrom
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionCoinFrom.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.TransactionCoinFrom();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.assetsChainid = reader.uint32();
                                break;
                            case 3:
                                message.assetsId = reader.uint32();
                                break;
                            case 4:
                                message.idAmount = reader.bytes();
                                break;
                            case 5:
                                message.nonce = reader.bytes();
                                break;
                            case 6:
                                message.locked = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionCoinFrom message.
                     * @function verify
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionCoinFrom.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.assetsChainid != null && message.hasOwnProperty("assetsChainid"))
                            if (!$util.isInteger(message.assetsChainid))
                                return "assetsChainid: integer expected";
                        if (message.assetsId != null && message.hasOwnProperty("assetsId"))
                            if (!$util.isInteger(message.assetsId))
                                return "assetsId: integer expected";
                        if (message.idAmount != null && message.hasOwnProperty("idAmount"))
                            if (!(message.idAmount && typeof message.idAmount.length === "number" || $util.isString(message.idAmount)))
                                return "idAmount: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.locked != null && message.hasOwnProperty("locked"))
                            if (!$util.isInteger(message.locked))
                                return "locked: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionCoinFrom message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.TransactionCoinFrom} TransactionCoinFrom
                     */
                    TransactionCoinFrom.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.TransactionCoinFrom)
                            return object;
                        var message = new $root.TW.NULS.Proto.TransactionCoinFrom();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.assetsChainid != null)
                            message.assetsChainid = object.assetsChainid >>> 0;
                        if (object.assetsId != null)
                            message.assetsId = object.assetsId >>> 0;
                        if (object.idAmount != null)
                            if (typeof object.idAmount === "string")
                                $util.base64.decode(object.idAmount, message.idAmount = $util.newBuffer($util.base64.length(object.idAmount)), 0);
                            else if (object.idAmount.length)
                                message.idAmount = object.idAmount;
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.locked != null)
                            message.locked = object.locked >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionCoinFrom message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @static
                     * @param {TW.NULS.Proto.TransactionCoinFrom} message TransactionCoinFrom
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionCoinFrom.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.assetsChainid = 0;
                            object.assetsId = 0;
                            if (options.bytes === String)
                                object.idAmount = "";
                            else {
                                object.idAmount = [];
                                if (options.bytes !== Array)
                                    object.idAmount = $util.newBuffer(object.idAmount);
                            }
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            object.locked = 0;
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.assetsChainid != null && message.hasOwnProperty("assetsChainid"))
                            object.assetsChainid = message.assetsChainid;
                        if (message.assetsId != null && message.hasOwnProperty("assetsId"))
                            object.assetsId = message.assetsId;
                        if (message.idAmount != null && message.hasOwnProperty("idAmount"))
                            object.idAmount = options.bytes === String ? $util.base64.encode(message.idAmount, 0, message.idAmount.length) : options.bytes === Array ? Array.prototype.slice.call(message.idAmount) : message.idAmount;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.locked != null && message.hasOwnProperty("locked"))
                            object.locked = message.locked;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionCoinFrom to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.TransactionCoinFrom
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionCoinFrom.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionCoinFrom;
                })();
    
                Proto.TransactionCoinTo = (function() {
    
                    /**
                     * Properties of a TransactionCoinTo.
                     * @memberof TW.NULS.Proto
                     * @interface ITransactionCoinTo
                     * @property {string|null} [toAddress] TransactionCoinTo toAddress
                     * @property {number|null} [assetsChainid] TransactionCoinTo assetsChainid
                     * @property {number|null} [assetsId] TransactionCoinTo assetsId
                     * @property {Uint8Array|null} [idAmount] TransactionCoinTo idAmount
                     * @property {number|null} [lockTime] TransactionCoinTo lockTime
                     */
    
                    /**
                     * Constructs a new TransactionCoinTo.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a TransactionCoinTo.
                     * @implements ITransactionCoinTo
                     * @constructor
                     * @param {TW.NULS.Proto.ITransactionCoinTo=} [properties] Properties to set
                     */
                    function TransactionCoinTo(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionCoinTo toAddress.
                     * @member {string} toAddress
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @instance
                     */
                    TransactionCoinTo.prototype.toAddress = "";
    
                    /**
                     * TransactionCoinTo assetsChainid.
                     * @member {number} assetsChainid
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @instance
                     */
                    TransactionCoinTo.prototype.assetsChainid = 0;
    
                    /**
                     * TransactionCoinTo assetsId.
                     * @member {number} assetsId
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @instance
                     */
                    TransactionCoinTo.prototype.assetsId = 0;
    
                    /**
                     * TransactionCoinTo idAmount.
                     * @member {Uint8Array} idAmount
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @instance
                     */
                    TransactionCoinTo.prototype.idAmount = $util.newBuffer([]);
    
                    /**
                     * TransactionCoinTo lockTime.
                     * @member {number} lockTime
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @instance
                     */
                    TransactionCoinTo.prototype.lockTime = 0;
    
                    /**
                     * Creates a new TransactionCoinTo instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @static
                     * @param {TW.NULS.Proto.ITransactionCoinTo=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.TransactionCoinTo} TransactionCoinTo instance
                     */
                    TransactionCoinTo.create = function create(properties) {
                        return new TransactionCoinTo(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionCoinTo message. Does not implicitly {@link TW.NULS.Proto.TransactionCoinTo.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @static
                     * @param {TW.NULS.Proto.ITransactionCoinTo} message TransactionCoinTo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionCoinTo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.toAddress);
                        if (message.assetsChainid != null && Object.hasOwnProperty.call(message, "assetsChainid"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.assetsChainid);
                        if (message.assetsId != null && Object.hasOwnProperty.call(message, "assetsId"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.assetsId);
                        if (message.idAmount != null && Object.hasOwnProperty.call(message, "idAmount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.idAmount);
                        if (message.lockTime != null && Object.hasOwnProperty.call(message, "lockTime"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.lockTime);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionCoinTo message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.TransactionCoinTo} TransactionCoinTo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionCoinTo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.TransactionCoinTo();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.toAddress = reader.string();
                                break;
                            case 2:
                                message.assetsChainid = reader.uint32();
                                break;
                            case 3:
                                message.assetsId = reader.uint32();
                                break;
                            case 4:
                                message.idAmount = reader.bytes();
                                break;
                            case 5:
                                message.lockTime = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionCoinTo message.
                     * @function verify
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionCoinTo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.assetsChainid != null && message.hasOwnProperty("assetsChainid"))
                            if (!$util.isInteger(message.assetsChainid))
                                return "assetsChainid: integer expected";
                        if (message.assetsId != null && message.hasOwnProperty("assetsId"))
                            if (!$util.isInteger(message.assetsId))
                                return "assetsId: integer expected";
                        if (message.idAmount != null && message.hasOwnProperty("idAmount"))
                            if (!(message.idAmount && typeof message.idAmount.length === "number" || $util.isString(message.idAmount)))
                                return "idAmount: buffer expected";
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime))
                                return "lockTime: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionCoinTo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.TransactionCoinTo} TransactionCoinTo
                     */
                    TransactionCoinTo.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.TransactionCoinTo)
                            return object;
                        var message = new $root.TW.NULS.Proto.TransactionCoinTo();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.assetsChainid != null)
                            message.assetsChainid = object.assetsChainid >>> 0;
                        if (object.assetsId != null)
                            message.assetsId = object.assetsId >>> 0;
                        if (object.idAmount != null)
                            if (typeof object.idAmount === "string")
                                $util.base64.decode(object.idAmount, message.idAmount = $util.newBuffer($util.base64.length(object.idAmount)), 0);
                            else if (object.idAmount.length)
                                message.idAmount = object.idAmount;
                        if (object.lockTime != null)
                            message.lockTime = object.lockTime >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionCoinTo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @static
                     * @param {TW.NULS.Proto.TransactionCoinTo} message TransactionCoinTo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionCoinTo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.toAddress = "";
                            object.assetsChainid = 0;
                            object.assetsId = 0;
                            if (options.bytes === String)
                                object.idAmount = "";
                            else {
                                object.idAmount = [];
                                if (options.bytes !== Array)
                                    object.idAmount = $util.newBuffer(object.idAmount);
                            }
                            object.lockTime = 0;
                        }
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.assetsChainid != null && message.hasOwnProperty("assetsChainid"))
                            object.assetsChainid = message.assetsChainid;
                        if (message.assetsId != null && message.hasOwnProperty("assetsId"))
                            object.assetsId = message.assetsId;
                        if (message.idAmount != null && message.hasOwnProperty("idAmount"))
                            object.idAmount = options.bytes === String ? $util.base64.encode(message.idAmount, 0, message.idAmount.length) : options.bytes === Array ? Array.prototype.slice.call(message.idAmount) : message.idAmount;
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            object.lockTime = message.lockTime;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionCoinTo to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.TransactionCoinTo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionCoinTo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionCoinTo;
                })();
    
                Proto.Signature = (function() {
    
                    /**
                     * Properties of a Signature.
                     * @memberof TW.NULS.Proto
                     * @interface ISignature
                     * @property {number|null} [pkeyLen] Signature pkeyLen
                     * @property {Uint8Array|null} [publicKey] Signature publicKey
                     * @property {number|null} [sigLen] Signature sigLen
                     * @property {Uint8Array|null} [signature] Signature signature
                     */
    
                    /**
                     * Constructs a new Signature.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a Signature.
                     * @implements ISignature
                     * @constructor
                     * @param {TW.NULS.Proto.ISignature=} [properties] Properties to set
                     */
                    function Signature(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signature pkeyLen.
                     * @member {number} pkeyLen
                     * @memberof TW.NULS.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.pkeyLen = 0;
    
                    /**
                     * Signature publicKey.
                     * @member {Uint8Array} publicKey
                     * @memberof TW.NULS.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.publicKey = $util.newBuffer([]);
    
                    /**
                     * Signature sigLen.
                     * @member {number} sigLen
                     * @memberof TW.NULS.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.sigLen = 0;
    
                    /**
                     * Signature signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.NULS.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new Signature instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.Signature
                     * @static
                     * @param {TW.NULS.Proto.ISignature=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.Signature} Signature instance
                     */
                    Signature.create = function create(properties) {
                        return new Signature(properties);
                    };
    
                    /**
                     * Encodes the specified Signature message. Does not implicitly {@link TW.NULS.Proto.Signature.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.Signature
                     * @static
                     * @param {TW.NULS.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.pkeyLen != null && Object.hasOwnProperty.call(message, "pkeyLen"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.pkeyLen);
                        if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
                        if (message.sigLen != null && Object.hasOwnProperty.call(message, "sigLen"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sigLen);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.Signature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.pkeyLen = reader.uint32();
                                break;
                            case 2:
                                message.publicKey = reader.bytes();
                                break;
                            case 3:
                                message.sigLen = reader.uint32();
                                break;
                            case 4:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Signature message.
                     * @function verify
                     * @memberof TW.NULS.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Signature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.pkeyLen != null && message.hasOwnProperty("pkeyLen"))
                            if (!$util.isInteger(message.pkeyLen))
                                return "pkeyLen: integer expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                                return "publicKey: buffer expected";
                        if (message.sigLen != null && message.hasOwnProperty("sigLen"))
                            if (!$util.isInteger(message.sigLen))
                                return "sigLen: integer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.Signature} Signature
                     */
                    Signature.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.Signature)
                            return object;
                        var message = new $root.TW.NULS.Proto.Signature();
                        if (object.pkeyLen != null)
                            message.pkeyLen = object.pkeyLen >>> 0;
                        if (object.publicKey != null)
                            if (typeof object.publicKey === "string")
                                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                            else if (object.publicKey.length)
                                message.publicKey = object.publicKey;
                        if (object.sigLen != null)
                            message.sigLen = object.sigLen >>> 0;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Signature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.Signature
                     * @static
                     * @param {TW.NULS.Proto.Signature} message Signature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Signature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.pkeyLen = 0;
                            if (options.bytes === String)
                                object.publicKey = "";
                            else {
                                object.publicKey = [];
                                if (options.bytes !== Array)
                                    object.publicKey = $util.newBuffer(object.publicKey);
                            }
                            object.sigLen = 0;
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.pkeyLen != null && message.hasOwnProperty("pkeyLen"))
                            object.pkeyLen = message.pkeyLen;
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                        if (message.sigLen != null && message.hasOwnProperty("sigLen"))
                            object.sigLen = message.sigLen;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this Signature to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.Signature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Signature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Signature;
                })();
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.NULS.Proto
                     * @interface ITransaction
                     * @property {number|null} [type] Transaction type
                     * @property {number|null} [timestamp] Transaction timestamp
                     * @property {string|null} [remark] Transaction remark
                     * @property {Uint8Array|null} [txData] Transaction txData
                     * @property {TW.NULS.Proto.ITransactionCoinFrom|null} [input] Transaction input
                     * @property {TW.NULS.Proto.ITransactionCoinTo|null} [output] Transaction output
                     * @property {TW.NULS.Proto.ISignature|null} [txSigs] Transaction txSigs
                     * @property {number|null} [hash] Transaction hash
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.NULS.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction type.
                     * @member {number} type
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.type = 0;
    
                    /**
                     * Transaction timestamp.
                     * @member {number} timestamp
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.timestamp = 0;
    
                    /**
                     * Transaction remark.
                     * @member {string} remark
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.remark = "";
    
                    /**
                     * Transaction txData.
                     * @member {Uint8Array} txData
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.txData = $util.newBuffer([]);
    
                    /**
                     * Transaction input.
                     * @member {TW.NULS.Proto.ITransactionCoinFrom|null|undefined} input
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.input = null;
    
                    /**
                     * Transaction output.
                     * @member {TW.NULS.Proto.ITransactionCoinTo|null|undefined} output
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.output = null;
    
                    /**
                     * Transaction txSigs.
                     * @member {TW.NULS.Proto.ISignature|null|undefined} txSigs
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.txSigs = null;
    
                    /**
                     * Transaction hash.
                     * @member {number} hash
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.hash = 0;
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {TW.NULS.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.NULS.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {TW.NULS.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp);
                        if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.remark);
                        if (message.txData != null && Object.hasOwnProperty.call(message, "txData"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.txData);
                        if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                            $root.TW.NULS.Proto.TransactionCoinFrom.encode(message.input, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.output != null && Object.hasOwnProperty.call(message, "output"))
                            $root.TW.NULS.Proto.TransactionCoinTo.encode(message.output, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.txSigs != null && Object.hasOwnProperty.call(message, "txSigs"))
                            $root.TW.NULS.Proto.Signature.encode(message.txSigs, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.hash);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.uint32();
                                break;
                            case 2:
                                message.timestamp = reader.uint32();
                                break;
                            case 3:
                                message.remark = reader.string();
                                break;
                            case 4:
                                message.txData = reader.bytes();
                                break;
                            case 5:
                                message.input = $root.TW.NULS.Proto.TransactionCoinFrom.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.output = $root.TW.NULS.Proto.TransactionCoinTo.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.txSigs = $root.TW.NULS.Proto.Signature.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.hash = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isInteger(message.type))
                                return "type: integer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp))
                                return "timestamp: integer expected";
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            if (!$util.isString(message.remark))
                                return "remark: string expected";
                        if (message.txData != null && message.hasOwnProperty("txData"))
                            if (!(message.txData && typeof message.txData.length === "number" || $util.isString(message.txData)))
                                return "txData: buffer expected";
                        if (message.input != null && message.hasOwnProperty("input")) {
                            var error = $root.TW.NULS.Proto.TransactionCoinFrom.verify(message.input);
                            if (error)
                                return "input." + error;
                        }
                        if (message.output != null && message.hasOwnProperty("output")) {
                            var error = $root.TW.NULS.Proto.TransactionCoinTo.verify(message.output);
                            if (error)
                                return "output." + error;
                        }
                        if (message.txSigs != null && message.hasOwnProperty("txSigs")) {
                            var error = $root.TW.NULS.Proto.Signature.verify(message.txSigs);
                            if (error)
                                return "txSigs." + error;
                        }
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!$util.isInteger(message.hash))
                                return "hash: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.Transaction)
                            return object;
                        var message = new $root.TW.NULS.Proto.Transaction();
                        if (object.type != null)
                            message.type = object.type >>> 0;
                        if (object.timestamp != null)
                            message.timestamp = object.timestamp >>> 0;
                        if (object.remark != null)
                            message.remark = String(object.remark);
                        if (object.txData != null)
                            if (typeof object.txData === "string")
                                $util.base64.decode(object.txData, message.txData = $util.newBuffer($util.base64.length(object.txData)), 0);
                            else if (object.txData.length)
                                message.txData = object.txData;
                        if (object.input != null) {
                            if (typeof object.input !== "object")
                                throw TypeError(".TW.NULS.Proto.Transaction.input: object expected");
                            message.input = $root.TW.NULS.Proto.TransactionCoinFrom.fromObject(object.input);
                        }
                        if (object.output != null) {
                            if (typeof object.output !== "object")
                                throw TypeError(".TW.NULS.Proto.Transaction.output: object expected");
                            message.output = $root.TW.NULS.Proto.TransactionCoinTo.fromObject(object.output);
                        }
                        if (object.txSigs != null) {
                            if (typeof object.txSigs !== "object")
                                throw TypeError(".TW.NULS.Proto.Transaction.txSigs: object expected");
                            message.txSigs = $root.TW.NULS.Proto.Signature.fromObject(object.txSigs);
                        }
                        if (object.hash != null)
                            message.hash = object.hash >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {TW.NULS.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.type = 0;
                            object.timestamp = 0;
                            object.remark = "";
                            if (options.bytes === String)
                                object.txData = "";
                            else {
                                object.txData = [];
                                if (options.bytes !== Array)
                                    object.txData = $util.newBuffer(object.txData);
                            }
                            object.input = null;
                            object.output = null;
                            object.txSigs = null;
                            object.hash = 0;
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = message.timestamp;
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            object.remark = message.remark;
                        if (message.txData != null && message.hasOwnProperty("txData"))
                            object.txData = options.bytes === String ? $util.base64.encode(message.txData, 0, message.txData.length) : options.bytes === Array ? Array.prototype.slice.call(message.txData) : message.txData;
                        if (message.input != null && message.hasOwnProperty("input"))
                            object.input = $root.TW.NULS.Proto.TransactionCoinFrom.toObject(message.input, options);
                        if (message.output != null && message.hasOwnProperty("output"))
                            object.output = $root.TW.NULS.Proto.TransactionCoinTo.toObject(message.output, options);
                        if (message.txSigs != null && message.hasOwnProperty("txSigs"))
                            object.txSigs = $root.TW.NULS.Proto.Signature.toObject(message.txSigs, options);
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = message.hash;
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.NULS.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [from] SigningInput from
                     * @property {string|null} [to] SigningInput to
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {number|null} [chainId] SigningInput chainId
                     * @property {number|null} [idassetsId] SigningInput idassetsId
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {string|null} [remark] SigningInput remark
                     * @property {Uint8Array|null} [balance] SigningInput balance
                     * @property {number|null} [timestamp] SigningInput timestamp
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.NULS.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput from.
                     * @member {string} from
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.from = "";
    
                    /**
                     * SigningInput to.
                     * @member {string} to
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.to = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput chainId.
                     * @member {number} chainId
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = 0;
    
                    /**
                     * SigningInput idassetsId.
                     * @member {number} idassetsId
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.idassetsId = 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput remark.
                     * @member {string} remark
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.remark = "";
    
                    /**
                     * SigningInput balance.
                     * @member {Uint8Array} balance
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.balance = $util.newBuffer([]);
    
                    /**
                     * SigningInput timestamp.
                     * @member {number} timestamp
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.SigningInput
                     * @static
                     * @param {TW.NULS.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.NULS.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.SigningInput
                     * @static
                     * @param {TW.NULS.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.from);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.to);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.amount);
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.chainId);
                        if (message.idassetsId != null && Object.hasOwnProperty.call(message, "idassetsId"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.idassetsId);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.nonce);
                        if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.remark);
                        if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.balance);
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.timestamp);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.from = reader.string();
                                break;
                            case 3:
                                message.to = reader.string();
                                break;
                            case 4:
                                message.amount = reader.bytes();
                                break;
                            case 5:
                                message.chainId = reader.uint32();
                                break;
                            case 6:
                                message.idassetsId = reader.uint32();
                                break;
                            case 7:
                                message.nonce = reader.bytes();
                                break;
                            case 8:
                                message.remark = reader.string();
                                break;
                            case 9:
                                message.balance = reader.bytes();
                                break;
                            case 10:
                                message.timestamp = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.NULS.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!$util.isString(message.from))
                                return "from: string expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isInteger(message.chainId))
                                return "chainId: integer expected";
                        if (message.idassetsId != null && message.hasOwnProperty("idassetsId"))
                            if (!$util.isInteger(message.idassetsId))
                                return "idassetsId: integer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            if (!$util.isString(message.remark))
                                return "remark: string expected";
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            if (!(message.balance && typeof message.balance.length === "number" || $util.isString(message.balance)))
                                return "balance: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp))
                                return "timestamp: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.NULS.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.from != null)
                            message.from = String(object.from);
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.chainId != null)
                            message.chainId = object.chainId >>> 0;
                        if (object.idassetsId != null)
                            message.idassetsId = object.idassetsId >>> 0;
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.remark != null)
                            message.remark = String(object.remark);
                        if (object.balance != null)
                            if (typeof object.balance === "string")
                                $util.base64.decode(object.balance, message.balance = $util.newBuffer($util.base64.length(object.balance)), 0);
                            else if (object.balance.length)
                                message.balance = object.balance;
                        if (object.timestamp != null)
                            message.timestamp = object.timestamp >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.SigningInput
                     * @static
                     * @param {TW.NULS.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.from = "";
                            object.to = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            object.chainId = 0;
                            object.idassetsId = 0;
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            object.remark = "";
                            if (options.bytes === String)
                                object.balance = "";
                            else {
                                object.balance = [];
                                if (options.bytes !== Array)
                                    object.balance = $util.newBuffer(object.balance);
                            }
                            object.timestamp = 0;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = message.from;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.idassetsId != null && message.hasOwnProperty("idassetsId"))
                            object.idassetsId = message.idassetsId;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            object.remark = message.remark;
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            object.balance = options.bytes === String ? $util.base64.encode(message.balance, 0, message.balance.length) : options.bytes === Array ? Array.prototype.slice.call(message.balance) : message.balance;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = message.timestamp;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.NULS.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.NULS.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {TW.NULS.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.NULS.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {TW.NULS.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.NULS.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {TW.NULS.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return NULS;
        })();
    
        TW.Oasis = (function() {
    
            /**
             * Namespace Oasis.
             * @memberof TW
             * @namespace
             */
            var Oasis = {};
    
            Oasis.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Oasis
                 * @namespace
                 */
                var Proto = {};
    
                Proto.TransferMessage = (function() {
    
                    /**
                     * Properties of a TransferMessage.
                     * @memberof TW.Oasis.Proto
                     * @interface ITransferMessage
                     * @property {string|null} [to] TransferMessage to
                     * @property {Long|null} [gasPrice] TransferMessage gasPrice
                     * @property {string|null} [gasAmount] TransferMessage gasAmount
                     * @property {string|null} [amount] TransferMessage amount
                     * @property {Long|null} [nonce] TransferMessage nonce
                     * @property {string|null} [context] TransferMessage context
                     */
    
                    /**
                     * Constructs a new TransferMessage.
                     * @memberof TW.Oasis.Proto
                     * @classdesc Represents a TransferMessage.
                     * @implements ITransferMessage
                     * @constructor
                     * @param {TW.Oasis.Proto.ITransferMessage=} [properties] Properties to set
                     */
                    function TransferMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferMessage to.
                     * @member {string} to
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.to = "";
    
                    /**
                     * TransferMessage gasPrice.
                     * @member {Long} gasPrice
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.gasPrice = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TransferMessage gasAmount.
                     * @member {string} gasAmount
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.gasAmount = "";
    
                    /**
                     * TransferMessage amount.
                     * @member {string} amount
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.amount = "";
    
                    /**
                     * TransferMessage nonce.
                     * @member {Long} nonce
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TransferMessage context.
                     * @member {string} context
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.context = "";
    
                    /**
                     * Creates a new TransferMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @static
                     * @param {TW.Oasis.Proto.ITransferMessage=} [properties] Properties to set
                     * @returns {TW.Oasis.Proto.TransferMessage} TransferMessage instance
                     */
                    TransferMessage.create = function create(properties) {
                        return new TransferMessage(properties);
                    };
    
                    /**
                     * Encodes the specified TransferMessage message. Does not implicitly {@link TW.Oasis.Proto.TransferMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @static
                     * @param {TW.Oasis.Proto.ITransferMessage} message TransferMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.to);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.gasPrice);
                        if (message.gasAmount != null && Object.hasOwnProperty.call(message, "gasAmount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.gasAmount);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.amount);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.nonce);
                        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.context);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransferMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Oasis.Proto.TransferMessage} TransferMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Oasis.Proto.TransferMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.to = reader.string();
                                break;
                            case 2:
                                message.gasPrice = reader.uint64();
                                break;
                            case 3:
                                message.gasAmount = reader.string();
                                break;
                            case 4:
                                message.amount = reader.string();
                                break;
                            case 5:
                                message.nonce = reader.uint64();
                                break;
                            case 6:
                                message.context = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransferMessage message.
                     * @function verify
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isInteger(message.gasPrice) && !(message.gasPrice && $util.isInteger(message.gasPrice.low) && $util.isInteger(message.gasPrice.high)))
                                return "gasPrice: integer|Long expected";
                        if (message.gasAmount != null && message.hasOwnProperty("gasAmount"))
                            if (!$util.isString(message.gasAmount))
                                return "gasAmount: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.context != null && message.hasOwnProperty("context"))
                            if (!$util.isString(message.context))
                                return "context: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Oasis.Proto.TransferMessage} TransferMessage
                     */
                    TransferMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Oasis.Proto.TransferMessage)
                            return object;
                        var message = new $root.TW.Oasis.Proto.TransferMessage();
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.gasPrice != null)
                            if ($util.Long)
                                (message.gasPrice = $util.Long.fromValue(object.gasPrice)).unsigned = true;
                            else if (typeof object.gasPrice === "string")
                                message.gasPrice = parseInt(object.gasPrice, 10);
                            else if (typeof object.gasPrice === "number")
                                message.gasPrice = object.gasPrice;
                            else if (typeof object.gasPrice === "object")
                                message.gasPrice = new $util.LongBits(object.gasPrice.low >>> 0, object.gasPrice.high >>> 0).toNumber(true);
                        if (object.gasAmount != null)
                            message.gasAmount = String(object.gasAmount);
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.context != null)
                            message.context = String(object.context);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @static
                     * @param {TW.Oasis.Proto.TransferMessage} message TransferMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.to = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasPrice = options.longs === String ? "0" : 0;
                            object.gasAmount = "";
                            object.amount = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            object.context = "";
                        }
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (typeof message.gasPrice === "number")
                                object.gasPrice = options.longs === String ? String(message.gasPrice) : message.gasPrice;
                            else
                                object.gasPrice = options.longs === String ? $util.Long.prototype.toString.call(message.gasPrice) : options.longs === Number ? new $util.LongBits(message.gasPrice.low >>> 0, message.gasPrice.high >>> 0).toNumber(true) : message.gasPrice;
                        if (message.gasAmount != null && message.hasOwnProperty("gasAmount"))
                            object.gasAmount = message.gasAmount;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.context != null && message.hasOwnProperty("context"))
                            object.context = message.context;
                        return object;
                    };
    
                    /**
                     * Converts this TransferMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Oasis.Proto.TransferMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferMessage;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Oasis.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Oasis.Proto.ITransferMessage|null} [transfer] SigningInput transfer
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Oasis.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Oasis.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput transfer.
                     * @member {TW.Oasis.Proto.ITransferMessage|null|undefined} transfer
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transfer = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput message.
                     * @member {"transfer"|undefined} message
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "message", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @static
                     * @param {TW.Oasis.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Oasis.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Oasis.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @static
                     * @param {TW.Oasis.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.Oasis.Proto.TransferMessage.encode(message.transfer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Oasis.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Oasis.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.transfer = $root.TW.Oasis.Proto.TransferMessage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.message = 1;
                            {
                                var error = $root.TW.Oasis.Proto.TransferMessage.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Oasis.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Oasis.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Oasis.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.Oasis.Proto.SigningInput.transfer: object expected");
                            message.transfer = $root.TW.Oasis.Proto.TransferMessage.fromObject(object.transfer);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @static
                     * @param {TW.Oasis.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.Oasis.Proto.TransferMessage.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.message = "transfer";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Oasis.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Oasis.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Oasis.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Oasis.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @static
                     * @param {TW.Oasis.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Oasis.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Oasis.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @static
                     * @param {TW.Oasis.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Oasis.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Oasis.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Oasis.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Oasis.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Oasis.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @static
                     * @param {TW.Oasis.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Oasis.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Oasis;
        })();
    
        TW.Ontology = (function() {
    
            /**
             * Namespace Ontology.
             * @memberof TW
             * @namespace
             */
            var Ontology = {};
    
            Ontology.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Ontology
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Ontology.Proto
                     * @interface ISigningInput
                     * @property {string|null} [contract] SigningInput contract
                     * @property {string|null} [method] SigningInput method
                     * @property {Uint8Array|null} [ownerPrivateKey] SigningInput ownerPrivateKey
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [payerPrivateKey] SigningInput payerPrivateKey
                     * @property {Long|null} [gasPrice] SigningInput gasPrice
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [queryAddress] SigningInput queryAddress
                     * @property {number|null} [nonce] SigningInput nonce
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Ontology.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Ontology.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput contract.
                     * @member {string} contract
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.contract = "";
    
                    /**
                     * SigningInput method.
                     * @member {string} method
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.method = "";
    
                    /**
                     * SigningInput ownerPrivateKey.
                     * @member {Uint8Array} ownerPrivateKey
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.ownerPrivateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput payerPrivateKey.
                     * @member {Uint8Array} payerPrivateKey
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payerPrivateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Long} gasPrice
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput queryAddress.
                     * @member {string} queryAddress
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.queryAddress = "";
    
                    /**
                     * SigningInput nonce.
                     * @member {number} nonce
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Ontology.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ontology.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contract);
                        if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.method);
                        if (message.ownerPrivateKey != null && Object.hasOwnProperty.call(message, "ownerPrivateKey"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ownerPrivateKey);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.amount);
                        if (message.payerPrivateKey != null && Object.hasOwnProperty.call(message, "payerPrivateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payerPrivateKey);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.gasLimit);
                        if (message.queryAddress != null && Object.hasOwnProperty.call(message, "queryAddress"))
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.queryAddress);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.nonce);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ontology.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ontology.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contract = reader.string();
                                break;
                            case 2:
                                message.method = reader.string();
                                break;
                            case 3:
                                message.ownerPrivateKey = reader.bytes();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.amount = reader.uint64();
                                break;
                            case 6:
                                message.payerPrivateKey = reader.bytes();
                                break;
                            case 7:
                                message.gasPrice = reader.uint64();
                                break;
                            case 8:
                                message.gasLimit = reader.uint64();
                                break;
                            case 9:
                                message.queryAddress = reader.string();
                                break;
                            case 10:
                                message.nonce = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            if (!$util.isString(message.contract))
                                return "contract: string expected";
                        if (message.method != null && message.hasOwnProperty("method"))
                            if (!$util.isString(message.method))
                                return "method: string expected";
                        if (message.ownerPrivateKey != null && message.hasOwnProperty("ownerPrivateKey"))
                            if (!(message.ownerPrivateKey && typeof message.ownerPrivateKey.length === "number" || $util.isString(message.ownerPrivateKey)))
                                return "ownerPrivateKey: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.payerPrivateKey != null && message.hasOwnProperty("payerPrivateKey"))
                            if (!(message.payerPrivateKey && typeof message.payerPrivateKey.length === "number" || $util.isString(message.payerPrivateKey)))
                                return "payerPrivateKey: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isInteger(message.gasPrice) && !(message.gasPrice && $util.isInteger(message.gasPrice.low) && $util.isInteger(message.gasPrice.high)))
                                return "gasPrice: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.queryAddress != null && message.hasOwnProperty("queryAddress"))
                            if (!$util.isString(message.queryAddress))
                                return "queryAddress: string expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce))
                                return "nonce: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ontology.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ontology.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Ontology.Proto.SigningInput();
                        if (object.contract != null)
                            message.contract = String(object.contract);
                        if (object.method != null)
                            message.method = String(object.method);
                        if (object.ownerPrivateKey != null)
                            if (typeof object.ownerPrivateKey === "string")
                                $util.base64.decode(object.ownerPrivateKey, message.ownerPrivateKey = $util.newBuffer($util.base64.length(object.ownerPrivateKey)), 0);
                            else if (object.ownerPrivateKey.length)
                                message.ownerPrivateKey = object.ownerPrivateKey;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.payerPrivateKey != null)
                            if (typeof object.payerPrivateKey === "string")
                                $util.base64.decode(object.payerPrivateKey, message.payerPrivateKey = $util.newBuffer($util.base64.length(object.payerPrivateKey)), 0);
                            else if (object.payerPrivateKey.length)
                                message.payerPrivateKey = object.payerPrivateKey;
                        if (object.gasPrice != null)
                            if ($util.Long)
                                (message.gasPrice = $util.Long.fromValue(object.gasPrice)).unsigned = true;
                            else if (typeof object.gasPrice === "string")
                                message.gasPrice = parseInt(object.gasPrice, 10);
                            else if (typeof object.gasPrice === "number")
                                message.gasPrice = object.gasPrice;
                            else if (typeof object.gasPrice === "object")
                                message.gasPrice = new $util.LongBits(object.gasPrice.low >>> 0, object.gasPrice.high >>> 0).toNumber(true);
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.queryAddress != null)
                            message.queryAddress = String(object.queryAddress);
                        if (object.nonce != null)
                            message.nonce = object.nonce >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {TW.Ontology.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contract = "";
                            object.method = "";
                            if (options.bytes === String)
                                object.ownerPrivateKey = "";
                            else {
                                object.ownerPrivateKey = [];
                                if (options.bytes !== Array)
                                    object.ownerPrivateKey = $util.newBuffer(object.ownerPrivateKey);
                            }
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.payerPrivateKey = "";
                            else {
                                object.payerPrivateKey = [];
                                if (options.bytes !== Array)
                                    object.payerPrivateKey = $util.newBuffer(object.payerPrivateKey);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasPrice = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            object.queryAddress = "";
                            object.nonce = 0;
                        }
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            object.contract = message.contract;
                        if (message.method != null && message.hasOwnProperty("method"))
                            object.method = message.method;
                        if (message.ownerPrivateKey != null && message.hasOwnProperty("ownerPrivateKey"))
                            object.ownerPrivateKey = options.bytes === String ? $util.base64.encode(message.ownerPrivateKey, 0, message.ownerPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerPrivateKey) : message.ownerPrivateKey;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.payerPrivateKey != null && message.hasOwnProperty("payerPrivateKey"))
                            object.payerPrivateKey = options.bytes === String ? $util.base64.encode(message.payerPrivateKey, 0, message.payerPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.payerPrivateKey) : message.payerPrivateKey;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (typeof message.gasPrice === "number")
                                object.gasPrice = options.longs === String ? String(message.gasPrice) : message.gasPrice;
                            else
                                object.gasPrice = options.longs === String ? $util.Long.prototype.toString.call(message.gasPrice) : options.longs === Number ? new $util.LongBits(message.gasPrice.low >>> 0, message.gasPrice.high >>> 0).toNumber(true) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.queryAddress != null && message.hasOwnProperty("queryAddress"))
                            object.queryAddress = message.queryAddress;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = message.nonce;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Ontology.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Ontology.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Ontology.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Ontology.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ontology.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ontology.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ontology.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ontology.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ontology.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Ontology.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {TW.Ontology.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Ontology;
        })();
    
        TW.Polkadot = (function() {
    
            /**
             * Namespace Polkadot.
             * @memberof TW
             * @namespace
             */
            var Polkadot = {};
    
            Polkadot.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Polkadot
                 * @namespace
                 */
                var Proto = {};
    
                /**
                 * Network enum.
                 * @name TW.Polkadot.Proto.Network
                 * @enum {number}
                 * @property {number} POLKADOT=0 POLKADOT value
                 * @property {number} KUSAMA=2 KUSAMA value
                 */
                Proto.Network = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "POLKADOT"] = 0;
                    values[valuesById[2] = "KUSAMA"] = 2;
                    return values;
                })();
    
                /**
                 * RewardDestination enum.
                 * @name TW.Polkadot.Proto.RewardDestination
                 * @enum {number}
                 * @property {number} STAKED=0 STAKED value
                 * @property {number} STASH=1 STASH value
                 * @property {number} CONTROLLER=2 CONTROLLER value
                 */
                Proto.RewardDestination = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STAKED"] = 0;
                    values[valuesById[1] = "STASH"] = 1;
                    values[valuesById[2] = "CONTROLLER"] = 2;
                    return values;
                })();
    
                Proto.Era = (function() {
    
                    /**
                     * Properties of an Era.
                     * @memberof TW.Polkadot.Proto
                     * @interface IEra
                     * @property {Long|null} [blockNumber] Era blockNumber
                     * @property {Long|null} [period] Era period
                     */
    
                    /**
                     * Constructs a new Era.
                     * @memberof TW.Polkadot.Proto
                     * @classdesc Represents an Era.
                     * @implements IEra
                     * @constructor
                     * @param {TW.Polkadot.Proto.IEra=} [properties] Properties to set
                     */
                    function Era(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Era blockNumber.
                     * @member {Long} blockNumber
                     * @memberof TW.Polkadot.Proto.Era
                     * @instance
                     */
                    Era.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Era period.
                     * @member {Long} period
                     * @memberof TW.Polkadot.Proto.Era
                     * @instance
                     */
                    Era.prototype.period = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new Era instance using the specified properties.
                     * @function create
                     * @memberof TW.Polkadot.Proto.Era
                     * @static
                     * @param {TW.Polkadot.Proto.IEra=} [properties] Properties to set
                     * @returns {TW.Polkadot.Proto.Era} Era instance
                     */
                    Era.create = function create(properties) {
                        return new Era(properties);
                    };
    
                    /**
                     * Encodes the specified Era message. Does not implicitly {@link TW.Polkadot.Proto.Era.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Polkadot.Proto.Era
                     * @static
                     * @param {TW.Polkadot.Proto.IEra} message Era message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Era.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.blockNumber != null && Object.hasOwnProperty.call(message, "blockNumber"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.blockNumber);
                        if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.period);
                        return writer;
                    };
    
                    /**
                     * Decodes an Era message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Polkadot.Proto.Era
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Polkadot.Proto.Era} Era
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Era.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Era();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.blockNumber = reader.uint64();
                                break;
                            case 2:
                                message.period = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Era message.
                     * @function verify
                     * @memberof TW.Polkadot.Proto.Era
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Era.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                            if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                                return "blockNumber: integer|Long expected";
                        if (message.period != null && message.hasOwnProperty("period"))
                            if (!$util.isInteger(message.period) && !(message.period && $util.isInteger(message.period.low) && $util.isInteger(message.period.high)))
                                return "period: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an Era message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Polkadot.Proto.Era
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Polkadot.Proto.Era} Era
                     */
                    Era.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Polkadot.Proto.Era)
                            return object;
                        var message = new $root.TW.Polkadot.Proto.Era();
                        if (object.blockNumber != null)
                            if ($util.Long)
                                (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = true;
                            else if (typeof object.blockNumber === "string")
                                message.blockNumber = parseInt(object.blockNumber, 10);
                            else if (typeof object.blockNumber === "number")
                                message.blockNumber = object.blockNumber;
                            else if (typeof object.blockNumber === "object")
                                message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber(true);
                        if (object.period != null)
                            if ($util.Long)
                                (message.period = $util.Long.fromValue(object.period)).unsigned = true;
                            else if (typeof object.period === "string")
                                message.period = parseInt(object.period, 10);
                            else if (typeof object.period === "number")
                                message.period = object.period;
                            else if (typeof object.period === "object")
                                message.period = new $util.LongBits(object.period.low >>> 0, object.period.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Era message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Polkadot.Proto.Era
                     * @static
                     * @param {TW.Polkadot.Proto.Era} message Era
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Era.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.blockNumber = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.period = options.longs === String ? "0" : 0;
                        }
                        if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                            if (typeof message.blockNumber === "number")
                                object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                            else
                                object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber(true) : message.blockNumber;
                        if (message.period != null && message.hasOwnProperty("period"))
                            if (typeof message.period === "number")
                                object.period = options.longs === String ? String(message.period) : message.period;
                            else
                                object.period = options.longs === String ? $util.Long.prototype.toString.call(message.period) : options.longs === Number ? new $util.LongBits(message.period.low >>> 0, message.period.high >>> 0).toNumber(true) : message.period;
                        return object;
                    };
    
                    /**
                     * Converts this Era to JSON.
                     * @function toJSON
                     * @memberof TW.Polkadot.Proto.Era
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Era.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Era;
                })();
    
                Proto.Balance = (function() {
    
                    /**
                     * Properties of a Balance.
                     * @memberof TW.Polkadot.Proto
                     * @interface IBalance
                     * @property {TW.Polkadot.Proto.Balance.ITransfer|null} [transfer] Balance transfer
                     */
    
                    /**
                     * Constructs a new Balance.
                     * @memberof TW.Polkadot.Proto
                     * @classdesc Represents a Balance.
                     * @implements IBalance
                     * @constructor
                     * @param {TW.Polkadot.Proto.IBalance=} [properties] Properties to set
                     */
                    function Balance(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Balance transfer.
                     * @member {TW.Polkadot.Proto.Balance.ITransfer|null|undefined} transfer
                     * @memberof TW.Polkadot.Proto.Balance
                     * @instance
                     */
                    Balance.prototype.transfer = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Balance messageOneof.
                     * @member {"transfer"|undefined} messageOneof
                     * @memberof TW.Polkadot.Proto.Balance
                     * @instance
                     */
                    Object.defineProperty(Balance.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Balance instance using the specified properties.
                     * @function create
                     * @memberof TW.Polkadot.Proto.Balance
                     * @static
                     * @param {TW.Polkadot.Proto.IBalance=} [properties] Properties to set
                     * @returns {TW.Polkadot.Proto.Balance} Balance instance
                     */
                    Balance.create = function create(properties) {
                        return new Balance(properties);
                    };
    
                    /**
                     * Encodes the specified Balance message. Does not implicitly {@link TW.Polkadot.Proto.Balance.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Polkadot.Proto.Balance
                     * @static
                     * @param {TW.Polkadot.Proto.IBalance} message Balance message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Balance.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.Polkadot.Proto.Balance.Transfer.encode(message.transfer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Balance message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Polkadot.Proto.Balance
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Polkadot.Proto.Balance} Balance
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Balance.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Balance();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transfer = $root.TW.Polkadot.Proto.Balance.Transfer.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Balance message.
                     * @function verify
                     * @memberof TW.Polkadot.Proto.Balance
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Balance.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Balance.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Balance message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Polkadot.Proto.Balance
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Polkadot.Proto.Balance} Balance
                     */
                    Balance.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Polkadot.Proto.Balance)
                            return object;
                        var message = new $root.TW.Polkadot.Proto.Balance();
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Balance.transfer: object expected");
                            message.transfer = $root.TW.Polkadot.Proto.Balance.Transfer.fromObject(object.transfer);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Balance message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Polkadot.Proto.Balance
                     * @static
                     * @param {TW.Polkadot.Proto.Balance} message Balance
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Balance.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.Polkadot.Proto.Balance.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.messageOneof = "transfer";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Balance to JSON.
                     * @function toJSON
                     * @memberof TW.Polkadot.Proto.Balance
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Balance.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Balance.Transfer = (function() {
    
                        /**
                         * Properties of a Transfer.
                         * @memberof TW.Polkadot.Proto.Balance
                         * @interface ITransfer
                         * @property {string|null} [toAddress] Transfer toAddress
                         * @property {Uint8Array|null} [value] Transfer value
                         */
    
                        /**
                         * Constructs a new Transfer.
                         * @memberof TW.Polkadot.Proto.Balance
                         * @classdesc Represents a Transfer.
                         * @implements ITransfer
                         * @constructor
                         * @param {TW.Polkadot.Proto.Balance.ITransfer=} [properties] Properties to set
                         */
                        function Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Transfer toAddress.
                         * @member {string} toAddress
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @instance
                         */
                        Transfer.prototype.toAddress = "";
    
                        /**
                         * Transfer value.
                         * @member {Uint8Array} value
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @instance
                         */
                        Transfer.prototype.value = $util.newBuffer([]);
    
                        /**
                         * Creates a new Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @static
                         * @param {TW.Polkadot.Proto.Balance.ITransfer=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Balance.Transfer} Transfer instance
                         */
                        Transfer.create = function create(properties) {
                            return new Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified Transfer message. Does not implicitly {@link TW.Polkadot.Proto.Balance.Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @static
                         * @param {TW.Polkadot.Proto.Balance.ITransfer} message Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.toAddress);
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                            return writer;
                        };
    
                        /**
                         * Decodes a Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Balance.Transfer} Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Balance.Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.toAddress = reader.string();
                                    break;
                                case 2:
                                    message.value = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Transfer message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                                if (!$util.isString(message.toAddress))
                                    return "toAddress: string expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                    return "value: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Balance.Transfer} Transfer
                         */
                        Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Balance.Transfer)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Balance.Transfer();
                            if (object.toAddress != null)
                                message.toAddress = String(object.toAddress);
                            if (object.value != null)
                                if (typeof object.value === "string")
                                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                                else if (object.value.length)
                                    message.value = object.value;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @static
                         * @param {TW.Polkadot.Proto.Balance.Transfer} message Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.toAddress = "";
                                if (options.bytes === String)
                                    object.value = "";
                                else {
                                    object.value = [];
                                    if (options.bytes !== Array)
                                        object.value = $util.newBuffer(object.value);
                                }
                            }
                            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                                object.toAddress = message.toAddress;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                            return object;
                        };
    
                        /**
                         * Converts this Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Balance.Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Transfer;
                    })();
    
                    return Balance;
                })();
    
                Proto.Staking = (function() {
    
                    /**
                     * Properties of a Staking.
                     * @memberof TW.Polkadot.Proto
                     * @interface IStaking
                     * @property {TW.Polkadot.Proto.Staking.IBond|null} [bond] Staking bond
                     * @property {TW.Polkadot.Proto.Staking.IBondAndNominate|null} [bondAndNominate] Staking bondAndNominate
                     * @property {TW.Polkadot.Proto.Staking.IBondExtra|null} [bondExtra] Staking bondExtra
                     * @property {TW.Polkadot.Proto.Staking.IUnbond|null} [unbond] Staking unbond
                     * @property {TW.Polkadot.Proto.Staking.IWithdrawUnbonded|null} [withdrawUnbonded] Staking withdrawUnbonded
                     * @property {TW.Polkadot.Proto.Staking.INominate|null} [nominate] Staking nominate
                     * @property {TW.Polkadot.Proto.Staking.IChill|null} [chill] Staking chill
                     * @property {TW.Polkadot.Proto.Staking.IChillAndUnbond|null} [chillAndUnbond] Staking chillAndUnbond
                     */
    
                    /**
                     * Constructs a new Staking.
                     * @memberof TW.Polkadot.Proto
                     * @classdesc Represents a Staking.
                     * @implements IStaking
                     * @constructor
                     * @param {TW.Polkadot.Proto.IStaking=} [properties] Properties to set
                     */
                    function Staking(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Staking bond.
                     * @member {TW.Polkadot.Proto.Staking.IBond|null|undefined} bond
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.bond = null;
    
                    /**
                     * Staking bondAndNominate.
                     * @member {TW.Polkadot.Proto.Staking.IBondAndNominate|null|undefined} bondAndNominate
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.bondAndNominate = null;
    
                    /**
                     * Staking bondExtra.
                     * @member {TW.Polkadot.Proto.Staking.IBondExtra|null|undefined} bondExtra
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.bondExtra = null;
    
                    /**
                     * Staking unbond.
                     * @member {TW.Polkadot.Proto.Staking.IUnbond|null|undefined} unbond
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.unbond = null;
    
                    /**
                     * Staking withdrawUnbonded.
                     * @member {TW.Polkadot.Proto.Staking.IWithdrawUnbonded|null|undefined} withdrawUnbonded
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.withdrawUnbonded = null;
    
                    /**
                     * Staking nominate.
                     * @member {TW.Polkadot.Proto.Staking.INominate|null|undefined} nominate
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.nominate = null;
    
                    /**
                     * Staking chill.
                     * @member {TW.Polkadot.Proto.Staking.IChill|null|undefined} chill
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.chill = null;
    
                    /**
                     * Staking chillAndUnbond.
                     * @member {TW.Polkadot.Proto.Staking.IChillAndUnbond|null|undefined} chillAndUnbond
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Staking.prototype.chillAndUnbond = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Staking messageOneof.
                     * @member {"bond"|"bondAndNominate"|"bondExtra"|"unbond"|"withdrawUnbonded"|"nominate"|"chill"|"chillAndUnbond"|undefined} messageOneof
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     */
                    Object.defineProperty(Staking.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["bond", "bondAndNominate", "bondExtra", "unbond", "withdrawUnbonded", "nominate", "chill", "chillAndUnbond"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Staking instance using the specified properties.
                     * @function create
                     * @memberof TW.Polkadot.Proto.Staking
                     * @static
                     * @param {TW.Polkadot.Proto.IStaking=} [properties] Properties to set
                     * @returns {TW.Polkadot.Proto.Staking} Staking instance
                     */
                    Staking.create = function create(properties) {
                        return new Staking(properties);
                    };
    
                    /**
                     * Encodes the specified Staking message. Does not implicitly {@link TW.Polkadot.Proto.Staking.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Polkadot.Proto.Staking
                     * @static
                     * @param {TW.Polkadot.Proto.IStaking} message Staking message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Staking.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.bond != null && Object.hasOwnProperty.call(message, "bond"))
                            $root.TW.Polkadot.Proto.Staking.Bond.encode(message.bond, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.bondAndNominate != null && Object.hasOwnProperty.call(message, "bondAndNominate"))
                            $root.TW.Polkadot.Proto.Staking.BondAndNominate.encode(message.bondAndNominate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.bondExtra != null && Object.hasOwnProperty.call(message, "bondExtra"))
                            $root.TW.Polkadot.Proto.Staking.BondExtra.encode(message.bondExtra, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.unbond != null && Object.hasOwnProperty.call(message, "unbond"))
                            $root.TW.Polkadot.Proto.Staking.Unbond.encode(message.unbond, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.withdrawUnbonded != null && Object.hasOwnProperty.call(message, "withdrawUnbonded"))
                            $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded.encode(message.withdrawUnbonded, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.nominate != null && Object.hasOwnProperty.call(message, "nominate"))
                            $root.TW.Polkadot.Proto.Staking.Nominate.encode(message.nominate, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.chill != null && Object.hasOwnProperty.call(message, "chill"))
                            $root.TW.Polkadot.Proto.Staking.Chill.encode(message.chill, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.chillAndUnbond != null && Object.hasOwnProperty.call(message, "chillAndUnbond"))
                            $root.TW.Polkadot.Proto.Staking.ChillAndUnbond.encode(message.chillAndUnbond, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Staking message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Polkadot.Proto.Staking
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Polkadot.Proto.Staking} Staking
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Staking.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.bond = $root.TW.Polkadot.Proto.Staking.Bond.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.bondAndNominate = $root.TW.Polkadot.Proto.Staking.BondAndNominate.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.bondExtra = $root.TW.Polkadot.Proto.Staking.BondExtra.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.unbond = $root.TW.Polkadot.Proto.Staking.Unbond.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.withdrawUnbonded = $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.nominate = $root.TW.Polkadot.Proto.Staking.Nominate.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.chill = $root.TW.Polkadot.Proto.Staking.Chill.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.chillAndUnbond = $root.TW.Polkadot.Proto.Staking.ChillAndUnbond.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Staking message.
                     * @function verify
                     * @memberof TW.Polkadot.Proto.Staking
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Staking.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.bond != null && message.hasOwnProperty("bond")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.Bond.verify(message.bond);
                                if (error)
                                    return "bond." + error;
                            }
                        }
                        if (message.bondAndNominate != null && message.hasOwnProperty("bondAndNominate")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.BondAndNominate.verify(message.bondAndNominate);
                                if (error)
                                    return "bondAndNominate." + error;
                            }
                        }
                        if (message.bondExtra != null && message.hasOwnProperty("bondExtra")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.BondExtra.verify(message.bondExtra);
                                if (error)
                                    return "bondExtra." + error;
                            }
                        }
                        if (message.unbond != null && message.hasOwnProperty("unbond")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.Unbond.verify(message.unbond);
                                if (error)
                                    return "unbond." + error;
                            }
                        }
                        if (message.withdrawUnbonded != null && message.hasOwnProperty("withdrawUnbonded")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded.verify(message.withdrawUnbonded);
                                if (error)
                                    return "withdrawUnbonded." + error;
                            }
                        }
                        if (message.nominate != null && message.hasOwnProperty("nominate")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.Nominate.verify(message.nominate);
                                if (error)
                                    return "nominate." + error;
                            }
                        }
                        if (message.chill != null && message.hasOwnProperty("chill")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.Chill.verify(message.chill);
                                if (error)
                                    return "chill." + error;
                            }
                        }
                        if (message.chillAndUnbond != null && message.hasOwnProperty("chillAndUnbond")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.ChillAndUnbond.verify(message.chillAndUnbond);
                                if (error)
                                    return "chillAndUnbond." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Staking message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Polkadot.Proto.Staking
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Polkadot.Proto.Staking} Staking
                     */
                    Staking.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Polkadot.Proto.Staking)
                            return object;
                        var message = new $root.TW.Polkadot.Proto.Staking();
                        if (object.bond != null) {
                            if (typeof object.bond !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.bond: object expected");
                            message.bond = $root.TW.Polkadot.Proto.Staking.Bond.fromObject(object.bond);
                        }
                        if (object.bondAndNominate != null) {
                            if (typeof object.bondAndNominate !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.bondAndNominate: object expected");
                            message.bondAndNominate = $root.TW.Polkadot.Proto.Staking.BondAndNominate.fromObject(object.bondAndNominate);
                        }
                        if (object.bondExtra != null) {
                            if (typeof object.bondExtra !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.bondExtra: object expected");
                            message.bondExtra = $root.TW.Polkadot.Proto.Staking.BondExtra.fromObject(object.bondExtra);
                        }
                        if (object.unbond != null) {
                            if (typeof object.unbond !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.unbond: object expected");
                            message.unbond = $root.TW.Polkadot.Proto.Staking.Unbond.fromObject(object.unbond);
                        }
                        if (object.withdrawUnbonded != null) {
                            if (typeof object.withdrawUnbonded !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.withdrawUnbonded: object expected");
                            message.withdrawUnbonded = $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded.fromObject(object.withdrawUnbonded);
                        }
                        if (object.nominate != null) {
                            if (typeof object.nominate !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.nominate: object expected");
                            message.nominate = $root.TW.Polkadot.Proto.Staking.Nominate.fromObject(object.nominate);
                        }
                        if (object.chill != null) {
                            if (typeof object.chill !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.chill: object expected");
                            message.chill = $root.TW.Polkadot.Proto.Staking.Chill.fromObject(object.chill);
                        }
                        if (object.chillAndUnbond != null) {
                            if (typeof object.chillAndUnbond !== "object")
                                throw TypeError(".TW.Polkadot.Proto.Staking.chillAndUnbond: object expected");
                            message.chillAndUnbond = $root.TW.Polkadot.Proto.Staking.ChillAndUnbond.fromObject(object.chillAndUnbond);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Staking message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Polkadot.Proto.Staking
                     * @static
                     * @param {TW.Polkadot.Proto.Staking} message Staking
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Staking.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.bond != null && message.hasOwnProperty("bond")) {
                            object.bond = $root.TW.Polkadot.Proto.Staking.Bond.toObject(message.bond, options);
                            if (options.oneofs)
                                object.messageOneof = "bond";
                        }
                        if (message.bondAndNominate != null && message.hasOwnProperty("bondAndNominate")) {
                            object.bondAndNominate = $root.TW.Polkadot.Proto.Staking.BondAndNominate.toObject(message.bondAndNominate, options);
                            if (options.oneofs)
                                object.messageOneof = "bondAndNominate";
                        }
                        if (message.bondExtra != null && message.hasOwnProperty("bondExtra")) {
                            object.bondExtra = $root.TW.Polkadot.Proto.Staking.BondExtra.toObject(message.bondExtra, options);
                            if (options.oneofs)
                                object.messageOneof = "bondExtra";
                        }
                        if (message.unbond != null && message.hasOwnProperty("unbond")) {
                            object.unbond = $root.TW.Polkadot.Proto.Staking.Unbond.toObject(message.unbond, options);
                            if (options.oneofs)
                                object.messageOneof = "unbond";
                        }
                        if (message.withdrawUnbonded != null && message.hasOwnProperty("withdrawUnbonded")) {
                            object.withdrawUnbonded = $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded.toObject(message.withdrawUnbonded, options);
                            if (options.oneofs)
                                object.messageOneof = "withdrawUnbonded";
                        }
                        if (message.nominate != null && message.hasOwnProperty("nominate")) {
                            object.nominate = $root.TW.Polkadot.Proto.Staking.Nominate.toObject(message.nominate, options);
                            if (options.oneofs)
                                object.messageOneof = "nominate";
                        }
                        if (message.chill != null && message.hasOwnProperty("chill")) {
                            object.chill = $root.TW.Polkadot.Proto.Staking.Chill.toObject(message.chill, options);
                            if (options.oneofs)
                                object.messageOneof = "chill";
                        }
                        if (message.chillAndUnbond != null && message.hasOwnProperty("chillAndUnbond")) {
                            object.chillAndUnbond = $root.TW.Polkadot.Proto.Staking.ChillAndUnbond.toObject(message.chillAndUnbond, options);
                            if (options.oneofs)
                                object.messageOneof = "chillAndUnbond";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Staking to JSON.
                     * @function toJSON
                     * @memberof TW.Polkadot.Proto.Staking
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Staking.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Staking.Bond = (function() {
    
                        /**
                         * Properties of a Bond.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface IBond
                         * @property {string|null} [controller] Bond controller
                         * @property {Uint8Array|null} [value] Bond value
                         * @property {TW.Polkadot.Proto.RewardDestination|null} [rewardDestination] Bond rewardDestination
                         */
    
                        /**
                         * Constructs a new Bond.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents a Bond.
                         * @implements IBond
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.IBond=} [properties] Properties to set
                         */
                        function Bond(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Bond controller.
                         * @member {string} controller
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @instance
                         */
                        Bond.prototype.controller = "";
    
                        /**
                         * Bond value.
                         * @member {Uint8Array} value
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @instance
                         */
                        Bond.prototype.value = $util.newBuffer([]);
    
                        /**
                         * Bond rewardDestination.
                         * @member {TW.Polkadot.Proto.RewardDestination} rewardDestination
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @instance
                         */
                        Bond.prototype.rewardDestination = 0;
    
                        /**
                         * Creates a new Bond instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IBond=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.Bond} Bond instance
                         */
                        Bond.create = function create(properties) {
                            return new Bond(properties);
                        };
    
                        /**
                         * Encodes the specified Bond message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Bond.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IBond} message Bond message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Bond.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.controller != null && Object.hasOwnProperty.call(message, "controller"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.controller);
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                            if (message.rewardDestination != null && Object.hasOwnProperty.call(message, "rewardDestination"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rewardDestination);
                            return writer;
                        };
    
                        /**
                         * Decodes a Bond message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.Bond} Bond
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Bond.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.Bond();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.controller = reader.string();
                                    break;
                                case 2:
                                    message.value = reader.bytes();
                                    break;
                                case 3:
                                    message.rewardDestination = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Bond message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Bond.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.controller != null && message.hasOwnProperty("controller"))
                                if (!$util.isString(message.controller))
                                    return "controller: string expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                    return "value: buffer expected";
                            if (message.rewardDestination != null && message.hasOwnProperty("rewardDestination"))
                                switch (message.rewardDestination) {
                                default:
                                    return "rewardDestination: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };
    
                        /**
                         * Creates a Bond message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.Bond} Bond
                         */
                        Bond.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.Bond)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Staking.Bond();
                            if (object.controller != null)
                                message.controller = String(object.controller);
                            if (object.value != null)
                                if (typeof object.value === "string")
                                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                                else if (object.value.length)
                                    message.value = object.value;
                            switch (object.rewardDestination) {
                            case "STAKED":
                            case 0:
                                message.rewardDestination = 0;
                                break;
                            case "STASH":
                            case 1:
                                message.rewardDestination = 1;
                                break;
                            case "CONTROLLER":
                            case 2:
                                message.rewardDestination = 2;
                                break;
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Bond message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.Bond} message Bond
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Bond.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.controller = "";
                                if (options.bytes === String)
                                    object.value = "";
                                else {
                                    object.value = [];
                                    if (options.bytes !== Array)
                                        object.value = $util.newBuffer(object.value);
                                }
                                object.rewardDestination = options.enums === String ? "STAKED" : 0;
                            }
                            if (message.controller != null && message.hasOwnProperty("controller"))
                                object.controller = message.controller;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                            if (message.rewardDestination != null && message.hasOwnProperty("rewardDestination"))
                                object.rewardDestination = options.enums === String ? $root.TW.Polkadot.Proto.RewardDestination[message.rewardDestination] : message.rewardDestination;
                            return object;
                        };
    
                        /**
                         * Converts this Bond to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.Bond
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Bond.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Bond;
                    })();
    
                    Staking.BondAndNominate = (function() {
    
                        /**
                         * Properties of a BondAndNominate.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface IBondAndNominate
                         * @property {string|null} [controller] BondAndNominate controller
                         * @property {Uint8Array|null} [value] BondAndNominate value
                         * @property {TW.Polkadot.Proto.RewardDestination|null} [rewardDestination] BondAndNominate rewardDestination
                         * @property {Array.<string>|null} [nominators] BondAndNominate nominators
                         */
    
                        /**
                         * Constructs a new BondAndNominate.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents a BondAndNominate.
                         * @implements IBondAndNominate
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.IBondAndNominate=} [properties] Properties to set
                         */
                        function BondAndNominate(properties) {
                            this.nominators = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * BondAndNominate controller.
                         * @member {string} controller
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @instance
                         */
                        BondAndNominate.prototype.controller = "";
    
                        /**
                         * BondAndNominate value.
                         * @member {Uint8Array} value
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @instance
                         */
                        BondAndNominate.prototype.value = $util.newBuffer([]);
    
                        /**
                         * BondAndNominate rewardDestination.
                         * @member {TW.Polkadot.Proto.RewardDestination} rewardDestination
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @instance
                         */
                        BondAndNominate.prototype.rewardDestination = 0;
    
                        /**
                         * BondAndNominate nominators.
                         * @member {Array.<string>} nominators
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @instance
                         */
                        BondAndNominate.prototype.nominators = $util.emptyArray;
    
                        /**
                         * Creates a new BondAndNominate instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IBondAndNominate=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.BondAndNominate} BondAndNominate instance
                         */
                        BondAndNominate.create = function create(properties) {
                            return new BondAndNominate(properties);
                        };
    
                        /**
                         * Encodes the specified BondAndNominate message. Does not implicitly {@link TW.Polkadot.Proto.Staking.BondAndNominate.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IBondAndNominate} message BondAndNominate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BondAndNominate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.controller != null && Object.hasOwnProperty.call(message, "controller"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.controller);
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                            if (message.rewardDestination != null && Object.hasOwnProperty.call(message, "rewardDestination"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rewardDestination);
                            if (message.nominators != null && message.nominators.length)
                                for (var i = 0; i < message.nominators.length; ++i)
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nominators[i]);
                            return writer;
                        };
    
                        /**
                         * Decodes a BondAndNominate message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.BondAndNominate} BondAndNominate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BondAndNominate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.BondAndNominate();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.controller = reader.string();
                                    break;
                                case 2:
                                    message.value = reader.bytes();
                                    break;
                                case 3:
                                    message.rewardDestination = reader.int32();
                                    break;
                                case 4:
                                    if (!(message.nominators && message.nominators.length))
                                        message.nominators = [];
                                    message.nominators.push(reader.string());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a BondAndNominate message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BondAndNominate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.controller != null && message.hasOwnProperty("controller"))
                                if (!$util.isString(message.controller))
                                    return "controller: string expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                    return "value: buffer expected";
                            if (message.rewardDestination != null && message.hasOwnProperty("rewardDestination"))
                                switch (message.rewardDestination) {
                                default:
                                    return "rewardDestination: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.nominators != null && message.hasOwnProperty("nominators")) {
                                if (!Array.isArray(message.nominators))
                                    return "nominators: array expected";
                                for (var i = 0; i < message.nominators.length; ++i)
                                    if (!$util.isString(message.nominators[i]))
                                        return "nominators: string[] expected";
                            }
                            return null;
                        };
    
                        /**
                         * Creates a BondAndNominate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.BondAndNominate} BondAndNominate
                         */
                        BondAndNominate.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.BondAndNominate)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Staking.BondAndNominate();
                            if (object.controller != null)
                                message.controller = String(object.controller);
                            if (object.value != null)
                                if (typeof object.value === "string")
                                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                                else if (object.value.length)
                                    message.value = object.value;
                            switch (object.rewardDestination) {
                            case "STAKED":
                            case 0:
                                message.rewardDestination = 0;
                                break;
                            case "STASH":
                            case 1:
                                message.rewardDestination = 1;
                                break;
                            case "CONTROLLER":
                            case 2:
                                message.rewardDestination = 2;
                                break;
                            }
                            if (object.nominators) {
                                if (!Array.isArray(object.nominators))
                                    throw TypeError(".TW.Polkadot.Proto.Staking.BondAndNominate.nominators: array expected");
                                message.nominators = [];
                                for (var i = 0; i < object.nominators.length; ++i)
                                    message.nominators[i] = String(object.nominators[i]);
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a BondAndNominate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.BondAndNominate} message BondAndNominate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BondAndNominate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.nominators = [];
                            if (options.defaults) {
                                object.controller = "";
                                if (options.bytes === String)
                                    object.value = "";
                                else {
                                    object.value = [];
                                    if (options.bytes !== Array)
                                        object.value = $util.newBuffer(object.value);
                                }
                                object.rewardDestination = options.enums === String ? "STAKED" : 0;
                            }
                            if (message.controller != null && message.hasOwnProperty("controller"))
                                object.controller = message.controller;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                            if (message.rewardDestination != null && message.hasOwnProperty("rewardDestination"))
                                object.rewardDestination = options.enums === String ? $root.TW.Polkadot.Proto.RewardDestination[message.rewardDestination] : message.rewardDestination;
                            if (message.nominators && message.nominators.length) {
                                object.nominators = [];
                                for (var j = 0; j < message.nominators.length; ++j)
                                    object.nominators[j] = message.nominators[j];
                            }
                            return object;
                        };
    
                        /**
                         * Converts this BondAndNominate to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.BondAndNominate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BondAndNominate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return BondAndNominate;
                    })();
    
                    Staking.BondExtra = (function() {
    
                        /**
                         * Properties of a BondExtra.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface IBondExtra
                         * @property {Uint8Array|null} [value] BondExtra value
                         */
    
                        /**
                         * Constructs a new BondExtra.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents a BondExtra.
                         * @implements IBondExtra
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.IBondExtra=} [properties] Properties to set
                         */
                        function BondExtra(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * BondExtra value.
                         * @member {Uint8Array} value
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @instance
                         */
                        BondExtra.prototype.value = $util.newBuffer([]);
    
                        /**
                         * Creates a new BondExtra instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IBondExtra=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.BondExtra} BondExtra instance
                         */
                        BondExtra.create = function create(properties) {
                            return new BondExtra(properties);
                        };
    
                        /**
                         * Encodes the specified BondExtra message. Does not implicitly {@link TW.Polkadot.Proto.Staking.BondExtra.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IBondExtra} message BondExtra message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BondExtra.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                            return writer;
                        };
    
                        /**
                         * Decodes a BondExtra message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.BondExtra} BondExtra
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BondExtra.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.BondExtra();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a BondExtra message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BondExtra.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                    return "value: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a BondExtra message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.BondExtra} BondExtra
                         */
                        BondExtra.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.BondExtra)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Staking.BondExtra();
                            if (object.value != null)
                                if (typeof object.value === "string")
                                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                                else if (object.value.length)
                                    message.value = object.value;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a BondExtra message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.BondExtra} message BondExtra
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BondExtra.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.value = "";
                                else {
                                    object.value = [];
                                    if (options.bytes !== Array)
                                        object.value = $util.newBuffer(object.value);
                                }
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                            return object;
                        };
    
                        /**
                         * Converts this BondExtra to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.BondExtra
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BondExtra.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return BondExtra;
                    })();
    
                    Staking.Unbond = (function() {
    
                        /**
                         * Properties of an Unbond.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface IUnbond
                         * @property {Uint8Array|null} [value] Unbond value
                         */
    
                        /**
                         * Constructs a new Unbond.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents an Unbond.
                         * @implements IUnbond
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.IUnbond=} [properties] Properties to set
                         */
                        function Unbond(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Unbond value.
                         * @member {Uint8Array} value
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @instance
                         */
                        Unbond.prototype.value = $util.newBuffer([]);
    
                        /**
                         * Creates a new Unbond instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IUnbond=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.Unbond} Unbond instance
                         */
                        Unbond.create = function create(properties) {
                            return new Unbond(properties);
                        };
    
                        /**
                         * Encodes the specified Unbond message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Unbond.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IUnbond} message Unbond message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Unbond.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                            return writer;
                        };
    
                        /**
                         * Decodes an Unbond message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.Unbond} Unbond
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Unbond.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.Unbond();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies an Unbond message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Unbond.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                    return "value: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates an Unbond message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.Unbond} Unbond
                         */
                        Unbond.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.Unbond)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Staking.Unbond();
                            if (object.value != null)
                                if (typeof object.value === "string")
                                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                                else if (object.value.length)
                                    message.value = object.value;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an Unbond message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.Unbond} message Unbond
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Unbond.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.value = "";
                                else {
                                    object.value = [];
                                    if (options.bytes !== Array)
                                        object.value = $util.newBuffer(object.value);
                                }
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                            return object;
                        };
    
                        /**
                         * Converts this Unbond to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.Unbond
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Unbond.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Unbond;
                    })();
    
                    Staking.WithdrawUnbonded = (function() {
    
                        /**
                         * Properties of a WithdrawUnbonded.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface IWithdrawUnbonded
                         * @property {number|null} [slashingSpans] WithdrawUnbonded slashingSpans
                         */
    
                        /**
                         * Constructs a new WithdrawUnbonded.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents a WithdrawUnbonded.
                         * @implements IWithdrawUnbonded
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.IWithdrawUnbonded=} [properties] Properties to set
                         */
                        function WithdrawUnbonded(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * WithdrawUnbonded slashingSpans.
                         * @member {number} slashingSpans
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @instance
                         */
                        WithdrawUnbonded.prototype.slashingSpans = 0;
    
                        /**
                         * Creates a new WithdrawUnbonded instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IWithdrawUnbonded=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.WithdrawUnbonded} WithdrawUnbonded instance
                         */
                        WithdrawUnbonded.create = function create(properties) {
                            return new WithdrawUnbonded(properties);
                        };
    
                        /**
                         * Encodes the specified WithdrawUnbonded message. Does not implicitly {@link TW.Polkadot.Proto.Staking.WithdrawUnbonded.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IWithdrawUnbonded} message WithdrawUnbonded message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        WithdrawUnbonded.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.slashingSpans != null && Object.hasOwnProperty.call(message, "slashingSpans"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slashingSpans);
                            return writer;
                        };
    
                        /**
                         * Decodes a WithdrawUnbonded message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.WithdrawUnbonded} WithdrawUnbonded
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        WithdrawUnbonded.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.slashingSpans = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a WithdrawUnbonded message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        WithdrawUnbonded.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.slashingSpans != null && message.hasOwnProperty("slashingSpans"))
                                if (!$util.isInteger(message.slashingSpans))
                                    return "slashingSpans: integer expected";
                            return null;
                        };
    
                        /**
                         * Creates a WithdrawUnbonded message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.WithdrawUnbonded} WithdrawUnbonded
                         */
                        WithdrawUnbonded.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Staking.WithdrawUnbonded();
                            if (object.slashingSpans != null)
                                message.slashingSpans = object.slashingSpans | 0;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a WithdrawUnbonded message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.WithdrawUnbonded} message WithdrawUnbonded
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        WithdrawUnbonded.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.slashingSpans = 0;
                            if (message.slashingSpans != null && message.hasOwnProperty("slashingSpans"))
                                object.slashingSpans = message.slashingSpans;
                            return object;
                        };
    
                        /**
                         * Converts this WithdrawUnbonded to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.WithdrawUnbonded
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        WithdrawUnbonded.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return WithdrawUnbonded;
                    })();
    
                    Staking.Nominate = (function() {
    
                        /**
                         * Properties of a Nominate.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface INominate
                         * @property {Array.<string>|null} [nominators] Nominate nominators
                         */
    
                        /**
                         * Constructs a new Nominate.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents a Nominate.
                         * @implements INominate
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.INominate=} [properties] Properties to set
                         */
                        function Nominate(properties) {
                            this.nominators = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Nominate nominators.
                         * @member {Array.<string>} nominators
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @instance
                         */
                        Nominate.prototype.nominators = $util.emptyArray;
    
                        /**
                         * Creates a new Nominate instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.INominate=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.Nominate} Nominate instance
                         */
                        Nominate.create = function create(properties) {
                            return new Nominate(properties);
                        };
    
                        /**
                         * Encodes the specified Nominate message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Nominate.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.INominate} message Nominate message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Nominate.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.nominators != null && message.nominators.length)
                                for (var i = 0; i < message.nominators.length; ++i)
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nominators[i]);
                            return writer;
                        };
    
                        /**
                         * Decodes a Nominate message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.Nominate} Nominate
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Nominate.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.Nominate();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.nominators && message.nominators.length))
                                        message.nominators = [];
                                    message.nominators.push(reader.string());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Nominate message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Nominate.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.nominators != null && message.hasOwnProperty("nominators")) {
                                if (!Array.isArray(message.nominators))
                                    return "nominators: array expected";
                                for (var i = 0; i < message.nominators.length; ++i)
                                    if (!$util.isString(message.nominators[i]))
                                        return "nominators: string[] expected";
                            }
                            return null;
                        };
    
                        /**
                         * Creates a Nominate message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.Nominate} Nominate
                         */
                        Nominate.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.Nominate)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Staking.Nominate();
                            if (object.nominators) {
                                if (!Array.isArray(object.nominators))
                                    throw TypeError(".TW.Polkadot.Proto.Staking.Nominate.nominators: array expected");
                                message.nominators = [];
                                for (var i = 0; i < object.nominators.length; ++i)
                                    message.nominators[i] = String(object.nominators[i]);
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Nominate message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.Nominate} message Nominate
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Nominate.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.nominators = [];
                            if (message.nominators && message.nominators.length) {
                                object.nominators = [];
                                for (var j = 0; j < message.nominators.length; ++j)
                                    object.nominators[j] = message.nominators[j];
                            }
                            return object;
                        };
    
                        /**
                         * Converts this Nominate to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.Nominate
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Nominate.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Nominate;
                    })();
    
                    Staking.ChillAndUnbond = (function() {
    
                        /**
                         * Properties of a ChillAndUnbond.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface IChillAndUnbond
                         * @property {Uint8Array|null} [value] ChillAndUnbond value
                         */
    
                        /**
                         * Constructs a new ChillAndUnbond.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents a ChillAndUnbond.
                         * @implements IChillAndUnbond
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.IChillAndUnbond=} [properties] Properties to set
                         */
                        function ChillAndUnbond(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ChillAndUnbond value.
                         * @member {Uint8Array} value
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @instance
                         */
                        ChillAndUnbond.prototype.value = $util.newBuffer([]);
    
                        /**
                         * Creates a new ChillAndUnbond instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IChillAndUnbond=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.ChillAndUnbond} ChillAndUnbond instance
                         */
                        ChillAndUnbond.create = function create(properties) {
                            return new ChillAndUnbond(properties);
                        };
    
                        /**
                         * Encodes the specified ChillAndUnbond message. Does not implicitly {@link TW.Polkadot.Proto.Staking.ChillAndUnbond.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IChillAndUnbond} message ChillAndUnbond message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChillAndUnbond.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                            return writer;
                        };
    
                        /**
                         * Decodes a ChillAndUnbond message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.ChillAndUnbond} ChillAndUnbond
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChillAndUnbond.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.ChillAndUnbond();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a ChillAndUnbond message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ChillAndUnbond.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                    return "value: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a ChillAndUnbond message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.ChillAndUnbond} ChillAndUnbond
                         */
                        ChillAndUnbond.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.ChillAndUnbond)
                                return object;
                            var message = new $root.TW.Polkadot.Proto.Staking.ChillAndUnbond();
                            if (object.value != null)
                                if (typeof object.value === "string")
                                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                                else if (object.value.length)
                                    message.value = object.value;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a ChillAndUnbond message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.ChillAndUnbond} message ChillAndUnbond
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ChillAndUnbond.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.value = "";
                                else {
                                    object.value = [];
                                    if (options.bytes !== Array)
                                        object.value = $util.newBuffer(object.value);
                                }
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                            return object;
                        };
    
                        /**
                         * Converts this ChillAndUnbond to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.ChillAndUnbond
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ChillAndUnbond.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return ChillAndUnbond;
                    })();
    
                    Staking.Chill = (function() {
    
                        /**
                         * Properties of a Chill.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @interface IChill
                         */
    
                        /**
                         * Constructs a new Chill.
                         * @memberof TW.Polkadot.Proto.Staking
                         * @classdesc Represents a Chill.
                         * @implements IChill
                         * @constructor
                         * @param {TW.Polkadot.Proto.Staking.IChill=} [properties] Properties to set
                         */
                        function Chill(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Creates a new Chill instance using the specified properties.
                         * @function create
                         * @memberof TW.Polkadot.Proto.Staking.Chill
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IChill=} [properties] Properties to set
                         * @returns {TW.Polkadot.Proto.Staking.Chill} Chill instance
                         */
                        Chill.create = function create(properties) {
                            return new Chill(properties);
                        };
    
                        /**
                         * Encodes the specified Chill message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Chill.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Polkadot.Proto.Staking.Chill
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.IChill} message Chill message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Chill.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };
    
                        /**
                         * Decodes a Chill message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Polkadot.Proto.Staking.Chill
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Polkadot.Proto.Staking.Chill} Chill
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Chill.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.Staking.Chill();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Chill message.
                         * @function verify
                         * @memberof TW.Polkadot.Proto.Staking.Chill
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Chill.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };
    
                        /**
                         * Creates a Chill message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Polkadot.Proto.Staking.Chill
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Polkadot.Proto.Staking.Chill} Chill
                         */
                        Chill.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Polkadot.Proto.Staking.Chill)
                                return object;
                            return new $root.TW.Polkadot.Proto.Staking.Chill();
                        };
    
                        /**
                         * Creates a plain object from a Chill message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Polkadot.Proto.Staking.Chill
                         * @static
                         * @param {TW.Polkadot.Proto.Staking.Chill} message Chill
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Chill.toObject = function toObject() {
                            return {};
                        };
    
                        /**
                         * Converts this Chill to JSON.
                         * @function toJSON
                         * @memberof TW.Polkadot.Proto.Staking.Chill
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Chill.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Chill;
                    })();
    
                    return Staking;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Polkadot.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [blockHash] SigningInput blockHash
                     * @property {Uint8Array|null} [genesisHash] SigningInput genesisHash
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {number|null} [specVersion] SigningInput specVersion
                     * @property {number|null} [transactionVersion] SigningInput transactionVersion
                     * @property {Uint8Array|null} [tip] SigningInput tip
                     * @property {TW.Polkadot.Proto.IEra|null} [era] SigningInput era
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Polkadot.Proto.Network|null} [network] SigningInput network
                     * @property {TW.Polkadot.Proto.IBalance|null} [balanceCall] SigningInput balanceCall
                     * @property {TW.Polkadot.Proto.IStaking|null} [stakingCall] SigningInput stakingCall
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Polkadot.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Polkadot.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput blockHash.
                     * @member {Uint8Array} blockHash
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.blockHash = $util.newBuffer([]);
    
                    /**
                     * SigningInput genesisHash.
                     * @member {Uint8Array} genesisHash
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.genesisHash = $util.newBuffer([]);
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput specVersion.
                     * @member {number} specVersion
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.specVersion = 0;
    
                    /**
                     * SigningInput transactionVersion.
                     * @member {number} transactionVersion
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transactionVersion = 0;
    
                    /**
                     * SigningInput tip.
                     * @member {Uint8Array} tip
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.tip = $util.newBuffer([]);
    
                    /**
                     * SigningInput era.
                     * @member {TW.Polkadot.Proto.IEra|null|undefined} era
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.era = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput network.
                     * @member {TW.Polkadot.Proto.Network} network
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.network = 0;
    
                    /**
                     * SigningInput balanceCall.
                     * @member {TW.Polkadot.Proto.IBalance|null|undefined} balanceCall
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.balanceCall = null;
    
                    /**
                     * SigningInput stakingCall.
                     * @member {TW.Polkadot.Proto.IStaking|null|undefined} stakingCall
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakingCall = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput messageOneof.
                     * @member {"balanceCall"|"stakingCall"|undefined} messageOneof
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["balanceCall", "stakingCall"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @static
                     * @param {TW.Polkadot.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Polkadot.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Polkadot.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @static
                     * @param {TW.Polkadot.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.blockHash != null && Object.hasOwnProperty.call(message, "blockHash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockHash);
                        if (message.genesisHash != null && Object.hasOwnProperty.call(message, "genesisHash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.genesisHash);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.nonce);
                        if (message.specVersion != null && Object.hasOwnProperty.call(message, "specVersion"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.specVersion);
                        if (message.transactionVersion != null && Object.hasOwnProperty.call(message, "transactionVersion"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.transactionVersion);
                        if (message.tip != null && Object.hasOwnProperty.call(message, "tip"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.tip);
                        if (message.era != null && Object.hasOwnProperty.call(message, "era"))
                            $root.TW.Polkadot.Proto.Era.encode(message.era, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.privateKey);
                        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.network);
                        if (message.balanceCall != null && Object.hasOwnProperty.call(message, "balanceCall"))
                            $root.TW.Polkadot.Proto.Balance.encode(message.balanceCall, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.stakingCall != null && Object.hasOwnProperty.call(message, "stakingCall"))
                            $root.TW.Polkadot.Proto.Staking.encode(message.stakingCall, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Polkadot.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.blockHash = reader.bytes();
                                break;
                            case 2:
                                message.genesisHash = reader.bytes();
                                break;
                            case 3:
                                message.nonce = reader.uint64();
                                break;
                            case 4:
                                message.specVersion = reader.uint32();
                                break;
                            case 5:
                                message.transactionVersion = reader.uint32();
                                break;
                            case 6:
                                message.tip = reader.bytes();
                                break;
                            case 7:
                                message.era = $root.TW.Polkadot.Proto.Era.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.privateKey = reader.bytes();
                                break;
                            case 9:
                                message.network = reader.int32();
                                break;
                            case 10:
                                message.balanceCall = $root.TW.Polkadot.Proto.Balance.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.stakingCall = $root.TW.Polkadot.Proto.Staking.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                                return "blockHash: buffer expected";
                        if (message.genesisHash != null && message.hasOwnProperty("genesisHash"))
                            if (!(message.genesisHash && typeof message.genesisHash.length === "number" || $util.isString(message.genesisHash)))
                                return "genesisHash: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.specVersion != null && message.hasOwnProperty("specVersion"))
                            if (!$util.isInteger(message.specVersion))
                                return "specVersion: integer expected";
                        if (message.transactionVersion != null && message.hasOwnProperty("transactionVersion"))
                            if (!$util.isInteger(message.transactionVersion))
                                return "transactionVersion: integer expected";
                        if (message.tip != null && message.hasOwnProperty("tip"))
                            if (!(message.tip && typeof message.tip.length === "number" || $util.isString(message.tip)))
                                return "tip: buffer expected";
                        if (message.era != null && message.hasOwnProperty("era")) {
                            var error = $root.TW.Polkadot.Proto.Era.verify(message.era);
                            if (error)
                                return "era." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.network != null && message.hasOwnProperty("network"))
                            switch (message.network) {
                            default:
                                return "network: enum value expected";
                            case 0:
                            case 2:
                                break;
                            }
                        if (message.balanceCall != null && message.hasOwnProperty("balanceCall")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Balance.verify(message.balanceCall);
                                if (error)
                                    return "balanceCall." + error;
                            }
                        }
                        if (message.stakingCall != null && message.hasOwnProperty("stakingCall")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Polkadot.Proto.Staking.verify(message.stakingCall);
                                if (error)
                                    return "stakingCall." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Polkadot.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Polkadot.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Polkadot.Proto.SigningInput();
                        if (object.blockHash != null)
                            if (typeof object.blockHash === "string")
                                $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                            else if (object.blockHash.length)
                                message.blockHash = object.blockHash;
                        if (object.genesisHash != null)
                            if (typeof object.genesisHash === "string")
                                $util.base64.decode(object.genesisHash, message.genesisHash = $util.newBuffer($util.base64.length(object.genesisHash)), 0);
                            else if (object.genesisHash.length)
                                message.genesisHash = object.genesisHash;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.specVersion != null)
                            message.specVersion = object.specVersion >>> 0;
                        if (object.transactionVersion != null)
                            message.transactionVersion = object.transactionVersion >>> 0;
                        if (object.tip != null)
                            if (typeof object.tip === "string")
                                $util.base64.decode(object.tip, message.tip = $util.newBuffer($util.base64.length(object.tip)), 0);
                            else if (object.tip.length)
                                message.tip = object.tip;
                        if (object.era != null) {
                            if (typeof object.era !== "object")
                                throw TypeError(".TW.Polkadot.Proto.SigningInput.era: object expected");
                            message.era = $root.TW.Polkadot.Proto.Era.fromObject(object.era);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        switch (object.network) {
                        case "POLKADOT":
                        case 0:
                            message.network = 0;
                            break;
                        case "KUSAMA":
                        case 2:
                            message.network = 2;
                            break;
                        }
                        if (object.balanceCall != null) {
                            if (typeof object.balanceCall !== "object")
                                throw TypeError(".TW.Polkadot.Proto.SigningInput.balanceCall: object expected");
                            message.balanceCall = $root.TW.Polkadot.Proto.Balance.fromObject(object.balanceCall);
                        }
                        if (object.stakingCall != null) {
                            if (typeof object.stakingCall !== "object")
                                throw TypeError(".TW.Polkadot.Proto.SigningInput.stakingCall: object expected");
                            message.stakingCall = $root.TW.Polkadot.Proto.Staking.fromObject(object.stakingCall);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @static
                     * @param {TW.Polkadot.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.blockHash = "";
                            else {
                                object.blockHash = [];
                                if (options.bytes !== Array)
                                    object.blockHash = $util.newBuffer(object.blockHash);
                            }
                            if (options.bytes === String)
                                object.genesisHash = "";
                            else {
                                object.genesisHash = [];
                                if (options.bytes !== Array)
                                    object.genesisHash = $util.newBuffer(object.genesisHash);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            object.specVersion = 0;
                            object.transactionVersion = 0;
                            if (options.bytes === String)
                                object.tip = "";
                            else {
                                object.tip = [];
                                if (options.bytes !== Array)
                                    object.tip = $util.newBuffer(object.tip);
                            }
                            object.era = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.network = options.enums === String ? "POLKADOT" : 0;
                        }
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
                        if (message.genesisHash != null && message.hasOwnProperty("genesisHash"))
                            object.genesisHash = options.bytes === String ? $util.base64.encode(message.genesisHash, 0, message.genesisHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.genesisHash) : message.genesisHash;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.specVersion != null && message.hasOwnProperty("specVersion"))
                            object.specVersion = message.specVersion;
                        if (message.transactionVersion != null && message.hasOwnProperty("transactionVersion"))
                            object.transactionVersion = message.transactionVersion;
                        if (message.tip != null && message.hasOwnProperty("tip"))
                            object.tip = options.bytes === String ? $util.base64.encode(message.tip, 0, message.tip.length) : options.bytes === Array ? Array.prototype.slice.call(message.tip) : message.tip;
                        if (message.era != null && message.hasOwnProperty("era"))
                            object.era = $root.TW.Polkadot.Proto.Era.toObject(message.era, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.network != null && message.hasOwnProperty("network"))
                            object.network = options.enums === String ? $root.TW.Polkadot.Proto.Network[message.network] : message.network;
                        if (message.balanceCall != null && message.hasOwnProperty("balanceCall")) {
                            object.balanceCall = $root.TW.Polkadot.Proto.Balance.toObject(message.balanceCall, options);
                            if (options.oneofs)
                                object.messageOneof = "balanceCall";
                        }
                        if (message.stakingCall != null && message.hasOwnProperty("stakingCall")) {
                            object.stakingCall = $root.TW.Polkadot.Proto.Staking.toObject(message.stakingCall, options);
                            if (options.oneofs)
                                object.messageOneof = "stakingCall";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Polkadot.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Polkadot.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Polkadot.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Polkadot.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @static
                     * @param {TW.Polkadot.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Polkadot.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Polkadot.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @static
                     * @param {TW.Polkadot.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Polkadot.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Polkadot.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Polkadot.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Polkadot.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Polkadot.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @static
                     * @param {TW.Polkadot.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Polkadot.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Polkadot;
        })();
    
        TW.Ripple = (function() {
    
            /**
             * Namespace Ripple.
             * @memberof TW
             * @namespace
             */
            var Ripple = {};
    
            Ripple.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Ripple
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Ripple.Proto
                     * @interface ISigningInput
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {number|null} [sequence] SigningInput sequence
                     * @property {number|null} [lastLedgerSequence] SigningInput lastLedgerSequence
                     * @property {string|null} [account] SigningInput account
                     * @property {string|null} [destination] SigningInput destination
                     * @property {Long|null} [destinationTag] SigningInput destinationTag
                     * @property {Long|null} [flags] SigningInput flags
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Ripple.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Ripple.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput sequence.
                     * @member {number} sequence
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = 0;
    
                    /**
                     * SigningInput lastLedgerSequence.
                     * @member {number} lastLedgerSequence
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.lastLedgerSequence = 0;
    
                    /**
                     * SigningInput account.
                     * @member {string} account
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.account = "";
    
                    /**
                     * SigningInput destination.
                     * @member {string} destination
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destination = "";
    
                    /**
                     * SigningInput destinationTag.
                     * @member {Long} destinationTag
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destinationTag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput flags.
                     * @member {Long} flags
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.flags = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Ripple.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ripple.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fee);
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sequence);
                        if (message.lastLedgerSequence != null && Object.hasOwnProperty.call(message, "lastLedgerSequence"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lastLedgerSequence);
                        if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.account);
                        if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.destination);
                        if (message.destinationTag != null && Object.hasOwnProperty.call(message, "destinationTag"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.destinationTag);
                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.flags);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ripple.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ripple.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.fee = reader.int64();
                                break;
                            case 3:
                                message.sequence = reader.int32();
                                break;
                            case 4:
                                message.lastLedgerSequence = reader.int32();
                                break;
                            case 5:
                                message.account = reader.string();
                                break;
                            case 6:
                                message.destination = reader.string();
                                break;
                            case 7:
                                message.destinationTag = reader.int64();
                                break;
                            case 8:
                                message.flags = reader.int64();
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        if (message.lastLedgerSequence != null && message.hasOwnProperty("lastLedgerSequence"))
                            if (!$util.isInteger(message.lastLedgerSequence))
                                return "lastLedgerSequence: integer expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.destinationTag != null && message.hasOwnProperty("destinationTag"))
                            if (!$util.isInteger(message.destinationTag) && !(message.destinationTag && $util.isInteger(message.destinationTag.low) && $util.isInteger(message.destinationTag.high)))
                                return "destinationTag: integer|Long expected";
                        if (message.flags != null && message.hasOwnProperty("flags"))
                            if (!$util.isInteger(message.flags) && !(message.flags && $util.isInteger(message.flags.low) && $util.isInteger(message.flags.high)))
                                return "flags: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ripple.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ripple.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Ripple.Proto.SigningInput();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.sequence != null)
                            message.sequence = object.sequence | 0;
                        if (object.lastLedgerSequence != null)
                            message.lastLedgerSequence = object.lastLedgerSequence | 0;
                        if (object.account != null)
                            message.account = String(object.account);
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.destinationTag != null)
                            if ($util.Long)
                                (message.destinationTag = $util.Long.fromValue(object.destinationTag)).unsigned = false;
                            else if (typeof object.destinationTag === "string")
                                message.destinationTag = parseInt(object.destinationTag, 10);
                            else if (typeof object.destinationTag === "number")
                                message.destinationTag = object.destinationTag;
                            else if (typeof object.destinationTag === "object")
                                message.destinationTag = new $util.LongBits(object.destinationTag.low >>> 0, object.destinationTag.high >>> 0).toNumber();
                        if (object.flags != null)
                            if ($util.Long)
                                (message.flags = $util.Long.fromValue(object.flags)).unsigned = false;
                            else if (typeof object.flags === "string")
                                message.flags = parseInt(object.flags, 10);
                            else if (typeof object.flags === "number")
                                message.flags = object.flags;
                            else if (typeof object.flags === "object")
                                message.flags = new $util.LongBits(object.flags.low >>> 0, object.flags.high >>> 0).toNumber();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {TW.Ripple.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.sequence = 0;
                            object.lastLedgerSequence = 0;
                            object.account = "";
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.destinationTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.destinationTag = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.flags = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.flags = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.lastLedgerSequence != null && message.hasOwnProperty("lastLedgerSequence"))
                            object.lastLedgerSequence = message.lastLedgerSequence;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.destinationTag != null && message.hasOwnProperty("destinationTag"))
                            if (typeof message.destinationTag === "number")
                                object.destinationTag = options.longs === String ? String(message.destinationTag) : message.destinationTag;
                            else
                                object.destinationTag = options.longs === String ? $util.Long.prototype.toString.call(message.destinationTag) : options.longs === Number ? new $util.LongBits(message.destinationTag.low >>> 0, message.destinationTag.high >>> 0).toNumber() : message.destinationTag;
                        if (message.flags != null && message.hasOwnProperty("flags"))
                            if (typeof message.flags === "number")
                                object.flags = options.longs === String ? String(message.flags) : message.flags;
                            else
                                object.flags = options.longs === String ? $util.Long.prototype.toString.call(message.flags) : options.longs === Number ? new $util.LongBits(message.flags.low >>> 0, message.flags.high >>> 0).toNumber() : message.flags;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Ripple.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {TW.Common.Proto.SigningError|null} [error] SigningOutput error
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Ripple.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Ripple.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = 0;
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Ripple.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ripple.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.error);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ripple.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ripple.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.error = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ripple.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ripple.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Ripple.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {TW.Ripple.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            object.error = options.enums === String ? "OK" : 0;
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Ripple;
        })();
    
        TW.Solana = (function() {
    
            /**
             * Namespace Solana.
             * @memberof TW
             * @namespace
             */
            var Solana = {};
    
            Solana.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Solana
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transfer = (function() {
    
                    /**
                     * Properties of a Transfer.
                     * @memberof TW.Solana.Proto
                     * @interface ITransfer
                     * @property {string|null} [recipient] Transfer recipient
                     * @property {Long|null} [value] Transfer value
                     * @property {string|null} [memo] Transfer memo
                     * @property {Array.<string>|null} [references] Transfer references
                     */
    
                    /**
                     * Constructs a new Transfer.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a Transfer.
                     * @implements ITransfer
                     * @constructor
                     * @param {TW.Solana.Proto.ITransfer=} [properties] Properties to set
                     */
                    function Transfer(properties) {
                        this.references = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transfer recipient.
                     * @member {string} recipient
                     * @memberof TW.Solana.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.recipient = "";
    
                    /**
                     * Transfer value.
                     * @member {Long} value
                     * @memberof TW.Solana.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Transfer memo.
                     * @member {string} memo
                     * @memberof TW.Solana.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.memo = "";
    
                    /**
                     * Transfer references.
                     * @member {Array.<string>} references
                     * @memberof TW.Solana.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.references = $util.emptyArray;
    
                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.Transfer
                     * @static
                     * @param {TW.Solana.Proto.ITransfer=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.Transfer} Transfer instance
                     */
                    Transfer.create = function create(properties) {
                        return new Transfer(properties);
                    };
    
                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.Solana.Proto.Transfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.Transfer
                     * @static
                     * @param {TW.Solana.Proto.ITransfer} message Transfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipient);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.memo);
                        if (message.references != null && message.references.length)
                            for (var i = 0; i < message.references.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.references[i]);
                        return writer;
                    };
    
                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.Transfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.Transfer} Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.Transfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.recipient = reader.string();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            case 3:
                                message.memo = reader.string();
                                break;
                            case 4:
                                if (!(message.references && message.references.length))
                                    message.references = [];
                                message.references.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transfer message.
                     * @function verify
                     * @memberof TW.Solana.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            if (!$util.isString(message.recipient))
                                return "recipient: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.references != null && message.hasOwnProperty("references")) {
                            if (!Array.isArray(message.references))
                                return "references: array expected";
                            for (var i = 0; i < message.references.length; ++i)
                                if (!$util.isString(message.references[i]))
                                    return "references: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.Transfer} Transfer
                     */
                    Transfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.Transfer)
                            return object;
                        var message = new $root.TW.Solana.Proto.Transfer();
                        if (object.recipient != null)
                            message.recipient = String(object.recipient);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.references) {
                            if (!Array.isArray(object.references))
                                throw TypeError(".TW.Solana.Proto.Transfer.references: array expected");
                            message.references = [];
                            for (var i = 0; i < object.references.length; ++i)
                                message.references[i] = String(object.references[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.Transfer
                     * @static
                     * @param {TW.Solana.Proto.Transfer} message Transfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.references = [];
                        if (options.defaults) {
                            object.recipient = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            object.memo = "";
                        }
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            object.recipient = message.recipient;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.references && message.references.length) {
                            object.references = [];
                            for (var j = 0; j < message.references.length; ++j)
                                object.references[j] = message.references[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transfer to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.Transfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transfer;
                })();
    
                Proto.DelegateStake = (function() {
    
                    /**
                     * Properties of a DelegateStake.
                     * @memberof TW.Solana.Proto
                     * @interface IDelegateStake
                     * @property {string|null} [validatorPubkey] DelegateStake validatorPubkey
                     * @property {Long|null} [value] DelegateStake value
                     * @property {string|null} [stakeAccount] DelegateStake stakeAccount
                     */
    
                    /**
                     * Constructs a new DelegateStake.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a DelegateStake.
                     * @implements IDelegateStake
                     * @constructor
                     * @param {TW.Solana.Proto.IDelegateStake=} [properties] Properties to set
                     */
                    function DelegateStake(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DelegateStake validatorPubkey.
                     * @member {string} validatorPubkey
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @instance
                     */
                    DelegateStake.prototype.validatorPubkey = "";
    
                    /**
                     * DelegateStake value.
                     * @member {Long} value
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @instance
                     */
                    DelegateStake.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * DelegateStake stakeAccount.
                     * @member {string} stakeAccount
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @instance
                     */
                    DelegateStake.prototype.stakeAccount = "";
    
                    /**
                     * Creates a new DelegateStake instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @static
                     * @param {TW.Solana.Proto.IDelegateStake=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.DelegateStake} DelegateStake instance
                     */
                    DelegateStake.create = function create(properties) {
                        return new DelegateStake(properties);
                    };
    
                    /**
                     * Encodes the specified DelegateStake message. Does not implicitly {@link TW.Solana.Proto.DelegateStake.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @static
                     * @param {TW.Solana.Proto.IDelegateStake} message DelegateStake message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DelegateStake.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.validatorPubkey != null && Object.hasOwnProperty.call(message, "validatorPubkey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.validatorPubkey);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        if (message.stakeAccount != null && Object.hasOwnProperty.call(message, "stakeAccount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.stakeAccount);
                        return writer;
                    };
    
                    /**
                     * Decodes a DelegateStake message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.DelegateStake} DelegateStake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DelegateStake.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.DelegateStake();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.validatorPubkey = reader.string();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            case 3:
                                message.stakeAccount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DelegateStake message.
                     * @function verify
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DelegateStake.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.validatorPubkey != null && message.hasOwnProperty("validatorPubkey"))
                            if (!$util.isString(message.validatorPubkey))
                                return "validatorPubkey: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            if (!$util.isString(message.stakeAccount))
                                return "stakeAccount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DelegateStake message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.DelegateStake} DelegateStake
                     */
                    DelegateStake.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.DelegateStake)
                            return object;
                        var message = new $root.TW.Solana.Proto.DelegateStake();
                        if (object.validatorPubkey != null)
                            message.validatorPubkey = String(object.validatorPubkey);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        if (object.stakeAccount != null)
                            message.stakeAccount = String(object.stakeAccount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DelegateStake message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @static
                     * @param {TW.Solana.Proto.DelegateStake} message DelegateStake
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DelegateStake.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.validatorPubkey = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            object.stakeAccount = "";
                        }
                        if (message.validatorPubkey != null && message.hasOwnProperty("validatorPubkey"))
                            object.validatorPubkey = message.validatorPubkey;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            object.stakeAccount = message.stakeAccount;
                        return object;
                    };
    
                    /**
                     * Converts this DelegateStake to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.DelegateStake
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DelegateStake.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DelegateStake;
                })();
    
                Proto.DeactivateStake = (function() {
    
                    /**
                     * Properties of a DeactivateStake.
                     * @memberof TW.Solana.Proto
                     * @interface IDeactivateStake
                     * @property {string|null} [stakeAccount] DeactivateStake stakeAccount
                     */
    
                    /**
                     * Constructs a new DeactivateStake.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a DeactivateStake.
                     * @implements IDeactivateStake
                     * @constructor
                     * @param {TW.Solana.Proto.IDeactivateStake=} [properties] Properties to set
                     */
                    function DeactivateStake(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DeactivateStake stakeAccount.
                     * @member {string} stakeAccount
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @instance
                     */
                    DeactivateStake.prototype.stakeAccount = "";
    
                    /**
                     * Creates a new DeactivateStake instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @static
                     * @param {TW.Solana.Proto.IDeactivateStake=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.DeactivateStake} DeactivateStake instance
                     */
                    DeactivateStake.create = function create(properties) {
                        return new DeactivateStake(properties);
                    };
    
                    /**
                     * Encodes the specified DeactivateStake message. Does not implicitly {@link TW.Solana.Proto.DeactivateStake.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @static
                     * @param {TW.Solana.Proto.IDeactivateStake} message DeactivateStake message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DeactivateStake.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.stakeAccount != null && Object.hasOwnProperty.call(message, "stakeAccount"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.stakeAccount);
                        return writer;
                    };
    
                    /**
                     * Decodes a DeactivateStake message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.DeactivateStake} DeactivateStake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DeactivateStake.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.DeactivateStake();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.stakeAccount = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DeactivateStake message.
                     * @function verify
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DeactivateStake.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            if (!$util.isString(message.stakeAccount))
                                return "stakeAccount: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DeactivateStake message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.DeactivateStake} DeactivateStake
                     */
                    DeactivateStake.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.DeactivateStake)
                            return object;
                        var message = new $root.TW.Solana.Proto.DeactivateStake();
                        if (object.stakeAccount != null)
                            message.stakeAccount = String(object.stakeAccount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DeactivateStake message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @static
                     * @param {TW.Solana.Proto.DeactivateStake} message DeactivateStake
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DeactivateStake.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.stakeAccount = "";
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            object.stakeAccount = message.stakeAccount;
                        return object;
                    };
    
                    /**
                     * Converts this DeactivateStake to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.DeactivateStake
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DeactivateStake.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DeactivateStake;
                })();
    
                Proto.DeactivateAllStake = (function() {
    
                    /**
                     * Properties of a DeactivateAllStake.
                     * @memberof TW.Solana.Proto
                     * @interface IDeactivateAllStake
                     * @property {Array.<string>|null} [stakeAccounts] DeactivateAllStake stakeAccounts
                     */
    
                    /**
                     * Constructs a new DeactivateAllStake.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a DeactivateAllStake.
                     * @implements IDeactivateAllStake
                     * @constructor
                     * @param {TW.Solana.Proto.IDeactivateAllStake=} [properties] Properties to set
                     */
                    function DeactivateAllStake(properties) {
                        this.stakeAccounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DeactivateAllStake stakeAccounts.
                     * @member {Array.<string>} stakeAccounts
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @instance
                     */
                    DeactivateAllStake.prototype.stakeAccounts = $util.emptyArray;
    
                    /**
                     * Creates a new DeactivateAllStake instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @static
                     * @param {TW.Solana.Proto.IDeactivateAllStake=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.DeactivateAllStake} DeactivateAllStake instance
                     */
                    DeactivateAllStake.create = function create(properties) {
                        return new DeactivateAllStake(properties);
                    };
    
                    /**
                     * Encodes the specified DeactivateAllStake message. Does not implicitly {@link TW.Solana.Proto.DeactivateAllStake.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @static
                     * @param {TW.Solana.Proto.IDeactivateAllStake} message DeactivateAllStake message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DeactivateAllStake.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.stakeAccounts != null && message.stakeAccounts.length)
                            for (var i = 0; i < message.stakeAccounts.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stakeAccounts[i]);
                        return writer;
                    };
    
                    /**
                     * Decodes a DeactivateAllStake message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.DeactivateAllStake} DeactivateAllStake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DeactivateAllStake.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.DeactivateAllStake();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.stakeAccounts && message.stakeAccounts.length))
                                    message.stakeAccounts = [];
                                message.stakeAccounts.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DeactivateAllStake message.
                     * @function verify
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DeactivateAllStake.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stakeAccounts != null && message.hasOwnProperty("stakeAccounts")) {
                            if (!Array.isArray(message.stakeAccounts))
                                return "stakeAccounts: array expected";
                            for (var i = 0; i < message.stakeAccounts.length; ++i)
                                if (!$util.isString(message.stakeAccounts[i]))
                                    return "stakeAccounts: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a DeactivateAllStake message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.DeactivateAllStake} DeactivateAllStake
                     */
                    DeactivateAllStake.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.DeactivateAllStake)
                            return object;
                        var message = new $root.TW.Solana.Proto.DeactivateAllStake();
                        if (object.stakeAccounts) {
                            if (!Array.isArray(object.stakeAccounts))
                                throw TypeError(".TW.Solana.Proto.DeactivateAllStake.stakeAccounts: array expected");
                            message.stakeAccounts = [];
                            for (var i = 0; i < object.stakeAccounts.length; ++i)
                                message.stakeAccounts[i] = String(object.stakeAccounts[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DeactivateAllStake message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @static
                     * @param {TW.Solana.Proto.DeactivateAllStake} message DeactivateAllStake
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DeactivateAllStake.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.stakeAccounts = [];
                        if (message.stakeAccounts && message.stakeAccounts.length) {
                            object.stakeAccounts = [];
                            for (var j = 0; j < message.stakeAccounts.length; ++j)
                                object.stakeAccounts[j] = message.stakeAccounts[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this DeactivateAllStake to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.DeactivateAllStake
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DeactivateAllStake.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DeactivateAllStake;
                })();
    
                Proto.WithdrawStake = (function() {
    
                    /**
                     * Properties of a WithdrawStake.
                     * @memberof TW.Solana.Proto
                     * @interface IWithdrawStake
                     * @property {string|null} [stakeAccount] WithdrawStake stakeAccount
                     * @property {Long|null} [value] WithdrawStake value
                     */
    
                    /**
                     * Constructs a new WithdrawStake.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a WithdrawStake.
                     * @implements IWithdrawStake
                     * @constructor
                     * @param {TW.Solana.Proto.IWithdrawStake=} [properties] Properties to set
                     */
                    function WithdrawStake(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * WithdrawStake stakeAccount.
                     * @member {string} stakeAccount
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @instance
                     */
                    WithdrawStake.prototype.stakeAccount = "";
    
                    /**
                     * WithdrawStake value.
                     * @member {Long} value
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @instance
                     */
                    WithdrawStake.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new WithdrawStake instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @static
                     * @param {TW.Solana.Proto.IWithdrawStake=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.WithdrawStake} WithdrawStake instance
                     */
                    WithdrawStake.create = function create(properties) {
                        return new WithdrawStake(properties);
                    };
    
                    /**
                     * Encodes the specified WithdrawStake message. Does not implicitly {@link TW.Solana.Proto.WithdrawStake.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @static
                     * @param {TW.Solana.Proto.IWithdrawStake} message WithdrawStake message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    WithdrawStake.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.stakeAccount != null && Object.hasOwnProperty.call(message, "stakeAccount"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.stakeAccount);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Decodes a WithdrawStake message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.WithdrawStake} WithdrawStake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    WithdrawStake.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.WithdrawStake();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.stakeAccount = reader.string();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a WithdrawStake message.
                     * @function verify
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    WithdrawStake.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            if (!$util.isString(message.stakeAccount))
                                return "stakeAccount: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a WithdrawStake message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.WithdrawStake} WithdrawStake
                     */
                    WithdrawStake.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.WithdrawStake)
                            return object;
                        var message = new $root.TW.Solana.Proto.WithdrawStake();
                        if (object.stakeAccount != null)
                            message.stakeAccount = String(object.stakeAccount);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a WithdrawStake message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @static
                     * @param {TW.Solana.Proto.WithdrawStake} message WithdrawStake
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    WithdrawStake.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.stakeAccount = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            object.stakeAccount = message.stakeAccount;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this WithdrawStake to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.WithdrawStake
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    WithdrawStake.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return WithdrawStake;
                })();
    
                Proto.StakeAccountValue = (function() {
    
                    /**
                     * Properties of a StakeAccountValue.
                     * @memberof TW.Solana.Proto
                     * @interface IStakeAccountValue
                     * @property {string|null} [stakeAccount] StakeAccountValue stakeAccount
                     * @property {Long|null} [value] StakeAccountValue value
                     */
    
                    /**
                     * Constructs a new StakeAccountValue.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a StakeAccountValue.
                     * @implements IStakeAccountValue
                     * @constructor
                     * @param {TW.Solana.Proto.IStakeAccountValue=} [properties] Properties to set
                     */
                    function StakeAccountValue(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * StakeAccountValue stakeAccount.
                     * @member {string} stakeAccount
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @instance
                     */
                    StakeAccountValue.prototype.stakeAccount = "";
    
                    /**
                     * StakeAccountValue value.
                     * @member {Long} value
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @instance
                     */
                    StakeAccountValue.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new StakeAccountValue instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @static
                     * @param {TW.Solana.Proto.IStakeAccountValue=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.StakeAccountValue} StakeAccountValue instance
                     */
                    StakeAccountValue.create = function create(properties) {
                        return new StakeAccountValue(properties);
                    };
    
                    /**
                     * Encodes the specified StakeAccountValue message. Does not implicitly {@link TW.Solana.Proto.StakeAccountValue.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @static
                     * @param {TW.Solana.Proto.IStakeAccountValue} message StakeAccountValue message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StakeAccountValue.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.stakeAccount != null && Object.hasOwnProperty.call(message, "stakeAccount"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.stakeAccount);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Decodes a StakeAccountValue message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.StakeAccountValue} StakeAccountValue
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StakeAccountValue.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.StakeAccountValue();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.stakeAccount = reader.string();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a StakeAccountValue message.
                     * @function verify
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StakeAccountValue.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            if (!$util.isString(message.stakeAccount))
                                return "stakeAccount: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a StakeAccountValue message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.StakeAccountValue} StakeAccountValue
                     */
                    StakeAccountValue.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.StakeAccountValue)
                            return object;
                        var message = new $root.TW.Solana.Proto.StakeAccountValue();
                        if (object.stakeAccount != null)
                            message.stakeAccount = String(object.stakeAccount);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a StakeAccountValue message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @static
                     * @param {TW.Solana.Proto.StakeAccountValue} message StakeAccountValue
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StakeAccountValue.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.stakeAccount = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.stakeAccount != null && message.hasOwnProperty("stakeAccount"))
                            object.stakeAccount = message.stakeAccount;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this StakeAccountValue to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.StakeAccountValue
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StakeAccountValue.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return StakeAccountValue;
                })();
    
                Proto.WithdrawAllStake = (function() {
    
                    /**
                     * Properties of a WithdrawAllStake.
                     * @memberof TW.Solana.Proto
                     * @interface IWithdrawAllStake
                     * @property {Array.<TW.Solana.Proto.IStakeAccountValue>|null} [stakeAccounts] WithdrawAllStake stakeAccounts
                     */
    
                    /**
                     * Constructs a new WithdrawAllStake.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a WithdrawAllStake.
                     * @implements IWithdrawAllStake
                     * @constructor
                     * @param {TW.Solana.Proto.IWithdrawAllStake=} [properties] Properties to set
                     */
                    function WithdrawAllStake(properties) {
                        this.stakeAccounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * WithdrawAllStake stakeAccounts.
                     * @member {Array.<TW.Solana.Proto.IStakeAccountValue>} stakeAccounts
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @instance
                     */
                    WithdrawAllStake.prototype.stakeAccounts = $util.emptyArray;
    
                    /**
                     * Creates a new WithdrawAllStake instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @static
                     * @param {TW.Solana.Proto.IWithdrawAllStake=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.WithdrawAllStake} WithdrawAllStake instance
                     */
                    WithdrawAllStake.create = function create(properties) {
                        return new WithdrawAllStake(properties);
                    };
    
                    /**
                     * Encodes the specified WithdrawAllStake message. Does not implicitly {@link TW.Solana.Proto.WithdrawAllStake.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @static
                     * @param {TW.Solana.Proto.IWithdrawAllStake} message WithdrawAllStake message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    WithdrawAllStake.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.stakeAccounts != null && message.stakeAccounts.length)
                            for (var i = 0; i < message.stakeAccounts.length; ++i)
                                $root.TW.Solana.Proto.StakeAccountValue.encode(message.stakeAccounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a WithdrawAllStake message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.WithdrawAllStake} WithdrawAllStake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    WithdrawAllStake.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.WithdrawAllStake();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.stakeAccounts && message.stakeAccounts.length))
                                    message.stakeAccounts = [];
                                message.stakeAccounts.push($root.TW.Solana.Proto.StakeAccountValue.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a WithdrawAllStake message.
                     * @function verify
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    WithdrawAllStake.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stakeAccounts != null && message.hasOwnProperty("stakeAccounts")) {
                            if (!Array.isArray(message.stakeAccounts))
                                return "stakeAccounts: array expected";
                            for (var i = 0; i < message.stakeAccounts.length; ++i) {
                                var error = $root.TW.Solana.Proto.StakeAccountValue.verify(message.stakeAccounts[i]);
                                if (error)
                                    return "stakeAccounts." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a WithdrawAllStake message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.WithdrawAllStake} WithdrawAllStake
                     */
                    WithdrawAllStake.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.WithdrawAllStake)
                            return object;
                        var message = new $root.TW.Solana.Proto.WithdrawAllStake();
                        if (object.stakeAccounts) {
                            if (!Array.isArray(object.stakeAccounts))
                                throw TypeError(".TW.Solana.Proto.WithdrawAllStake.stakeAccounts: array expected");
                            message.stakeAccounts = [];
                            for (var i = 0; i < object.stakeAccounts.length; ++i) {
                                if (typeof object.stakeAccounts[i] !== "object")
                                    throw TypeError(".TW.Solana.Proto.WithdrawAllStake.stakeAccounts: object expected");
                                message.stakeAccounts[i] = $root.TW.Solana.Proto.StakeAccountValue.fromObject(object.stakeAccounts[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a WithdrawAllStake message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @static
                     * @param {TW.Solana.Proto.WithdrawAllStake} message WithdrawAllStake
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    WithdrawAllStake.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.stakeAccounts = [];
                        if (message.stakeAccounts && message.stakeAccounts.length) {
                            object.stakeAccounts = [];
                            for (var j = 0; j < message.stakeAccounts.length; ++j)
                                object.stakeAccounts[j] = $root.TW.Solana.Proto.StakeAccountValue.toObject(message.stakeAccounts[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this WithdrawAllStake to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.WithdrawAllStake
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    WithdrawAllStake.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return WithdrawAllStake;
                })();
    
                Proto.CreateTokenAccount = (function() {
    
                    /**
                     * Properties of a CreateTokenAccount.
                     * @memberof TW.Solana.Proto
                     * @interface ICreateTokenAccount
                     * @property {string|null} [mainAddress] CreateTokenAccount mainAddress
                     * @property {string|null} [tokenMintAddress] CreateTokenAccount tokenMintAddress
                     * @property {string|null} [tokenAddress] CreateTokenAccount tokenAddress
                     */
    
                    /**
                     * Constructs a new CreateTokenAccount.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a CreateTokenAccount.
                     * @implements ICreateTokenAccount
                     * @constructor
                     * @param {TW.Solana.Proto.ICreateTokenAccount=} [properties] Properties to set
                     */
                    function CreateTokenAccount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CreateTokenAccount mainAddress.
                     * @member {string} mainAddress
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @instance
                     */
                    CreateTokenAccount.prototype.mainAddress = "";
    
                    /**
                     * CreateTokenAccount tokenMintAddress.
                     * @member {string} tokenMintAddress
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @instance
                     */
                    CreateTokenAccount.prototype.tokenMintAddress = "";
    
                    /**
                     * CreateTokenAccount tokenAddress.
                     * @member {string} tokenAddress
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @instance
                     */
                    CreateTokenAccount.prototype.tokenAddress = "";
    
                    /**
                     * Creates a new CreateTokenAccount instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @static
                     * @param {TW.Solana.Proto.ICreateTokenAccount=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.CreateTokenAccount} CreateTokenAccount instance
                     */
                    CreateTokenAccount.create = function create(properties) {
                        return new CreateTokenAccount(properties);
                    };
    
                    /**
                     * Encodes the specified CreateTokenAccount message. Does not implicitly {@link TW.Solana.Proto.CreateTokenAccount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @static
                     * @param {TW.Solana.Proto.ICreateTokenAccount} message CreateTokenAccount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateTokenAccount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.mainAddress != null && Object.hasOwnProperty.call(message, "mainAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.mainAddress);
                        if (message.tokenMintAddress != null && Object.hasOwnProperty.call(message, "tokenMintAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.tokenMintAddress);
                        if (message.tokenAddress != null && Object.hasOwnProperty.call(message, "tokenAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tokenAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes a CreateTokenAccount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.CreateTokenAccount} CreateTokenAccount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateTokenAccount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.CreateTokenAccount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.mainAddress = reader.string();
                                break;
                            case 2:
                                message.tokenMintAddress = reader.string();
                                break;
                            case 3:
                                message.tokenAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a CreateTokenAccount message.
                     * @function verify
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateTokenAccount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.mainAddress != null && message.hasOwnProperty("mainAddress"))
                            if (!$util.isString(message.mainAddress))
                                return "mainAddress: string expected";
                        if (message.tokenMintAddress != null && message.hasOwnProperty("tokenMintAddress"))
                            if (!$util.isString(message.tokenMintAddress))
                                return "tokenMintAddress: string expected";
                        if (message.tokenAddress != null && message.hasOwnProperty("tokenAddress"))
                            if (!$util.isString(message.tokenAddress))
                                return "tokenAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a CreateTokenAccount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.CreateTokenAccount} CreateTokenAccount
                     */
                    CreateTokenAccount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.CreateTokenAccount)
                            return object;
                        var message = new $root.TW.Solana.Proto.CreateTokenAccount();
                        if (object.mainAddress != null)
                            message.mainAddress = String(object.mainAddress);
                        if (object.tokenMintAddress != null)
                            message.tokenMintAddress = String(object.tokenMintAddress);
                        if (object.tokenAddress != null)
                            message.tokenAddress = String(object.tokenAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CreateTokenAccount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @static
                     * @param {TW.Solana.Proto.CreateTokenAccount} message CreateTokenAccount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateTokenAccount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.mainAddress = "";
                            object.tokenMintAddress = "";
                            object.tokenAddress = "";
                        }
                        if (message.mainAddress != null && message.hasOwnProperty("mainAddress"))
                            object.mainAddress = message.mainAddress;
                        if (message.tokenMintAddress != null && message.hasOwnProperty("tokenMintAddress"))
                            object.tokenMintAddress = message.tokenMintAddress;
                        if (message.tokenAddress != null && message.hasOwnProperty("tokenAddress"))
                            object.tokenAddress = message.tokenAddress;
                        return object;
                    };
    
                    /**
                     * Converts this CreateTokenAccount to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.CreateTokenAccount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateTokenAccount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CreateTokenAccount;
                })();
    
                Proto.TokenTransfer = (function() {
    
                    /**
                     * Properties of a TokenTransfer.
                     * @memberof TW.Solana.Proto
                     * @interface ITokenTransfer
                     * @property {string|null} [tokenMintAddress] TokenTransfer tokenMintAddress
                     * @property {string|null} [senderTokenAddress] TokenTransfer senderTokenAddress
                     * @property {string|null} [recipientTokenAddress] TokenTransfer recipientTokenAddress
                     * @property {Long|null} [amount] TokenTransfer amount
                     * @property {number|null} [decimals] TokenTransfer decimals
                     * @property {string|null} [memo] TokenTransfer memo
                     * @property {Array.<string>|null} [references] TokenTransfer references
                     */
    
                    /**
                     * Constructs a new TokenTransfer.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a TokenTransfer.
                     * @implements ITokenTransfer
                     * @constructor
                     * @param {TW.Solana.Proto.ITokenTransfer=} [properties] Properties to set
                     */
                    function TokenTransfer(properties) {
                        this.references = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenTransfer tokenMintAddress.
                     * @member {string} tokenMintAddress
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     */
                    TokenTransfer.prototype.tokenMintAddress = "";
    
                    /**
                     * TokenTransfer senderTokenAddress.
                     * @member {string} senderTokenAddress
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     */
                    TokenTransfer.prototype.senderTokenAddress = "";
    
                    /**
                     * TokenTransfer recipientTokenAddress.
                     * @member {string} recipientTokenAddress
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     */
                    TokenTransfer.prototype.recipientTokenAddress = "";
    
                    /**
                     * TokenTransfer amount.
                     * @member {Long} amount
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     */
                    TokenTransfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TokenTransfer decimals.
                     * @member {number} decimals
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     */
                    TokenTransfer.prototype.decimals = 0;
    
                    /**
                     * TokenTransfer memo.
                     * @member {string} memo
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     */
                    TokenTransfer.prototype.memo = "";
    
                    /**
                     * TokenTransfer references.
                     * @member {Array.<string>} references
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     */
                    TokenTransfer.prototype.references = $util.emptyArray;
    
                    /**
                     * Creates a new TokenTransfer instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @static
                     * @param {TW.Solana.Proto.ITokenTransfer=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.TokenTransfer} TokenTransfer instance
                     */
                    TokenTransfer.create = function create(properties) {
                        return new TokenTransfer(properties);
                    };
    
                    /**
                     * Encodes the specified TokenTransfer message. Does not implicitly {@link TW.Solana.Proto.TokenTransfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @static
                     * @param {TW.Solana.Proto.ITokenTransfer} message TokenTransfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenTransfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.tokenMintAddress != null && Object.hasOwnProperty.call(message, "tokenMintAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tokenMintAddress);
                        if (message.senderTokenAddress != null && Object.hasOwnProperty.call(message, "senderTokenAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.senderTokenAddress);
                        if (message.recipientTokenAddress != null && Object.hasOwnProperty.call(message, "recipientTokenAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipientTokenAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.amount);
                        if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.decimals);
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.memo);
                        if (message.references != null && message.references.length)
                            for (var i = 0; i < message.references.length; ++i)
                                writer.uint32(/* id 7, wireType 2 =*/58).string(message.references[i]);
                        return writer;
                    };
    
                    /**
                     * Decodes a TokenTransfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.TokenTransfer} TokenTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenTransfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.TokenTransfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.tokenMintAddress = reader.string();
                                break;
                            case 2:
                                message.senderTokenAddress = reader.string();
                                break;
                            case 3:
                                message.recipientTokenAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.uint64();
                                break;
                            case 5:
                                message.decimals = reader.uint32();
                                break;
                            case 6:
                                message.memo = reader.string();
                                break;
                            case 7:
                                if (!(message.references && message.references.length))
                                    message.references = [];
                                message.references.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TokenTransfer message.
                     * @function verify
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenTransfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.tokenMintAddress != null && message.hasOwnProperty("tokenMintAddress"))
                            if (!$util.isString(message.tokenMintAddress))
                                return "tokenMintAddress: string expected";
                        if (message.senderTokenAddress != null && message.hasOwnProperty("senderTokenAddress"))
                            if (!$util.isString(message.senderTokenAddress))
                                return "senderTokenAddress: string expected";
                        if (message.recipientTokenAddress != null && message.hasOwnProperty("recipientTokenAddress"))
                            if (!$util.isString(message.recipientTokenAddress))
                                return "recipientTokenAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            if (!$util.isInteger(message.decimals))
                                return "decimals: integer expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.references != null && message.hasOwnProperty("references")) {
                            if (!Array.isArray(message.references))
                                return "references: array expected";
                            for (var i = 0; i < message.references.length; ++i)
                                if (!$util.isString(message.references[i]))
                                    return "references: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a TokenTransfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.TokenTransfer} TokenTransfer
                     */
                    TokenTransfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.TokenTransfer)
                            return object;
                        var message = new $root.TW.Solana.Proto.TokenTransfer();
                        if (object.tokenMintAddress != null)
                            message.tokenMintAddress = String(object.tokenMintAddress);
                        if (object.senderTokenAddress != null)
                            message.senderTokenAddress = String(object.senderTokenAddress);
                        if (object.recipientTokenAddress != null)
                            message.recipientTokenAddress = String(object.recipientTokenAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.decimals != null)
                            message.decimals = object.decimals >>> 0;
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.references) {
                            if (!Array.isArray(object.references))
                                throw TypeError(".TW.Solana.Proto.TokenTransfer.references: array expected");
                            message.references = [];
                            for (var i = 0; i < object.references.length; ++i)
                                message.references[i] = String(object.references[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenTransfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @static
                     * @param {TW.Solana.Proto.TokenTransfer} message TokenTransfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenTransfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.references = [];
                        if (options.defaults) {
                            object.tokenMintAddress = "";
                            object.senderTokenAddress = "";
                            object.recipientTokenAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.decimals = 0;
                            object.memo = "";
                        }
                        if (message.tokenMintAddress != null && message.hasOwnProperty("tokenMintAddress"))
                            object.tokenMintAddress = message.tokenMintAddress;
                        if (message.senderTokenAddress != null && message.hasOwnProperty("senderTokenAddress"))
                            object.senderTokenAddress = message.senderTokenAddress;
                        if (message.recipientTokenAddress != null && message.hasOwnProperty("recipientTokenAddress"))
                            object.recipientTokenAddress = message.recipientTokenAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            object.decimals = message.decimals;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.references && message.references.length) {
                            object.references = [];
                            for (var j = 0; j < message.references.length; ++j)
                                object.references[j] = message.references[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this TokenTransfer to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.TokenTransfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenTransfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenTransfer;
                })();
    
                Proto.CreateAndTransferToken = (function() {
    
                    /**
                     * Properties of a CreateAndTransferToken.
                     * @memberof TW.Solana.Proto
                     * @interface ICreateAndTransferToken
                     * @property {string|null} [recipientMainAddress] CreateAndTransferToken recipientMainAddress
                     * @property {string|null} [tokenMintAddress] CreateAndTransferToken tokenMintAddress
                     * @property {string|null} [recipientTokenAddress] CreateAndTransferToken recipientTokenAddress
                     * @property {string|null} [senderTokenAddress] CreateAndTransferToken senderTokenAddress
                     * @property {Long|null} [amount] CreateAndTransferToken amount
                     * @property {number|null} [decimals] CreateAndTransferToken decimals
                     * @property {string|null} [memo] CreateAndTransferToken memo
                     * @property {Array.<string>|null} [references] CreateAndTransferToken references
                     */
    
                    /**
                     * Constructs a new CreateAndTransferToken.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a CreateAndTransferToken.
                     * @implements ICreateAndTransferToken
                     * @constructor
                     * @param {TW.Solana.Proto.ICreateAndTransferToken=} [properties] Properties to set
                     */
                    function CreateAndTransferToken(properties) {
                        this.references = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CreateAndTransferToken recipientMainAddress.
                     * @member {string} recipientMainAddress
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.recipientMainAddress = "";
    
                    /**
                     * CreateAndTransferToken tokenMintAddress.
                     * @member {string} tokenMintAddress
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.tokenMintAddress = "";
    
                    /**
                     * CreateAndTransferToken recipientTokenAddress.
                     * @member {string} recipientTokenAddress
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.recipientTokenAddress = "";
    
                    /**
                     * CreateAndTransferToken senderTokenAddress.
                     * @member {string} senderTokenAddress
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.senderTokenAddress = "";
    
                    /**
                     * CreateAndTransferToken amount.
                     * @member {Long} amount
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * CreateAndTransferToken decimals.
                     * @member {number} decimals
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.decimals = 0;
    
                    /**
                     * CreateAndTransferToken memo.
                     * @member {string} memo
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.memo = "";
    
                    /**
                     * CreateAndTransferToken references.
                     * @member {Array.<string>} references
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     */
                    CreateAndTransferToken.prototype.references = $util.emptyArray;
    
                    /**
                     * Creates a new CreateAndTransferToken instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @static
                     * @param {TW.Solana.Proto.ICreateAndTransferToken=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.CreateAndTransferToken} CreateAndTransferToken instance
                     */
                    CreateAndTransferToken.create = function create(properties) {
                        return new CreateAndTransferToken(properties);
                    };
    
                    /**
                     * Encodes the specified CreateAndTransferToken message. Does not implicitly {@link TW.Solana.Proto.CreateAndTransferToken.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @static
                     * @param {TW.Solana.Proto.ICreateAndTransferToken} message CreateAndTransferToken message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateAndTransferToken.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.recipientMainAddress != null && Object.hasOwnProperty.call(message, "recipientMainAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.recipientMainAddress);
                        if (message.tokenMintAddress != null && Object.hasOwnProperty.call(message, "tokenMintAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.tokenMintAddress);
                        if (message.recipientTokenAddress != null && Object.hasOwnProperty.call(message, "recipientTokenAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipientTokenAddress);
                        if (message.senderTokenAddress != null && Object.hasOwnProperty.call(message, "senderTokenAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.senderTokenAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.amount);
                        if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.decimals);
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
                        if (message.references != null && message.references.length)
                            for (var i = 0; i < message.references.length; ++i)
                                writer.uint32(/* id 8, wireType 2 =*/66).string(message.references[i]);
                        return writer;
                    };
    
                    /**
                     * Decodes a CreateAndTransferToken message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.CreateAndTransferToken} CreateAndTransferToken
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateAndTransferToken.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.CreateAndTransferToken();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.recipientMainAddress = reader.string();
                                break;
                            case 2:
                                message.tokenMintAddress = reader.string();
                                break;
                            case 3:
                                message.recipientTokenAddress = reader.string();
                                break;
                            case 4:
                                message.senderTokenAddress = reader.string();
                                break;
                            case 5:
                                message.amount = reader.uint64();
                                break;
                            case 6:
                                message.decimals = reader.uint32();
                                break;
                            case 7:
                                message.memo = reader.string();
                                break;
                            case 8:
                                if (!(message.references && message.references.length))
                                    message.references = [];
                                message.references.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a CreateAndTransferToken message.
                     * @function verify
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateAndTransferToken.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.recipientMainAddress != null && message.hasOwnProperty("recipientMainAddress"))
                            if (!$util.isString(message.recipientMainAddress))
                                return "recipientMainAddress: string expected";
                        if (message.tokenMintAddress != null && message.hasOwnProperty("tokenMintAddress"))
                            if (!$util.isString(message.tokenMintAddress))
                                return "tokenMintAddress: string expected";
                        if (message.recipientTokenAddress != null && message.hasOwnProperty("recipientTokenAddress"))
                            if (!$util.isString(message.recipientTokenAddress))
                                return "recipientTokenAddress: string expected";
                        if (message.senderTokenAddress != null && message.hasOwnProperty("senderTokenAddress"))
                            if (!$util.isString(message.senderTokenAddress))
                                return "senderTokenAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            if (!$util.isInteger(message.decimals))
                                return "decimals: integer expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.references != null && message.hasOwnProperty("references")) {
                            if (!Array.isArray(message.references))
                                return "references: array expected";
                            for (var i = 0; i < message.references.length; ++i)
                                if (!$util.isString(message.references[i]))
                                    return "references: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a CreateAndTransferToken message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.CreateAndTransferToken} CreateAndTransferToken
                     */
                    CreateAndTransferToken.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.CreateAndTransferToken)
                            return object;
                        var message = new $root.TW.Solana.Proto.CreateAndTransferToken();
                        if (object.recipientMainAddress != null)
                            message.recipientMainAddress = String(object.recipientMainAddress);
                        if (object.tokenMintAddress != null)
                            message.tokenMintAddress = String(object.tokenMintAddress);
                        if (object.recipientTokenAddress != null)
                            message.recipientTokenAddress = String(object.recipientTokenAddress);
                        if (object.senderTokenAddress != null)
                            message.senderTokenAddress = String(object.senderTokenAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.decimals != null)
                            message.decimals = object.decimals >>> 0;
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.references) {
                            if (!Array.isArray(object.references))
                                throw TypeError(".TW.Solana.Proto.CreateAndTransferToken.references: array expected");
                            message.references = [];
                            for (var i = 0; i < object.references.length; ++i)
                                message.references[i] = String(object.references[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CreateAndTransferToken message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @static
                     * @param {TW.Solana.Proto.CreateAndTransferToken} message CreateAndTransferToken
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateAndTransferToken.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.references = [];
                        if (options.defaults) {
                            object.recipientMainAddress = "";
                            object.tokenMintAddress = "";
                            object.recipientTokenAddress = "";
                            object.senderTokenAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.decimals = 0;
                            object.memo = "";
                        }
                        if (message.recipientMainAddress != null && message.hasOwnProperty("recipientMainAddress"))
                            object.recipientMainAddress = message.recipientMainAddress;
                        if (message.tokenMintAddress != null && message.hasOwnProperty("tokenMintAddress"))
                            object.tokenMintAddress = message.tokenMintAddress;
                        if (message.recipientTokenAddress != null && message.hasOwnProperty("recipientTokenAddress"))
                            object.recipientTokenAddress = message.recipientTokenAddress;
                        if (message.senderTokenAddress != null && message.hasOwnProperty("senderTokenAddress"))
                            object.senderTokenAddress = message.senderTokenAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            object.decimals = message.decimals;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.references && message.references.length) {
                            object.references = [];
                            for (var j = 0; j < message.references.length; ++j)
                                object.references[j] = message.references[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this CreateAndTransferToken to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.CreateAndTransferToken
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateAndTransferToken.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CreateAndTransferToken;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Solana.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [recentBlockhash] SigningInput recentBlockhash
                     * @property {TW.Solana.Proto.ITransfer|null} [transferTransaction] SigningInput transferTransaction
                     * @property {TW.Solana.Proto.IDelegateStake|null} [delegateStakeTransaction] SigningInput delegateStakeTransaction
                     * @property {TW.Solana.Proto.IDeactivateStake|null} [deactivateStakeTransaction] SigningInput deactivateStakeTransaction
                     * @property {TW.Solana.Proto.IDeactivateAllStake|null} [deactivateAllStakeTransaction] SigningInput deactivateAllStakeTransaction
                     * @property {TW.Solana.Proto.IWithdrawStake|null} [withdrawTransaction] SigningInput withdrawTransaction
                     * @property {TW.Solana.Proto.IWithdrawAllStake|null} [withdrawAllTransaction] SigningInput withdrawAllTransaction
                     * @property {TW.Solana.Proto.ICreateTokenAccount|null} [createTokenAccountTransaction] SigningInput createTokenAccountTransaction
                     * @property {TW.Solana.Proto.ITokenTransfer|null} [tokenTransferTransaction] SigningInput tokenTransferTransaction
                     * @property {TW.Solana.Proto.ICreateAndTransferToken|null} [createAndTransferTokenTransaction] SigningInput createAndTransferTokenTransaction
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Solana.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput recentBlockhash.
                     * @member {string} recentBlockhash
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.recentBlockhash = "";
    
                    /**
                     * SigningInput transferTransaction.
                     * @member {TW.Solana.Proto.ITransfer|null|undefined} transferTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transferTransaction = null;
    
                    /**
                     * SigningInput delegateStakeTransaction.
                     * @member {TW.Solana.Proto.IDelegateStake|null|undefined} delegateStakeTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.delegateStakeTransaction = null;
    
                    /**
                     * SigningInput deactivateStakeTransaction.
                     * @member {TW.Solana.Proto.IDeactivateStake|null|undefined} deactivateStakeTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.deactivateStakeTransaction = null;
    
                    /**
                     * SigningInput deactivateAllStakeTransaction.
                     * @member {TW.Solana.Proto.IDeactivateAllStake|null|undefined} deactivateAllStakeTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.deactivateAllStakeTransaction = null;
    
                    /**
                     * SigningInput withdrawTransaction.
                     * @member {TW.Solana.Proto.IWithdrawStake|null|undefined} withdrawTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.withdrawTransaction = null;
    
                    /**
                     * SigningInput withdrawAllTransaction.
                     * @member {TW.Solana.Proto.IWithdrawAllStake|null|undefined} withdrawAllTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.withdrawAllTransaction = null;
    
                    /**
                     * SigningInput createTokenAccountTransaction.
                     * @member {TW.Solana.Proto.ICreateTokenAccount|null|undefined} createTokenAccountTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.createTokenAccountTransaction = null;
    
                    /**
                     * SigningInput tokenTransferTransaction.
                     * @member {TW.Solana.Proto.ITokenTransfer|null|undefined} tokenTransferTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.tokenTransferTransaction = null;
    
                    /**
                     * SigningInput createAndTransferTokenTransaction.
                     * @member {TW.Solana.Proto.ICreateAndTransferToken|null|undefined} createAndTransferTokenTransaction
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.createAndTransferTokenTransaction = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput transactionType.
                     * @member {"transferTransaction"|"delegateStakeTransaction"|"deactivateStakeTransaction"|"deactivateAllStakeTransaction"|"withdrawTransaction"|"withdrawAllTransaction"|"createTokenAccountTransaction"|"tokenTransferTransaction"|"createAndTransferTokenTransaction"|undefined} transactionType
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "transactionType", {
                        get: $util.oneOfGetter($oneOfFields = ["transferTransaction", "delegateStakeTransaction", "deactivateStakeTransaction", "deactivateAllStakeTransaction", "withdrawTransaction", "withdrawAllTransaction", "createTokenAccountTransaction", "tokenTransferTransaction", "createAndTransferTokenTransaction"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.SigningInput
                     * @static
                     * @param {TW.Solana.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Solana.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.SigningInput
                     * @static
                     * @param {TW.Solana.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.recentBlockhash != null && Object.hasOwnProperty.call(message, "recentBlockhash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.recentBlockhash);
                        if (message.transferTransaction != null && Object.hasOwnProperty.call(message, "transferTransaction"))
                            $root.TW.Solana.Proto.Transfer.encode(message.transferTransaction, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.delegateStakeTransaction != null && Object.hasOwnProperty.call(message, "delegateStakeTransaction"))
                            $root.TW.Solana.Proto.DelegateStake.encode(message.delegateStakeTransaction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.deactivateStakeTransaction != null && Object.hasOwnProperty.call(message, "deactivateStakeTransaction"))
                            $root.TW.Solana.Proto.DeactivateStake.encode(message.deactivateStakeTransaction, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.deactivateAllStakeTransaction != null && Object.hasOwnProperty.call(message, "deactivateAllStakeTransaction"))
                            $root.TW.Solana.Proto.DeactivateAllStake.encode(message.deactivateAllStakeTransaction, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.withdrawTransaction != null && Object.hasOwnProperty.call(message, "withdrawTransaction"))
                            $root.TW.Solana.Proto.WithdrawStake.encode(message.withdrawTransaction, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.withdrawAllTransaction != null && Object.hasOwnProperty.call(message, "withdrawAllTransaction"))
                            $root.TW.Solana.Proto.WithdrawAllStake.encode(message.withdrawAllTransaction, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.createTokenAccountTransaction != null && Object.hasOwnProperty.call(message, "createTokenAccountTransaction"))
                            $root.TW.Solana.Proto.CreateTokenAccount.encode(message.createTokenAccountTransaction, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.tokenTransferTransaction != null && Object.hasOwnProperty.call(message, "tokenTransferTransaction"))
                            $root.TW.Solana.Proto.TokenTransfer.encode(message.tokenTransferTransaction, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.createAndTransferTokenTransaction != null && Object.hasOwnProperty.call(message, "createAndTransferTokenTransaction"))
                            $root.TW.Solana.Proto.CreateAndTransferToken.encode(message.createAndTransferTokenTransaction, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.recentBlockhash = reader.string();
                                break;
                            case 3:
                                message.transferTransaction = $root.TW.Solana.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.delegateStakeTransaction = $root.TW.Solana.Proto.DelegateStake.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.deactivateStakeTransaction = $root.TW.Solana.Proto.DeactivateStake.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.deactivateAllStakeTransaction = $root.TW.Solana.Proto.DeactivateAllStake.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.withdrawTransaction = $root.TW.Solana.Proto.WithdrawStake.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.withdrawAllTransaction = $root.TW.Solana.Proto.WithdrawAllStake.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.createTokenAccountTransaction = $root.TW.Solana.Proto.CreateTokenAccount.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.tokenTransferTransaction = $root.TW.Solana.Proto.TokenTransfer.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.createAndTransferTokenTransaction = $root.TW.Solana.Proto.CreateAndTransferToken.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Solana.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.recentBlockhash != null && message.hasOwnProperty("recentBlockhash"))
                            if (!$util.isString(message.recentBlockhash))
                                return "recentBlockhash: string expected";
                        if (message.transferTransaction != null && message.hasOwnProperty("transferTransaction")) {
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.Transfer.verify(message.transferTransaction);
                                if (error)
                                    return "transferTransaction." + error;
                            }
                        }
                        if (message.delegateStakeTransaction != null && message.hasOwnProperty("delegateStakeTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.DelegateStake.verify(message.delegateStakeTransaction);
                                if (error)
                                    return "delegateStakeTransaction." + error;
                            }
                        }
                        if (message.deactivateStakeTransaction != null && message.hasOwnProperty("deactivateStakeTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.DeactivateStake.verify(message.deactivateStakeTransaction);
                                if (error)
                                    return "deactivateStakeTransaction." + error;
                            }
                        }
                        if (message.deactivateAllStakeTransaction != null && message.hasOwnProperty("deactivateAllStakeTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.DeactivateAllStake.verify(message.deactivateAllStakeTransaction);
                                if (error)
                                    return "deactivateAllStakeTransaction." + error;
                            }
                        }
                        if (message.withdrawTransaction != null && message.hasOwnProperty("withdrawTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.WithdrawStake.verify(message.withdrawTransaction);
                                if (error)
                                    return "withdrawTransaction." + error;
                            }
                        }
                        if (message.withdrawAllTransaction != null && message.hasOwnProperty("withdrawAllTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.WithdrawAllStake.verify(message.withdrawAllTransaction);
                                if (error)
                                    return "withdrawAllTransaction." + error;
                            }
                        }
                        if (message.createTokenAccountTransaction != null && message.hasOwnProperty("createTokenAccountTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.CreateTokenAccount.verify(message.createTokenAccountTransaction);
                                if (error)
                                    return "createTokenAccountTransaction." + error;
                            }
                        }
                        if (message.tokenTransferTransaction != null && message.hasOwnProperty("tokenTransferTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.TokenTransfer.verify(message.tokenTransferTransaction);
                                if (error)
                                    return "tokenTransferTransaction." + error;
                            }
                        }
                        if (message.createAndTransferTokenTransaction != null && message.hasOwnProperty("createAndTransferTokenTransaction")) {
                            if (properties.transactionType === 1)
                                return "transactionType: multiple values";
                            properties.transactionType = 1;
                            {
                                var error = $root.TW.Solana.Proto.CreateAndTransferToken.verify(message.createAndTransferTokenTransaction);
                                if (error)
                                    return "createAndTransferTokenTransaction." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Solana.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.recentBlockhash != null)
                            message.recentBlockhash = String(object.recentBlockhash);
                        if (object.transferTransaction != null) {
                            if (typeof object.transferTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.transferTransaction: object expected");
                            message.transferTransaction = $root.TW.Solana.Proto.Transfer.fromObject(object.transferTransaction);
                        }
                        if (object.delegateStakeTransaction != null) {
                            if (typeof object.delegateStakeTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.delegateStakeTransaction: object expected");
                            message.delegateStakeTransaction = $root.TW.Solana.Proto.DelegateStake.fromObject(object.delegateStakeTransaction);
                        }
                        if (object.deactivateStakeTransaction != null) {
                            if (typeof object.deactivateStakeTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.deactivateStakeTransaction: object expected");
                            message.deactivateStakeTransaction = $root.TW.Solana.Proto.DeactivateStake.fromObject(object.deactivateStakeTransaction);
                        }
                        if (object.deactivateAllStakeTransaction != null) {
                            if (typeof object.deactivateAllStakeTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.deactivateAllStakeTransaction: object expected");
                            message.deactivateAllStakeTransaction = $root.TW.Solana.Proto.DeactivateAllStake.fromObject(object.deactivateAllStakeTransaction);
                        }
                        if (object.withdrawTransaction != null) {
                            if (typeof object.withdrawTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.withdrawTransaction: object expected");
                            message.withdrawTransaction = $root.TW.Solana.Proto.WithdrawStake.fromObject(object.withdrawTransaction);
                        }
                        if (object.withdrawAllTransaction != null) {
                            if (typeof object.withdrawAllTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.withdrawAllTransaction: object expected");
                            message.withdrawAllTransaction = $root.TW.Solana.Proto.WithdrawAllStake.fromObject(object.withdrawAllTransaction);
                        }
                        if (object.createTokenAccountTransaction != null) {
                            if (typeof object.createTokenAccountTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.createTokenAccountTransaction: object expected");
                            message.createTokenAccountTransaction = $root.TW.Solana.Proto.CreateTokenAccount.fromObject(object.createTokenAccountTransaction);
                        }
                        if (object.tokenTransferTransaction != null) {
                            if (typeof object.tokenTransferTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.tokenTransferTransaction: object expected");
                            message.tokenTransferTransaction = $root.TW.Solana.Proto.TokenTransfer.fromObject(object.tokenTransferTransaction);
                        }
                        if (object.createAndTransferTokenTransaction != null) {
                            if (typeof object.createAndTransferTokenTransaction !== "object")
                                throw TypeError(".TW.Solana.Proto.SigningInput.createAndTransferTokenTransaction: object expected");
                            message.createAndTransferTokenTransaction = $root.TW.Solana.Proto.CreateAndTransferToken.fromObject(object.createAndTransferTokenTransaction);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.SigningInput
                     * @static
                     * @param {TW.Solana.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.recentBlockhash = "";
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.recentBlockhash != null && message.hasOwnProperty("recentBlockhash"))
                            object.recentBlockhash = message.recentBlockhash;
                        if (message.transferTransaction != null && message.hasOwnProperty("transferTransaction")) {
                            object.transferTransaction = $root.TW.Solana.Proto.Transfer.toObject(message.transferTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "transferTransaction";
                        }
                        if (message.delegateStakeTransaction != null && message.hasOwnProperty("delegateStakeTransaction")) {
                            object.delegateStakeTransaction = $root.TW.Solana.Proto.DelegateStake.toObject(message.delegateStakeTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "delegateStakeTransaction";
                        }
                        if (message.deactivateStakeTransaction != null && message.hasOwnProperty("deactivateStakeTransaction")) {
                            object.deactivateStakeTransaction = $root.TW.Solana.Proto.DeactivateStake.toObject(message.deactivateStakeTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "deactivateStakeTransaction";
                        }
                        if (message.deactivateAllStakeTransaction != null && message.hasOwnProperty("deactivateAllStakeTransaction")) {
                            object.deactivateAllStakeTransaction = $root.TW.Solana.Proto.DeactivateAllStake.toObject(message.deactivateAllStakeTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "deactivateAllStakeTransaction";
                        }
                        if (message.withdrawTransaction != null && message.hasOwnProperty("withdrawTransaction")) {
                            object.withdrawTransaction = $root.TW.Solana.Proto.WithdrawStake.toObject(message.withdrawTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "withdrawTransaction";
                        }
                        if (message.withdrawAllTransaction != null && message.hasOwnProperty("withdrawAllTransaction")) {
                            object.withdrawAllTransaction = $root.TW.Solana.Proto.WithdrawAllStake.toObject(message.withdrawAllTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "withdrawAllTransaction";
                        }
                        if (message.createTokenAccountTransaction != null && message.hasOwnProperty("createTokenAccountTransaction")) {
                            object.createTokenAccountTransaction = $root.TW.Solana.Proto.CreateTokenAccount.toObject(message.createTokenAccountTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "createTokenAccountTransaction";
                        }
                        if (message.tokenTransferTransaction != null && message.hasOwnProperty("tokenTransferTransaction")) {
                            object.tokenTransferTransaction = $root.TW.Solana.Proto.TokenTransfer.toObject(message.tokenTransferTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "tokenTransferTransaction";
                        }
                        if (message.createAndTransferTokenTransaction != null && message.hasOwnProperty("createAndTransferTokenTransaction")) {
                            object.createAndTransferTokenTransaction = $root.TW.Solana.Proto.CreateAndTransferToken.toObject(message.createAndTransferTokenTransaction, options);
                            if (options.oneofs)
                                object.transactionType = "createAndTransferTokenTransaction";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Solana.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Solana.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Solana.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {string} encoded
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @static
                     * @param {TW.Solana.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Solana.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Solana.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @static
                     * @param {TW.Solana.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Solana.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Solana.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!$util.isString(message.encoded))
                                return "encoded: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Solana.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Solana.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Solana.Proto.SigningOutput();
                        if (object.encoded != null)
                            message.encoded = String(object.encoded);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @static
                     * @param {TW.Solana.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.encoded = "";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Solana.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Solana;
        })();
    
        TW.Stellar = (function() {
    
            /**
             * Namespace Stellar.
             * @memberof TW
             * @namespace
             */
            var Stellar = {};
    
            Stellar.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Stellar
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Asset = (function() {
    
                    /**
                     * Properties of an Asset.
                     * @memberof TW.Stellar.Proto
                     * @interface IAsset
                     * @property {string|null} [issuer] Asset issuer
                     * @property {string|null} [alphanum4] Asset alphanum4
                     */
    
                    /**
                     * Constructs a new Asset.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents an Asset.
                     * @implements IAsset
                     * @constructor
                     * @param {TW.Stellar.Proto.IAsset=} [properties] Properties to set
                     */
                    function Asset(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Asset issuer.
                     * @member {string} issuer
                     * @memberof TW.Stellar.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.issuer = "";
    
                    /**
                     * Asset alphanum4.
                     * @member {string} alphanum4
                     * @memberof TW.Stellar.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.alphanum4 = "";
    
                    /**
                     * Creates a new Asset instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.Asset
                     * @static
                     * @param {TW.Stellar.Proto.IAsset=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.Asset} Asset instance
                     */
                    Asset.create = function create(properties) {
                        return new Asset(properties);
                    };
    
                    /**
                     * Encodes the specified Asset message. Does not implicitly {@link TW.Stellar.Proto.Asset.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.Asset
                     * @static
                     * @param {TW.Stellar.Proto.IAsset} message Asset message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Asset.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.issuer != null && Object.hasOwnProperty.call(message, "issuer"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.issuer);
                        if (message.alphanum4 != null && Object.hasOwnProperty.call(message, "alphanum4"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.alphanum4);
                        return writer;
                    };
    
                    /**
                     * Decodes an Asset message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.Asset
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.Asset} Asset
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Asset.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.Asset();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.issuer = reader.string();
                                break;
                            case 2:
                                message.alphanum4 = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Asset message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Asset.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.issuer != null && message.hasOwnProperty("issuer"))
                            if (!$util.isString(message.issuer))
                                return "issuer: string expected";
                        if (message.alphanum4 != null && message.hasOwnProperty("alphanum4"))
                            if (!$util.isString(message.alphanum4))
                                return "alphanum4: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.Asset} Asset
                     */
                    Asset.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.Asset)
                            return object;
                        var message = new $root.TW.Stellar.Proto.Asset();
                        if (object.issuer != null)
                            message.issuer = String(object.issuer);
                        if (object.alphanum4 != null)
                            message.alphanum4 = String(object.alphanum4);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Asset message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.Asset
                     * @static
                     * @param {TW.Stellar.Proto.Asset} message Asset
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Asset.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.issuer = "";
                            object.alphanum4 = "";
                        }
                        if (message.issuer != null && message.hasOwnProperty("issuer"))
                            object.issuer = message.issuer;
                        if (message.alphanum4 != null && message.hasOwnProperty("alphanum4"))
                            object.alphanum4 = message.alphanum4;
                        return object;
                    };
    
                    /**
                     * Converts this Asset to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.Asset
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Asset.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Asset;
                })();
    
                Proto.OperationCreateAccount = (function() {
    
                    /**
                     * Properties of an OperationCreateAccount.
                     * @memberof TW.Stellar.Proto
                     * @interface IOperationCreateAccount
                     * @property {string|null} [destination] OperationCreateAccount destination
                     * @property {Long|null} [amount] OperationCreateAccount amount
                     */
    
                    /**
                     * Constructs a new OperationCreateAccount.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents an OperationCreateAccount.
                     * @implements IOperationCreateAccount
                     * @constructor
                     * @param {TW.Stellar.Proto.IOperationCreateAccount=} [properties] Properties to set
                     */
                    function OperationCreateAccount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OperationCreateAccount destination.
                     * @member {string} destination
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @instance
                     */
                    OperationCreateAccount.prototype.destination = "";
    
                    /**
                     * OperationCreateAccount amount.
                     * @member {Long} amount
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @instance
                     */
                    OperationCreateAccount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new OperationCreateAccount instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @static
                     * @param {TW.Stellar.Proto.IOperationCreateAccount=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.OperationCreateAccount} OperationCreateAccount instance
                     */
                    OperationCreateAccount.create = function create(properties) {
                        return new OperationCreateAccount(properties);
                    };
    
                    /**
                     * Encodes the specified OperationCreateAccount message. Does not implicitly {@link TW.Stellar.Proto.OperationCreateAccount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @static
                     * @param {TW.Stellar.Proto.IOperationCreateAccount} message OperationCreateAccount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationCreateAccount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes an OperationCreateAccount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.OperationCreateAccount} OperationCreateAccount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationCreateAccount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.OperationCreateAccount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.destination = reader.string();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OperationCreateAccount message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OperationCreateAccount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an OperationCreateAccount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.OperationCreateAccount} OperationCreateAccount
                     */
                    OperationCreateAccount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.OperationCreateAccount)
                            return object;
                        var message = new $root.TW.Stellar.Proto.OperationCreateAccount();
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OperationCreateAccount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @static
                     * @param {TW.Stellar.Proto.OperationCreateAccount} message OperationCreateAccount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OperationCreateAccount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this OperationCreateAccount to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.OperationCreateAccount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OperationCreateAccount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OperationCreateAccount;
                })();
    
                Proto.OperationPayment = (function() {
    
                    /**
                     * Properties of an OperationPayment.
                     * @memberof TW.Stellar.Proto
                     * @interface IOperationPayment
                     * @property {string|null} [destination] OperationPayment destination
                     * @property {TW.Stellar.Proto.IAsset|null} [asset] OperationPayment asset
                     * @property {Long|null} [amount] OperationPayment amount
                     */
    
                    /**
                     * Constructs a new OperationPayment.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents an OperationPayment.
                     * @implements IOperationPayment
                     * @constructor
                     * @param {TW.Stellar.Proto.IOperationPayment=} [properties] Properties to set
                     */
                    function OperationPayment(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OperationPayment destination.
                     * @member {string} destination
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @instance
                     */
                    OperationPayment.prototype.destination = "";
    
                    /**
                     * OperationPayment asset.
                     * @member {TW.Stellar.Proto.IAsset|null|undefined} asset
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @instance
                     */
                    OperationPayment.prototype.asset = null;
    
                    /**
                     * OperationPayment amount.
                     * @member {Long} amount
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @instance
                     */
                    OperationPayment.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new OperationPayment instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @static
                     * @param {TW.Stellar.Proto.IOperationPayment=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.OperationPayment} OperationPayment instance
                     */
                    OperationPayment.create = function create(properties) {
                        return new OperationPayment(properties);
                    };
    
                    /**
                     * Encodes the specified OperationPayment message. Does not implicitly {@link TW.Stellar.Proto.OperationPayment.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @static
                     * @param {TW.Stellar.Proto.IOperationPayment} message OperationPayment message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationPayment.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                        if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                            $root.TW.Stellar.Proto.Asset.encode(message.asset, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes an OperationPayment message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.OperationPayment} OperationPayment
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationPayment.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.OperationPayment();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.destination = reader.string();
                                break;
                            case 2:
                                message.asset = $root.TW.Stellar.Proto.Asset.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OperationPayment message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OperationPayment.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.asset != null && message.hasOwnProperty("asset")) {
                            var error = $root.TW.Stellar.Proto.Asset.verify(message.asset);
                            if (error)
                                return "asset." + error;
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an OperationPayment message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.OperationPayment} OperationPayment
                     */
                    OperationPayment.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.OperationPayment)
                            return object;
                        var message = new $root.TW.Stellar.Proto.OperationPayment();
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.asset != null) {
                            if (typeof object.asset !== "object")
                                throw TypeError(".TW.Stellar.Proto.OperationPayment.asset: object expected");
                            message.asset = $root.TW.Stellar.Proto.Asset.fromObject(object.asset);
                        }
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OperationPayment message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @static
                     * @param {TW.Stellar.Proto.OperationPayment} message OperationPayment
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OperationPayment.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.destination = "";
                            object.asset = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            object.asset = $root.TW.Stellar.Proto.Asset.toObject(message.asset, options);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this OperationPayment to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.OperationPayment
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OperationPayment.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OperationPayment;
                })();
    
                Proto.OperationChangeTrust = (function() {
    
                    /**
                     * Properties of an OperationChangeTrust.
                     * @memberof TW.Stellar.Proto
                     * @interface IOperationChangeTrust
                     * @property {TW.Stellar.Proto.IAsset|null} [asset] OperationChangeTrust asset
                     * @property {Long|null} [validBefore] OperationChangeTrust validBefore
                     */
    
                    /**
                     * Constructs a new OperationChangeTrust.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents an OperationChangeTrust.
                     * @implements IOperationChangeTrust
                     * @constructor
                     * @param {TW.Stellar.Proto.IOperationChangeTrust=} [properties] Properties to set
                     */
                    function OperationChangeTrust(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OperationChangeTrust asset.
                     * @member {TW.Stellar.Proto.IAsset|null|undefined} asset
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @instance
                     */
                    OperationChangeTrust.prototype.asset = null;
    
                    /**
                     * OperationChangeTrust validBefore.
                     * @member {Long} validBefore
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @instance
                     */
                    OperationChangeTrust.prototype.validBefore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new OperationChangeTrust instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @static
                     * @param {TW.Stellar.Proto.IOperationChangeTrust=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.OperationChangeTrust} OperationChangeTrust instance
                     */
                    OperationChangeTrust.create = function create(properties) {
                        return new OperationChangeTrust(properties);
                    };
    
                    /**
                     * Encodes the specified OperationChangeTrust message. Does not implicitly {@link TW.Stellar.Proto.OperationChangeTrust.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @static
                     * @param {TW.Stellar.Proto.IOperationChangeTrust} message OperationChangeTrust message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationChangeTrust.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                            $root.TW.Stellar.Proto.Asset.encode(message.asset, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.validBefore != null && Object.hasOwnProperty.call(message, "validBefore"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.validBefore);
                        return writer;
                    };
    
                    /**
                     * Decodes an OperationChangeTrust message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.OperationChangeTrust} OperationChangeTrust
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationChangeTrust.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.OperationChangeTrust();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.asset = $root.TW.Stellar.Proto.Asset.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.validBefore = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OperationChangeTrust message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OperationChangeTrust.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.asset != null && message.hasOwnProperty("asset")) {
                            var error = $root.TW.Stellar.Proto.Asset.verify(message.asset);
                            if (error)
                                return "asset." + error;
                        }
                        if (message.validBefore != null && message.hasOwnProperty("validBefore"))
                            if (!$util.isInteger(message.validBefore) && !(message.validBefore && $util.isInteger(message.validBefore.low) && $util.isInteger(message.validBefore.high)))
                                return "validBefore: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an OperationChangeTrust message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.OperationChangeTrust} OperationChangeTrust
                     */
                    OperationChangeTrust.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.OperationChangeTrust)
                            return object;
                        var message = new $root.TW.Stellar.Proto.OperationChangeTrust();
                        if (object.asset != null) {
                            if (typeof object.asset !== "object")
                                throw TypeError(".TW.Stellar.Proto.OperationChangeTrust.asset: object expected");
                            message.asset = $root.TW.Stellar.Proto.Asset.fromObject(object.asset);
                        }
                        if (object.validBefore != null)
                            if ($util.Long)
                                (message.validBefore = $util.Long.fromValue(object.validBefore)).unsigned = false;
                            else if (typeof object.validBefore === "string")
                                message.validBefore = parseInt(object.validBefore, 10);
                            else if (typeof object.validBefore === "number")
                                message.validBefore = object.validBefore;
                            else if (typeof object.validBefore === "object")
                                message.validBefore = new $util.LongBits(object.validBefore.low >>> 0, object.validBefore.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OperationChangeTrust message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @static
                     * @param {TW.Stellar.Proto.OperationChangeTrust} message OperationChangeTrust
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OperationChangeTrust.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.asset = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.validBefore = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.validBefore = options.longs === String ? "0" : 0;
                        }
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            object.asset = $root.TW.Stellar.Proto.Asset.toObject(message.asset, options);
                        if (message.validBefore != null && message.hasOwnProperty("validBefore"))
                            if (typeof message.validBefore === "number")
                                object.validBefore = options.longs === String ? String(message.validBefore) : message.validBefore;
                            else
                                object.validBefore = options.longs === String ? $util.Long.prototype.toString.call(message.validBefore) : options.longs === Number ? new $util.LongBits(message.validBefore.low >>> 0, message.validBefore.high >>> 0).toNumber() : message.validBefore;
                        return object;
                    };
    
                    /**
                     * Converts this OperationChangeTrust to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.OperationChangeTrust
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OperationChangeTrust.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OperationChangeTrust;
                })();
    
                /**
                 * ClaimPredicate enum.
                 * @name TW.Stellar.Proto.ClaimPredicate
                 * @enum {number}
                 * @property {number} Predicate_unconditional=0 Predicate_unconditional value
                 */
                Proto.ClaimPredicate = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "Predicate_unconditional"] = 0;
                    return values;
                })();
    
                Proto.Claimant = (function() {
    
                    /**
                     * Properties of a Claimant.
                     * @memberof TW.Stellar.Proto
                     * @interface IClaimant
                     * @property {string|null} [account] Claimant account
                     * @property {TW.Stellar.Proto.ClaimPredicate|null} [predicate] Claimant predicate
                     */
    
                    /**
                     * Constructs a new Claimant.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a Claimant.
                     * @implements IClaimant
                     * @constructor
                     * @param {TW.Stellar.Proto.IClaimant=} [properties] Properties to set
                     */
                    function Claimant(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Claimant account.
                     * @member {string} account
                     * @memberof TW.Stellar.Proto.Claimant
                     * @instance
                     */
                    Claimant.prototype.account = "";
    
                    /**
                     * Claimant predicate.
                     * @member {TW.Stellar.Proto.ClaimPredicate} predicate
                     * @memberof TW.Stellar.Proto.Claimant
                     * @instance
                     */
                    Claimant.prototype.predicate = 0;
    
                    /**
                     * Creates a new Claimant instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.Claimant
                     * @static
                     * @param {TW.Stellar.Proto.IClaimant=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.Claimant} Claimant instance
                     */
                    Claimant.create = function create(properties) {
                        return new Claimant(properties);
                    };
    
                    /**
                     * Encodes the specified Claimant message. Does not implicitly {@link TW.Stellar.Proto.Claimant.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.Claimant
                     * @static
                     * @param {TW.Stellar.Proto.IClaimant} message Claimant message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Claimant.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                        if (message.predicate != null && Object.hasOwnProperty.call(message, "predicate"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.predicate);
                        return writer;
                    };
    
                    /**
                     * Decodes a Claimant message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.Claimant
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.Claimant} Claimant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Claimant.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.Claimant();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = reader.string();
                                break;
                            case 2:
                                message.predicate = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Claimant message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.Claimant
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Claimant.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        if (message.predicate != null && message.hasOwnProperty("predicate"))
                            switch (message.predicate) {
                            default:
                                return "predicate: enum value expected";
                            case 0:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a Claimant message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.Claimant
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.Claimant} Claimant
                     */
                    Claimant.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.Claimant)
                            return object;
                        var message = new $root.TW.Stellar.Proto.Claimant();
                        if (object.account != null)
                            message.account = String(object.account);
                        switch (object.predicate) {
                        case "Predicate_unconditional":
                        case 0:
                            message.predicate = 0;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Claimant message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.Claimant
                     * @static
                     * @param {TW.Stellar.Proto.Claimant} message Claimant
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Claimant.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.account = "";
                            object.predicate = options.enums === String ? "Predicate_unconditional" : 0;
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        if (message.predicate != null && message.hasOwnProperty("predicate"))
                            object.predicate = options.enums === String ? $root.TW.Stellar.Proto.ClaimPredicate[message.predicate] : message.predicate;
                        return object;
                    };
    
                    /**
                     * Converts this Claimant to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.Claimant
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Claimant.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Claimant;
                })();
    
                Proto.OperationCreateClaimableBalance = (function() {
    
                    /**
                     * Properties of an OperationCreateClaimableBalance.
                     * @memberof TW.Stellar.Proto
                     * @interface IOperationCreateClaimableBalance
                     * @property {TW.Stellar.Proto.IAsset|null} [asset] OperationCreateClaimableBalance asset
                     * @property {Long|null} [amount] OperationCreateClaimableBalance amount
                     * @property {Array.<TW.Stellar.Proto.IClaimant>|null} [claimants] OperationCreateClaimableBalance claimants
                     */
    
                    /**
                     * Constructs a new OperationCreateClaimableBalance.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents an OperationCreateClaimableBalance.
                     * @implements IOperationCreateClaimableBalance
                     * @constructor
                     * @param {TW.Stellar.Proto.IOperationCreateClaimableBalance=} [properties] Properties to set
                     */
                    function OperationCreateClaimableBalance(properties) {
                        this.claimants = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OperationCreateClaimableBalance asset.
                     * @member {TW.Stellar.Proto.IAsset|null|undefined} asset
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @instance
                     */
                    OperationCreateClaimableBalance.prototype.asset = null;
    
                    /**
                     * OperationCreateClaimableBalance amount.
                     * @member {Long} amount
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @instance
                     */
                    OperationCreateClaimableBalance.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * OperationCreateClaimableBalance claimants.
                     * @member {Array.<TW.Stellar.Proto.IClaimant>} claimants
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @instance
                     */
                    OperationCreateClaimableBalance.prototype.claimants = $util.emptyArray;
    
                    /**
                     * Creates a new OperationCreateClaimableBalance instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @static
                     * @param {TW.Stellar.Proto.IOperationCreateClaimableBalance=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.OperationCreateClaimableBalance} OperationCreateClaimableBalance instance
                     */
                    OperationCreateClaimableBalance.create = function create(properties) {
                        return new OperationCreateClaimableBalance(properties);
                    };
    
                    /**
                     * Encodes the specified OperationCreateClaimableBalance message. Does not implicitly {@link TW.Stellar.Proto.OperationCreateClaimableBalance.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @static
                     * @param {TW.Stellar.Proto.IOperationCreateClaimableBalance} message OperationCreateClaimableBalance message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationCreateClaimableBalance.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                            $root.TW.Stellar.Proto.Asset.encode(message.asset, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        if (message.claimants != null && message.claimants.length)
                            for (var i = 0; i < message.claimants.length; ++i)
                                $root.TW.Stellar.Proto.Claimant.encode(message.claimants[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an OperationCreateClaimableBalance message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.OperationCreateClaimableBalance} OperationCreateClaimableBalance
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationCreateClaimableBalance.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.OperationCreateClaimableBalance();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.asset = $root.TW.Stellar.Proto.Asset.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            case 3:
                                if (!(message.claimants && message.claimants.length))
                                    message.claimants = [];
                                message.claimants.push($root.TW.Stellar.Proto.Claimant.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OperationCreateClaimableBalance message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OperationCreateClaimableBalance.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.asset != null && message.hasOwnProperty("asset")) {
                            var error = $root.TW.Stellar.Proto.Asset.verify(message.asset);
                            if (error)
                                return "asset." + error;
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.claimants != null && message.hasOwnProperty("claimants")) {
                            if (!Array.isArray(message.claimants))
                                return "claimants: array expected";
                            for (var i = 0; i < message.claimants.length; ++i) {
                                var error = $root.TW.Stellar.Proto.Claimant.verify(message.claimants[i]);
                                if (error)
                                    return "claimants." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an OperationCreateClaimableBalance message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.OperationCreateClaimableBalance} OperationCreateClaimableBalance
                     */
                    OperationCreateClaimableBalance.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.OperationCreateClaimableBalance)
                            return object;
                        var message = new $root.TW.Stellar.Proto.OperationCreateClaimableBalance();
                        if (object.asset != null) {
                            if (typeof object.asset !== "object")
                                throw TypeError(".TW.Stellar.Proto.OperationCreateClaimableBalance.asset: object expected");
                            message.asset = $root.TW.Stellar.Proto.Asset.fromObject(object.asset);
                        }
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.claimants) {
                            if (!Array.isArray(object.claimants))
                                throw TypeError(".TW.Stellar.Proto.OperationCreateClaimableBalance.claimants: array expected");
                            message.claimants = [];
                            for (var i = 0; i < object.claimants.length; ++i) {
                                if (typeof object.claimants[i] !== "object")
                                    throw TypeError(".TW.Stellar.Proto.OperationCreateClaimableBalance.claimants: object expected");
                                message.claimants[i] = $root.TW.Stellar.Proto.Claimant.fromObject(object.claimants[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OperationCreateClaimableBalance message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @static
                     * @param {TW.Stellar.Proto.OperationCreateClaimableBalance} message OperationCreateClaimableBalance
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OperationCreateClaimableBalance.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.claimants = [];
                        if (options.defaults) {
                            object.asset = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            object.asset = $root.TW.Stellar.Proto.Asset.toObject(message.asset, options);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.claimants && message.claimants.length) {
                            object.claimants = [];
                            for (var j = 0; j < message.claimants.length; ++j)
                                object.claimants[j] = $root.TW.Stellar.Proto.Claimant.toObject(message.claimants[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this OperationCreateClaimableBalance to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.OperationCreateClaimableBalance
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OperationCreateClaimableBalance.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OperationCreateClaimableBalance;
                })();
    
                Proto.OperationClaimClaimableBalance = (function() {
    
                    /**
                     * Properties of an OperationClaimClaimableBalance.
                     * @memberof TW.Stellar.Proto
                     * @interface IOperationClaimClaimableBalance
                     * @property {Uint8Array|null} [balanceId] OperationClaimClaimableBalance balanceId
                     */
    
                    /**
                     * Constructs a new OperationClaimClaimableBalance.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents an OperationClaimClaimableBalance.
                     * @implements IOperationClaimClaimableBalance
                     * @constructor
                     * @param {TW.Stellar.Proto.IOperationClaimClaimableBalance=} [properties] Properties to set
                     */
                    function OperationClaimClaimableBalance(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OperationClaimClaimableBalance balanceId.
                     * @member {Uint8Array} balanceId
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @instance
                     */
                    OperationClaimClaimableBalance.prototype.balanceId = $util.newBuffer([]);
    
                    /**
                     * Creates a new OperationClaimClaimableBalance instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @static
                     * @param {TW.Stellar.Proto.IOperationClaimClaimableBalance=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.OperationClaimClaimableBalance} OperationClaimClaimableBalance instance
                     */
                    OperationClaimClaimableBalance.create = function create(properties) {
                        return new OperationClaimClaimableBalance(properties);
                    };
    
                    /**
                     * Encodes the specified OperationClaimClaimableBalance message. Does not implicitly {@link TW.Stellar.Proto.OperationClaimClaimableBalance.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @static
                     * @param {TW.Stellar.Proto.IOperationClaimClaimableBalance} message OperationClaimClaimableBalance message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationClaimClaimableBalance.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.balanceId != null && Object.hasOwnProperty.call(message, "balanceId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.balanceId);
                        return writer;
                    };
    
                    /**
                     * Decodes an OperationClaimClaimableBalance message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.OperationClaimClaimableBalance} OperationClaimClaimableBalance
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationClaimClaimableBalance.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.OperationClaimClaimableBalance();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.balanceId = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OperationClaimClaimableBalance message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OperationClaimClaimableBalance.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.balanceId != null && message.hasOwnProperty("balanceId"))
                            if (!(message.balanceId && typeof message.balanceId.length === "number" || $util.isString(message.balanceId)))
                                return "balanceId: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates an OperationClaimClaimableBalance message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.OperationClaimClaimableBalance} OperationClaimClaimableBalance
                     */
                    OperationClaimClaimableBalance.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.OperationClaimClaimableBalance)
                            return object;
                        var message = new $root.TW.Stellar.Proto.OperationClaimClaimableBalance();
                        if (object.balanceId != null)
                            if (typeof object.balanceId === "string")
                                $util.base64.decode(object.balanceId, message.balanceId = $util.newBuffer($util.base64.length(object.balanceId)), 0);
                            else if (object.balanceId.length)
                                message.balanceId = object.balanceId;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OperationClaimClaimableBalance message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @static
                     * @param {TW.Stellar.Proto.OperationClaimClaimableBalance} message OperationClaimClaimableBalance
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OperationClaimClaimableBalance.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.balanceId = "";
                            else {
                                object.balanceId = [];
                                if (options.bytes !== Array)
                                    object.balanceId = $util.newBuffer(object.balanceId);
                            }
                        if (message.balanceId != null && message.hasOwnProperty("balanceId"))
                            object.balanceId = options.bytes === String ? $util.base64.encode(message.balanceId, 0, message.balanceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.balanceId) : message.balanceId;
                        return object;
                    };
    
                    /**
                     * Converts this OperationClaimClaimableBalance to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.OperationClaimClaimableBalance
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OperationClaimClaimableBalance.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OperationClaimClaimableBalance;
                })();
    
                Proto.MemoVoid = (function() {
    
                    /**
                     * Properties of a MemoVoid.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoVoid
                     */
    
                    /**
                     * Constructs a new MemoVoid.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoVoid.
                     * @implements IMemoVoid
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoVoid=} [properties] Properties to set
                     */
                    function MemoVoid(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new MemoVoid instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {TW.Stellar.Proto.IMemoVoid=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoVoid} MemoVoid instance
                     */
                    MemoVoid.create = function create(properties) {
                        return new MemoVoid(properties);
                    };
    
                    /**
                     * Encodes the specified MemoVoid message. Does not implicitly {@link TW.Stellar.Proto.MemoVoid.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {TW.Stellar.Proto.IMemoVoid} message MemoVoid message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoVoid.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a MemoVoid message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoVoid} MemoVoid
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoVoid.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoVoid();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a MemoVoid message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoVoid.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoVoid message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoVoid} MemoVoid
                     */
                    MemoVoid.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoVoid)
                            return object;
                        return new $root.TW.Stellar.Proto.MemoVoid();
                    };
    
                    /**
                     * Creates a plain object from a MemoVoid message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {TW.Stellar.Proto.MemoVoid} message MemoVoid
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoVoid.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this MemoVoid to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoVoid.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoVoid;
                })();
    
                Proto.MemoText = (function() {
    
                    /**
                     * Properties of a MemoText.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoText
                     * @property {string|null} [text] MemoText text
                     */
    
                    /**
                     * Constructs a new MemoText.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoText.
                     * @implements IMemoText
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoText=} [properties] Properties to set
                     */
                    function MemoText(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * MemoText text.
                     * @member {string} text
                     * @memberof TW.Stellar.Proto.MemoText
                     * @instance
                     */
                    MemoText.prototype.text = "";
    
                    /**
                     * Creates a new MemoText instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {TW.Stellar.Proto.IMemoText=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoText} MemoText instance
                     */
                    MemoText.create = function create(properties) {
                        return new MemoText(properties);
                    };
    
                    /**
                     * Encodes the specified MemoText message. Does not implicitly {@link TW.Stellar.Proto.MemoText.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {TW.Stellar.Proto.IMemoText} message MemoText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoText.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                        return writer;
                    };
    
                    /**
                     * Decodes a MemoText message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoText} MemoText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoText.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoText();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.text = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a MemoText message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoText.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoText message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoText} MemoText
                     */
                    MemoText.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoText)
                            return object;
                        var message = new $root.TW.Stellar.Proto.MemoText();
                        if (object.text != null)
                            message.text = String(object.text);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a MemoText message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {TW.Stellar.Proto.MemoText} message MemoText
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoText.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.text = "";
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        return object;
                    };
    
                    /**
                     * Converts this MemoText to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoText
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoText.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoText;
                })();
    
                Proto.MemoId = (function() {
    
                    /**
                     * Properties of a MemoId.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoId
                     * @property {Long|null} [id] MemoId id
                     */
    
                    /**
                     * Constructs a new MemoId.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoId.
                     * @implements IMemoId
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoId=} [properties] Properties to set
                     */
                    function MemoId(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * MemoId id.
                     * @member {Long} id
                     * @memberof TW.Stellar.Proto.MemoId
                     * @instance
                     */
                    MemoId.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new MemoId instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {TW.Stellar.Proto.IMemoId=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoId} MemoId instance
                     */
                    MemoId.create = function create(properties) {
                        return new MemoId(properties);
                    };
    
                    /**
                     * Encodes the specified MemoId message. Does not implicitly {@link TW.Stellar.Proto.MemoId.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {TW.Stellar.Proto.IMemoId} message MemoId message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoId.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
                        return writer;
                    };
    
                    /**
                     * Decodes a MemoId message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoId} MemoId
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoId.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoId();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a MemoId message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoId.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                                return "id: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoId message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoId} MemoId
                     */
                    MemoId.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoId)
                            return object;
                        var message = new $root.TW.Stellar.Proto.MemoId();
                        if (object.id != null)
                            if ($util.Long)
                                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                            else if (typeof object.id === "string")
                                message.id = parseInt(object.id, 10);
                            else if (typeof object.id === "number")
                                message.id = object.id;
                            else if (typeof object.id === "object")
                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a MemoId message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {TW.Stellar.Proto.MemoId} message MemoId
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoId.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.id = options.longs === String ? "0" : 0;
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (typeof message.id === "number")
                                object.id = options.longs === String ? String(message.id) : message.id;
                            else
                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                        return object;
                    };
    
                    /**
                     * Converts this MemoId to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoId
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoId.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoId;
                })();
    
                Proto.MemoHash = (function() {
    
                    /**
                     * Properties of a MemoHash.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoHash
                     * @property {Uint8Array|null} [hash] MemoHash hash
                     */
    
                    /**
                     * Constructs a new MemoHash.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoHash.
                     * @implements IMemoHash
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoHash=} [properties] Properties to set
                     */
                    function MemoHash(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * MemoHash hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @instance
                     */
                    MemoHash.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * Creates a new MemoHash instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {TW.Stellar.Proto.IMemoHash=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoHash} MemoHash instance
                     */
                    MemoHash.create = function create(properties) {
                        return new MemoHash(properties);
                    };
    
                    /**
                     * Encodes the specified MemoHash message. Does not implicitly {@link TW.Stellar.Proto.MemoHash.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {TW.Stellar.Proto.IMemoHash} message MemoHash message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoHash.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                        return writer;
                    };
    
                    /**
                     * Decodes a MemoHash message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoHash} MemoHash
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoHash.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoHash();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hash = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a MemoHash message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoHash.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoHash message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoHash} MemoHash
                     */
                    MemoHash.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoHash)
                            return object;
                        var message = new $root.TW.Stellar.Proto.MemoHash();
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a MemoHash message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {TW.Stellar.Proto.MemoHash} message MemoHash
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoHash.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        return object;
                    };
    
                    /**
                     * Converts this MemoHash to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoHash.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoHash;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Stellar.Proto
                     * @interface ISigningInput
                     * @property {number|null} [fee] SigningInput fee
                     * @property {Long|null} [sequence] SigningInput sequence
                     * @property {string|null} [account] SigningInput account
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [passphrase] SigningInput passphrase
                     * @property {TW.Stellar.Proto.IOperationCreateAccount|null} [opCreateAccount] SigningInput opCreateAccount
                     * @property {TW.Stellar.Proto.IOperationPayment|null} [opPayment] SigningInput opPayment
                     * @property {TW.Stellar.Proto.IOperationChangeTrust|null} [opChangeTrust] SigningInput opChangeTrust
                     * @property {TW.Stellar.Proto.IOperationCreateClaimableBalance|null} [opCreateClaimableBalance] SigningInput opCreateClaimableBalance
                     * @property {TW.Stellar.Proto.IOperationClaimClaimableBalance|null} [opClaimClaimableBalance] SigningInput opClaimClaimableBalance
                     * @property {TW.Stellar.Proto.IMemoVoid|null} [memoVoid] SigningInput memoVoid
                     * @property {TW.Stellar.Proto.IMemoText|null} [memoText] SigningInput memoText
                     * @property {TW.Stellar.Proto.IMemoId|null} [memoId] SigningInput memoId
                     * @property {TW.Stellar.Proto.IMemoHash|null} [memoHash] SigningInput memoHash
                     * @property {TW.Stellar.Proto.IMemoHash|null} [memoReturnHash] SigningInput memoReturnHash
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Stellar.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput fee.
                     * @member {number} fee
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = 0;
    
                    /**
                     * SigningInput sequence.
                     * @member {Long} sequence
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput account.
                     * @member {string} account
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.account = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput passphrase.
                     * @member {string} passphrase
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.passphrase = "";
    
                    /**
                     * SigningInput opCreateAccount.
                     * @member {TW.Stellar.Proto.IOperationCreateAccount|null|undefined} opCreateAccount
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.opCreateAccount = null;
    
                    /**
                     * SigningInput opPayment.
                     * @member {TW.Stellar.Proto.IOperationPayment|null|undefined} opPayment
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.opPayment = null;
    
                    /**
                     * SigningInput opChangeTrust.
                     * @member {TW.Stellar.Proto.IOperationChangeTrust|null|undefined} opChangeTrust
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.opChangeTrust = null;
    
                    /**
                     * SigningInput opCreateClaimableBalance.
                     * @member {TW.Stellar.Proto.IOperationCreateClaimableBalance|null|undefined} opCreateClaimableBalance
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.opCreateClaimableBalance = null;
    
                    /**
                     * SigningInput opClaimClaimableBalance.
                     * @member {TW.Stellar.Proto.IOperationClaimClaimableBalance|null|undefined} opClaimClaimableBalance
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.opClaimClaimableBalance = null;
    
                    /**
                     * SigningInput memoVoid.
                     * @member {TW.Stellar.Proto.IMemoVoid|null|undefined} memoVoid
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoVoid = null;
    
                    /**
                     * SigningInput memoText.
                     * @member {TW.Stellar.Proto.IMemoText|null|undefined} memoText
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoText = null;
    
                    /**
                     * SigningInput memoId.
                     * @member {TW.Stellar.Proto.IMemoId|null|undefined} memoId
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoId = null;
    
                    /**
                     * SigningInput memoHash.
                     * @member {TW.Stellar.Proto.IMemoHash|null|undefined} memoHash
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoHash = null;
    
                    /**
                     * SigningInput memoReturnHash.
                     * @member {TW.Stellar.Proto.IMemoHash|null|undefined} memoReturnHash
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoReturnHash = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput operationOneof.
                     * @member {"opCreateAccount"|"opPayment"|"opChangeTrust"|"opCreateClaimableBalance"|"opClaimClaimableBalance"|undefined} operationOneof
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "operationOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["opCreateAccount", "opPayment", "opChangeTrust", "opCreateClaimableBalance", "opClaimClaimableBalance"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * SigningInput memoTypeOneof.
                     * @member {"memoVoid"|"memoText"|"memoId"|"memoHash"|"memoReturnHash"|undefined} memoTypeOneof
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "memoTypeOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["memoVoid", "memoText", "memoId", "memoHash", "memoReturnHash"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Stellar.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fee);
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
                        if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.account);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.privateKey);
                        if (message.passphrase != null && Object.hasOwnProperty.call(message, "passphrase"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.passphrase);
                        if (message.opCreateAccount != null && Object.hasOwnProperty.call(message, "opCreateAccount"))
                            $root.TW.Stellar.Proto.OperationCreateAccount.encode(message.opCreateAccount, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.opPayment != null && Object.hasOwnProperty.call(message, "opPayment"))
                            $root.TW.Stellar.Proto.OperationPayment.encode(message.opPayment, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.opChangeTrust != null && Object.hasOwnProperty.call(message, "opChangeTrust"))
                            $root.TW.Stellar.Proto.OperationChangeTrust.encode(message.opChangeTrust, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.memoVoid != null && Object.hasOwnProperty.call(message, "memoVoid"))
                            $root.TW.Stellar.Proto.MemoVoid.encode(message.memoVoid, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.memoText != null && Object.hasOwnProperty.call(message, "memoText"))
                            $root.TW.Stellar.Proto.MemoText.encode(message.memoText, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.memoId != null && Object.hasOwnProperty.call(message, "memoId"))
                            $root.TW.Stellar.Proto.MemoId.encode(message.memoId, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.memoHash != null && Object.hasOwnProperty.call(message, "memoHash"))
                            $root.TW.Stellar.Proto.MemoHash.encode(message.memoHash, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.memoReturnHash != null && Object.hasOwnProperty.call(message, "memoReturnHash"))
                            $root.TW.Stellar.Proto.MemoHash.encode(message.memoReturnHash, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                        if (message.opCreateClaimableBalance != null && Object.hasOwnProperty.call(message, "opCreateClaimableBalance"))
                            $root.TW.Stellar.Proto.OperationCreateClaimableBalance.encode(message.opCreateClaimableBalance, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                        if (message.opClaimClaimableBalance != null && Object.hasOwnProperty.call(message, "opClaimClaimableBalance"))
                            $root.TW.Stellar.Proto.OperationClaimClaimableBalance.encode(message.opClaimClaimableBalance, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fee = reader.int32();
                                break;
                            case 2:
                                message.sequence = reader.int64();
                                break;
                            case 3:
                                message.account = reader.string();
                                break;
                            case 4:
                                message.privateKey = reader.bytes();
                                break;
                            case 5:
                                message.passphrase = reader.string();
                                break;
                            case 6:
                                message.opCreateAccount = $root.TW.Stellar.Proto.OperationCreateAccount.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.opPayment = $root.TW.Stellar.Proto.OperationPayment.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.opChangeTrust = $root.TW.Stellar.Proto.OperationChangeTrust.decode(reader, reader.uint32());
                                break;
                            case 14:
                                message.opCreateClaimableBalance = $root.TW.Stellar.Proto.OperationCreateClaimableBalance.decode(reader, reader.uint32());
                                break;
                            case 15:
                                message.opClaimClaimableBalance = $root.TW.Stellar.Proto.OperationClaimClaimableBalance.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.memoVoid = $root.TW.Stellar.Proto.MemoVoid.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.memoText = $root.TW.Stellar.Proto.MemoText.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.memoId = $root.TW.Stellar.Proto.MemoId.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.memoHash = $root.TW.Stellar.Proto.MemoHash.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.memoReturnHash = $root.TW.Stellar.Proto.MemoHash.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee))
                                return "fee: integer expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.passphrase != null && message.hasOwnProperty("passphrase"))
                            if (!$util.isString(message.passphrase))
                                return "passphrase: string expected";
                        if (message.opCreateAccount != null && message.hasOwnProperty("opCreateAccount")) {
                            properties.operationOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.OperationCreateAccount.verify(message.opCreateAccount);
                                if (error)
                                    return "opCreateAccount." + error;
                            }
                        }
                        if (message.opPayment != null && message.hasOwnProperty("opPayment")) {
                            if (properties.operationOneof === 1)
                                return "operationOneof: multiple values";
                            properties.operationOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.OperationPayment.verify(message.opPayment);
                                if (error)
                                    return "opPayment." + error;
                            }
                        }
                        if (message.opChangeTrust != null && message.hasOwnProperty("opChangeTrust")) {
                            if (properties.operationOneof === 1)
                                return "operationOneof: multiple values";
                            properties.operationOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.OperationChangeTrust.verify(message.opChangeTrust);
                                if (error)
                                    return "opChangeTrust." + error;
                            }
                        }
                        if (message.opCreateClaimableBalance != null && message.hasOwnProperty("opCreateClaimableBalance")) {
                            if (properties.operationOneof === 1)
                                return "operationOneof: multiple values";
                            properties.operationOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.OperationCreateClaimableBalance.verify(message.opCreateClaimableBalance);
                                if (error)
                                    return "opCreateClaimableBalance." + error;
                            }
                        }
                        if (message.opClaimClaimableBalance != null && message.hasOwnProperty("opClaimClaimableBalance")) {
                            if (properties.operationOneof === 1)
                                return "operationOneof: multiple values";
                            properties.operationOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.OperationClaimClaimableBalance.verify(message.opClaimClaimableBalance);
                                if (error)
                                    return "opClaimClaimableBalance." + error;
                            }
                        }
                        if (message.memoVoid != null && message.hasOwnProperty("memoVoid")) {
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoVoid.verify(message.memoVoid);
                                if (error)
                                    return "memoVoid." + error;
                            }
                        }
                        if (message.memoText != null && message.hasOwnProperty("memoText")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoText.verify(message.memoText);
                                if (error)
                                    return "memoText." + error;
                            }
                        }
                        if (message.memoId != null && message.hasOwnProperty("memoId")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoId.verify(message.memoId);
                                if (error)
                                    return "memoId." + error;
                            }
                        }
                        if (message.memoHash != null && message.hasOwnProperty("memoHash")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoHash.verify(message.memoHash);
                                if (error)
                                    return "memoHash." + error;
                            }
                        }
                        if (message.memoReturnHash != null && message.hasOwnProperty("memoReturnHash")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoHash.verify(message.memoReturnHash);
                                if (error)
                                    return "memoReturnHash." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Stellar.Proto.SigningInput();
                        if (object.fee != null)
                            message.fee = object.fee | 0;
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                        if (object.account != null)
                            message.account = String(object.account);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.passphrase != null)
                            message.passphrase = String(object.passphrase);
                        if (object.opCreateAccount != null) {
                            if (typeof object.opCreateAccount !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.opCreateAccount: object expected");
                            message.opCreateAccount = $root.TW.Stellar.Proto.OperationCreateAccount.fromObject(object.opCreateAccount);
                        }
                        if (object.opPayment != null) {
                            if (typeof object.opPayment !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.opPayment: object expected");
                            message.opPayment = $root.TW.Stellar.Proto.OperationPayment.fromObject(object.opPayment);
                        }
                        if (object.opChangeTrust != null) {
                            if (typeof object.opChangeTrust !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.opChangeTrust: object expected");
                            message.opChangeTrust = $root.TW.Stellar.Proto.OperationChangeTrust.fromObject(object.opChangeTrust);
                        }
                        if (object.opCreateClaimableBalance != null) {
                            if (typeof object.opCreateClaimableBalance !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.opCreateClaimableBalance: object expected");
                            message.opCreateClaimableBalance = $root.TW.Stellar.Proto.OperationCreateClaimableBalance.fromObject(object.opCreateClaimableBalance);
                        }
                        if (object.opClaimClaimableBalance != null) {
                            if (typeof object.opClaimClaimableBalance !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.opClaimClaimableBalance: object expected");
                            message.opClaimClaimableBalance = $root.TW.Stellar.Proto.OperationClaimClaimableBalance.fromObject(object.opClaimClaimableBalance);
                        }
                        if (object.memoVoid != null) {
                            if (typeof object.memoVoid !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoVoid: object expected");
                            message.memoVoid = $root.TW.Stellar.Proto.MemoVoid.fromObject(object.memoVoid);
                        }
                        if (object.memoText != null) {
                            if (typeof object.memoText !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoText: object expected");
                            message.memoText = $root.TW.Stellar.Proto.MemoText.fromObject(object.memoText);
                        }
                        if (object.memoId != null) {
                            if (typeof object.memoId !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoId: object expected");
                            message.memoId = $root.TW.Stellar.Proto.MemoId.fromObject(object.memoId);
                        }
                        if (object.memoHash != null) {
                            if (typeof object.memoHash !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoHash: object expected");
                            message.memoHash = $root.TW.Stellar.Proto.MemoHash.fromObject(object.memoHash);
                        }
                        if (object.memoReturnHash != null) {
                            if (typeof object.memoReturnHash !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoReturnHash: object expected");
                            message.memoReturnHash = $root.TW.Stellar.Proto.MemoHash.fromObject(object.memoReturnHash);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {TW.Stellar.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fee = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            object.account = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.passphrase = "";
                        }
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = message.fee;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.passphrase != null && message.hasOwnProperty("passphrase"))
                            object.passphrase = message.passphrase;
                        if (message.opCreateAccount != null && message.hasOwnProperty("opCreateAccount")) {
                            object.opCreateAccount = $root.TW.Stellar.Proto.OperationCreateAccount.toObject(message.opCreateAccount, options);
                            if (options.oneofs)
                                object.operationOneof = "opCreateAccount";
                        }
                        if (message.opPayment != null && message.hasOwnProperty("opPayment")) {
                            object.opPayment = $root.TW.Stellar.Proto.OperationPayment.toObject(message.opPayment, options);
                            if (options.oneofs)
                                object.operationOneof = "opPayment";
                        }
                        if (message.opChangeTrust != null && message.hasOwnProperty("opChangeTrust")) {
                            object.opChangeTrust = $root.TW.Stellar.Proto.OperationChangeTrust.toObject(message.opChangeTrust, options);
                            if (options.oneofs)
                                object.operationOneof = "opChangeTrust";
                        }
                        if (message.memoVoid != null && message.hasOwnProperty("memoVoid")) {
                            object.memoVoid = $root.TW.Stellar.Proto.MemoVoid.toObject(message.memoVoid, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoVoid";
                        }
                        if (message.memoText != null && message.hasOwnProperty("memoText")) {
                            object.memoText = $root.TW.Stellar.Proto.MemoText.toObject(message.memoText, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoText";
                        }
                        if (message.memoId != null && message.hasOwnProperty("memoId")) {
                            object.memoId = $root.TW.Stellar.Proto.MemoId.toObject(message.memoId, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoId";
                        }
                        if (message.memoHash != null && message.hasOwnProperty("memoHash")) {
                            object.memoHash = $root.TW.Stellar.Proto.MemoHash.toObject(message.memoHash, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoHash";
                        }
                        if (message.memoReturnHash != null && message.hasOwnProperty("memoReturnHash")) {
                            object.memoReturnHash = $root.TW.Stellar.Proto.MemoHash.toObject(message.memoReturnHash, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoReturnHash";
                        }
                        if (message.opCreateClaimableBalance != null && message.hasOwnProperty("opCreateClaimableBalance")) {
                            object.opCreateClaimableBalance = $root.TW.Stellar.Proto.OperationCreateClaimableBalance.toObject(message.opCreateClaimableBalance, options);
                            if (options.oneofs)
                                object.operationOneof = "opCreateClaimableBalance";
                        }
                        if (message.opClaimClaimableBalance != null && message.hasOwnProperty("opClaimClaimableBalance")) {
                            object.opClaimClaimableBalance = $root.TW.Stellar.Proto.OperationClaimClaimableBalance.toObject(message.opClaimClaimableBalance, options);
                            if (options.oneofs)
                                object.operationOneof = "opClaimClaimableBalance";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Stellar.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Stellar.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {string} signature
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Stellar.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!$util.isString(message.signature))
                                return "signature: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Stellar.Proto.SigningOutput();
                        if (object.signature != null)
                            message.signature = String(object.signature);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {TW.Stellar.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.signature = "";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Stellar;
        })();
    
        TW.Tezos = (function() {
    
            /**
             * Namespace Tezos.
             * @memberof TW
             * @namespace
             */
            var Tezos = {};
    
            Tezos.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Tezos
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Tezos.Proto
                     * @interface ISigningInput
                     * @property {TW.Tezos.Proto.IOperationList|null} [operationList] SigningInput operationList
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Tezos.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput operationList.
                     * @member {TW.Tezos.Proto.IOperationList|null|undefined} operationList
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.operationList = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Tezos.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.operationList != null && Object.hasOwnProperty.call(message, "operationList"))
                            $root.TW.Tezos.Proto.OperationList.encode(message.operationList, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.operationList = $root.TW.Tezos.Proto.OperationList.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.operationList != null && message.hasOwnProperty("operationList")) {
                            var error = $root.TW.Tezos.Proto.OperationList.verify(message.operationList);
                            if (error)
                                return "operationList." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Tezos.Proto.SigningInput();
                        if (object.operationList != null) {
                            if (typeof object.operationList !== "object")
                                throw TypeError(".TW.Tezos.Proto.SigningInput.operationList: object expected");
                            message.operationList = $root.TW.Tezos.Proto.OperationList.fromObject(object.operationList);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {TW.Tezos.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.operationList = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.operationList != null && message.hasOwnProperty("operationList"))
                            object.operationList = $root.TW.Tezos.Proto.OperationList.toObject(message.operationList, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Tezos.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Tezos.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Tezos.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Tezos.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {TW.Tezos.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.OperationList = (function() {
    
                    /**
                     * Properties of an OperationList.
                     * @memberof TW.Tezos.Proto
                     * @interface IOperationList
                     * @property {string|null} [branch] OperationList branch
                     * @property {Array.<TW.Tezos.Proto.IOperation>|null} [operations] OperationList operations
                     */
    
                    /**
                     * Constructs a new OperationList.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents an OperationList.
                     * @implements IOperationList
                     * @constructor
                     * @param {TW.Tezos.Proto.IOperationList=} [properties] Properties to set
                     */
                    function OperationList(properties) {
                        this.operations = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OperationList branch.
                     * @member {string} branch
                     * @memberof TW.Tezos.Proto.OperationList
                     * @instance
                     */
                    OperationList.prototype.branch = "";
    
                    /**
                     * OperationList operations.
                     * @member {Array.<TW.Tezos.Proto.IOperation>} operations
                     * @memberof TW.Tezos.Proto.OperationList
                     * @instance
                     */
                    OperationList.prototype.operations = $util.emptyArray;
    
                    /**
                     * Creates a new OperationList instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {TW.Tezos.Proto.IOperationList=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.OperationList} OperationList instance
                     */
                    OperationList.create = function create(properties) {
                        return new OperationList(properties);
                    };
    
                    /**
                     * Encodes the specified OperationList message. Does not implicitly {@link TW.Tezos.Proto.OperationList.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {TW.Tezos.Proto.IOperationList} message OperationList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationList.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.branch != null && Object.hasOwnProperty.call(message, "branch"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.branch);
                        if (message.operations != null && message.operations.length)
                            for (var i = 0; i < message.operations.length; ++i)
                                $root.TW.Tezos.Proto.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an OperationList message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.OperationList} OperationList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationList.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.OperationList();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.branch = reader.string();
                                break;
                            case 2:
                                if (!(message.operations && message.operations.length))
                                    message.operations = [];
                                message.operations.push($root.TW.Tezos.Proto.Operation.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an OperationList message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OperationList.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.branch != null && message.hasOwnProperty("branch"))
                            if (!$util.isString(message.branch))
                                return "branch: string expected";
                        if (message.operations != null && message.hasOwnProperty("operations")) {
                            if (!Array.isArray(message.operations))
                                return "operations: array expected";
                            for (var i = 0; i < message.operations.length; ++i) {
                                var error = $root.TW.Tezos.Proto.Operation.verify(message.operations[i]);
                                if (error)
                                    return "operations." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an OperationList message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.OperationList} OperationList
                     */
                    OperationList.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.OperationList)
                            return object;
                        var message = new $root.TW.Tezos.Proto.OperationList();
                        if (object.branch != null)
                            message.branch = String(object.branch);
                        if (object.operations) {
                            if (!Array.isArray(object.operations))
                                throw TypeError(".TW.Tezos.Proto.OperationList.operations: array expected");
                            message.operations = [];
                            for (var i = 0; i < object.operations.length; ++i) {
                                if (typeof object.operations[i] !== "object")
                                    throw TypeError(".TW.Tezos.Proto.OperationList.operations: object expected");
                                message.operations[i] = $root.TW.Tezos.Proto.Operation.fromObject(object.operations[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OperationList message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {TW.Tezos.Proto.OperationList} message OperationList
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OperationList.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.operations = [];
                        if (options.defaults)
                            object.branch = "";
                        if (message.branch != null && message.hasOwnProperty("branch"))
                            object.branch = message.branch;
                        if (message.operations && message.operations.length) {
                            object.operations = [];
                            for (var j = 0; j < message.operations.length; ++j)
                                object.operations[j] = $root.TW.Tezos.Proto.Operation.toObject(message.operations[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this OperationList to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.OperationList
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OperationList.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OperationList;
                })();
    
                Proto.Operation = (function() {
    
                    /**
                     * Properties of an Operation.
                     * @memberof TW.Tezos.Proto
                     * @interface IOperation
                     * @property {Long|null} [counter] Operation counter
                     * @property {string|null} [source] Operation source
                     * @property {Long|null} [fee] Operation fee
                     * @property {Long|null} [gasLimit] Operation gasLimit
                     * @property {Long|null} [storageLimit] Operation storageLimit
                     * @property {TW.Tezos.Proto.Operation.OperationKind|null} [kind] Operation kind
                     * @property {TW.Tezos.Proto.IRevealOperationData|null} [revealOperationData] Operation revealOperationData
                     * @property {TW.Tezos.Proto.ITransactionOperationData|null} [transactionOperationData] Operation transactionOperationData
                     * @property {TW.Tezos.Proto.IDelegationOperationData|null} [delegationOperationData] Operation delegationOperationData
                     */
    
                    /**
                     * Constructs a new Operation.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents an Operation.
                     * @implements IOperation
                     * @constructor
                     * @param {TW.Tezos.Proto.IOperation=} [properties] Properties to set
                     */
                    function Operation(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Operation counter.
                     * @member {Long} counter
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.counter = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation source.
                     * @member {string} source
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.source = "";
    
                    /**
                     * Operation fee.
                     * @member {Long} fee
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation storageLimit.
                     * @member {Long} storageLimit
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.storageLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation kind.
                     * @member {TW.Tezos.Proto.Operation.OperationKind} kind
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.kind = 0;
    
                    /**
                     * Operation revealOperationData.
                     * @member {TW.Tezos.Proto.IRevealOperationData|null|undefined} revealOperationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.revealOperationData = null;
    
                    /**
                     * Operation transactionOperationData.
                     * @member {TW.Tezos.Proto.ITransactionOperationData|null|undefined} transactionOperationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.transactionOperationData = null;
    
                    /**
                     * Operation delegationOperationData.
                     * @member {TW.Tezos.Proto.IDelegationOperationData|null|undefined} delegationOperationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.delegationOperationData = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Operation operationData.
                     * @member {"revealOperationData"|"transactionOperationData"|"delegationOperationData"|undefined} operationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Object.defineProperty(Operation.prototype, "operationData", {
                        get: $util.oneOfGetter($oneOfFields = ["revealOperationData", "transactionOperationData", "delegationOperationData"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Operation instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {TW.Tezos.Proto.IOperation=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.Operation} Operation instance
                     */
                    Operation.create = function create(properties) {
                        return new Operation(properties);
                    };
    
                    /**
                     * Encodes the specified Operation message. Does not implicitly {@link TW.Tezos.Proto.Operation.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {TW.Tezos.Proto.IOperation} message Operation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Operation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.counter != null && Object.hasOwnProperty.call(message, "counter"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.counter);
                        if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.source);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.gasLimit);
                        if (message.storageLimit != null && Object.hasOwnProperty.call(message, "storageLimit"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.storageLimit);
                        if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.kind);
                        if (message.revealOperationData != null && Object.hasOwnProperty.call(message, "revealOperationData"))
                            $root.TW.Tezos.Proto.RevealOperationData.encode(message.revealOperationData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.transactionOperationData != null && Object.hasOwnProperty.call(message, "transactionOperationData"))
                            $root.TW.Tezos.Proto.TransactionOperationData.encode(message.transactionOperationData, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.delegationOperationData != null && Object.hasOwnProperty.call(message, "delegationOperationData"))
                            $root.TW.Tezos.Proto.DelegationOperationData.encode(message.delegationOperationData, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an Operation message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.Operation} Operation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Operation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.Operation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.counter = reader.int64();
                                break;
                            case 2:
                                message.source = reader.string();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.gasLimit = reader.int64();
                                break;
                            case 5:
                                message.storageLimit = reader.int64();
                                break;
                            case 7:
                                message.kind = reader.int32();
                                break;
                            case 8:
                                message.revealOperationData = $root.TW.Tezos.Proto.RevealOperationData.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.transactionOperationData = $root.TW.Tezos.Proto.TransactionOperationData.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.delegationOperationData = $root.TW.Tezos.Proto.DelegationOperationData.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Operation message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Operation.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.counter != null && message.hasOwnProperty("counter"))
                            if (!$util.isInteger(message.counter) && !(message.counter && $util.isInteger(message.counter.low) && $util.isInteger(message.counter.high)))
                                return "counter: integer|Long expected";
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (!$util.isString(message.source))
                                return "source: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                            if (!$util.isInteger(message.storageLimit) && !(message.storageLimit && $util.isInteger(message.storageLimit.low) && $util.isInteger(message.storageLimit.high)))
                                return "storageLimit: integer|Long expected";
                        if (message.kind != null && message.hasOwnProperty("kind"))
                            switch (message.kind) {
                            default:
                                return "kind: enum value expected";
                            case 0:
                            case 107:
                            case 108:
                            case 110:
                                break;
                            }
                        if (message.revealOperationData != null && message.hasOwnProperty("revealOperationData")) {
                            properties.operationData = 1;
                            {
                                var error = $root.TW.Tezos.Proto.RevealOperationData.verify(message.revealOperationData);
                                if (error)
                                    return "revealOperationData." + error;
                            }
                        }
                        if (message.transactionOperationData != null && message.hasOwnProperty("transactionOperationData")) {
                            if (properties.operationData === 1)
                                return "operationData: multiple values";
                            properties.operationData = 1;
                            {
                                var error = $root.TW.Tezos.Proto.TransactionOperationData.verify(message.transactionOperationData);
                                if (error)
                                    return "transactionOperationData." + error;
                            }
                        }
                        if (message.delegationOperationData != null && message.hasOwnProperty("delegationOperationData")) {
                            if (properties.operationData === 1)
                                return "operationData: multiple values";
                            properties.operationData = 1;
                            {
                                var error = $root.TW.Tezos.Proto.DelegationOperationData.verify(message.delegationOperationData);
                                if (error)
                                    return "delegationOperationData." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an Operation message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.Operation} Operation
                     */
                    Operation.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.Operation)
                            return object;
                        var message = new $root.TW.Tezos.Proto.Operation();
                        if (object.counter != null)
                            if ($util.Long)
                                (message.counter = $util.Long.fromValue(object.counter)).unsigned = false;
                            else if (typeof object.counter === "string")
                                message.counter = parseInt(object.counter, 10);
                            else if (typeof object.counter === "number")
                                message.counter = object.counter;
                            else if (typeof object.counter === "object")
                                message.counter = new $util.LongBits(object.counter.low >>> 0, object.counter.high >>> 0).toNumber();
                        if (object.source != null)
                            message.source = String(object.source);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = false;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber();
                        if (object.storageLimit != null)
                            if ($util.Long)
                                (message.storageLimit = $util.Long.fromValue(object.storageLimit)).unsigned = false;
                            else if (typeof object.storageLimit === "string")
                                message.storageLimit = parseInt(object.storageLimit, 10);
                            else if (typeof object.storageLimit === "number")
                                message.storageLimit = object.storageLimit;
                            else if (typeof object.storageLimit === "object")
                                message.storageLimit = new $util.LongBits(object.storageLimit.low >>> 0, object.storageLimit.high >>> 0).toNumber();
                        switch (object.kind) {
                        case "ENDORSEMENT":
                        case 0:
                            message.kind = 0;
                            break;
                        case "REVEAL":
                        case 107:
                            message.kind = 107;
                            break;
                        case "TRANSACTION":
                        case 108:
                            message.kind = 108;
                            break;
                        case "DELEGATION":
                        case 110:
                            message.kind = 110;
                            break;
                        }
                        if (object.revealOperationData != null) {
                            if (typeof object.revealOperationData !== "object")
                                throw TypeError(".TW.Tezos.Proto.Operation.revealOperationData: object expected");
                            message.revealOperationData = $root.TW.Tezos.Proto.RevealOperationData.fromObject(object.revealOperationData);
                        }
                        if (object.transactionOperationData != null) {
                            if (typeof object.transactionOperationData !== "object")
                                throw TypeError(".TW.Tezos.Proto.Operation.transactionOperationData: object expected");
                            message.transactionOperationData = $root.TW.Tezos.Proto.TransactionOperationData.fromObject(object.transactionOperationData);
                        }
                        if (object.delegationOperationData != null) {
                            if (typeof object.delegationOperationData !== "object")
                                throw TypeError(".TW.Tezos.Proto.Operation.delegationOperationData: object expected");
                            message.delegationOperationData = $root.TW.Tezos.Proto.DelegationOperationData.fromObject(object.delegationOperationData);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Operation message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {TW.Tezos.Proto.Operation} message Operation
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Operation.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.counter = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.counter = options.longs === String ? "0" : 0;
                            object.source = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.storageLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.storageLimit = options.longs === String ? "0" : 0;
                            object.kind = options.enums === String ? "ENDORSEMENT" : 0;
                        }
                        if (message.counter != null && message.hasOwnProperty("counter"))
                            if (typeof message.counter === "number")
                                object.counter = options.longs === String ? String(message.counter) : message.counter;
                            else
                                object.counter = options.longs === String ? $util.Long.prototype.toString.call(message.counter) : options.longs === Number ? new $util.LongBits(message.counter.low >>> 0, message.counter.high >>> 0).toNumber() : message.counter;
                        if (message.source != null && message.hasOwnProperty("source"))
                            object.source = message.source;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber() : message.gasLimit;
                        if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                            if (typeof message.storageLimit === "number")
                                object.storageLimit = options.longs === String ? String(message.storageLimit) : message.storageLimit;
                            else
                                object.storageLimit = options.longs === String ? $util.Long.prototype.toString.call(message.storageLimit) : options.longs === Number ? new $util.LongBits(message.storageLimit.low >>> 0, message.storageLimit.high >>> 0).toNumber() : message.storageLimit;
                        if (message.kind != null && message.hasOwnProperty("kind"))
                            object.kind = options.enums === String ? $root.TW.Tezos.Proto.Operation.OperationKind[message.kind] : message.kind;
                        if (message.revealOperationData != null && message.hasOwnProperty("revealOperationData")) {
                            object.revealOperationData = $root.TW.Tezos.Proto.RevealOperationData.toObject(message.revealOperationData, options);
                            if (options.oneofs)
                                object.operationData = "revealOperationData";
                        }
                        if (message.transactionOperationData != null && message.hasOwnProperty("transactionOperationData")) {
                            object.transactionOperationData = $root.TW.Tezos.Proto.TransactionOperationData.toObject(message.transactionOperationData, options);
                            if (options.oneofs)
                                object.operationData = "transactionOperationData";
                        }
                        if (message.delegationOperationData != null && message.hasOwnProperty("delegationOperationData")) {
                            object.delegationOperationData = $root.TW.Tezos.Proto.DelegationOperationData.toObject(message.delegationOperationData, options);
                            if (options.oneofs)
                                object.operationData = "delegationOperationData";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Operation to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Operation.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * OperationKind enum.
                     * @name TW.Tezos.Proto.Operation.OperationKind
                     * @enum {number}
                     * @property {number} ENDORSEMENT=0 ENDORSEMENT value
                     * @property {number} REVEAL=107 REVEAL value
                     * @property {number} TRANSACTION=108 TRANSACTION value
                     * @property {number} DELEGATION=110 DELEGATION value
                     */
                    Operation.OperationKind = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "ENDORSEMENT"] = 0;
                        values[valuesById[107] = "REVEAL"] = 107;
                        values[valuesById[108] = "TRANSACTION"] = 108;
                        values[valuesById[110] = "DELEGATION"] = 110;
                        return values;
                    })();
    
                    return Operation;
                })();
    
                Proto.TransactionOperationData = (function() {
    
                    /**
                     * Properties of a TransactionOperationData.
                     * @memberof TW.Tezos.Proto
                     * @interface ITransactionOperationData
                     * @property {string|null} [destination] TransactionOperationData destination
                     * @property {Long|null} [amount] TransactionOperationData amount
                     */
    
                    /**
                     * Constructs a new TransactionOperationData.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a TransactionOperationData.
                     * @implements ITransactionOperationData
                     * @constructor
                     * @param {TW.Tezos.Proto.ITransactionOperationData=} [properties] Properties to set
                     */
                    function TransactionOperationData(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOperationData destination.
                     * @member {string} destination
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @instance
                     */
                    TransactionOperationData.prototype.destination = "";
    
                    /**
                     * TransactionOperationData amount.
                     * @member {Long} amount
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @instance
                     */
                    TransactionOperationData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TransactionOperationData instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {TW.Tezos.Proto.ITransactionOperationData=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.TransactionOperationData} TransactionOperationData instance
                     */
                    TransactionOperationData.create = function create(properties) {
                        return new TransactionOperationData(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOperationData message. Does not implicitly {@link TW.Tezos.Proto.TransactionOperationData.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {TW.Tezos.Proto.ITransactionOperationData} message TransactionOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOperationData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransactionOperationData message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.TransactionOperationData} TransactionOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOperationData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.TransactionOperationData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.destination = reader.string();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransactionOperationData message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOperationData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOperationData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.TransactionOperationData} TransactionOperationData
                     */
                    TransactionOperationData.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.TransactionOperationData)
                            return object;
                        var message = new $root.TW.Tezos.Proto.TransactionOperationData();
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOperationData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {TW.Tezos.Proto.TransactionOperationData} message TransactionOperationData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOperationData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOperationData to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOperationData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOperationData;
                })();
    
                Proto.RevealOperationData = (function() {
    
                    /**
                     * Properties of a RevealOperationData.
                     * @memberof TW.Tezos.Proto
                     * @interface IRevealOperationData
                     * @property {Uint8Array|null} [publicKey] RevealOperationData publicKey
                     */
    
                    /**
                     * Constructs a new RevealOperationData.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a RevealOperationData.
                     * @implements IRevealOperationData
                     * @constructor
                     * @param {TW.Tezos.Proto.IRevealOperationData=} [properties] Properties to set
                     */
                    function RevealOperationData(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RevealOperationData publicKey.
                     * @member {Uint8Array} publicKey
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @instance
                     */
                    RevealOperationData.prototype.publicKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new RevealOperationData instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IRevealOperationData=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.RevealOperationData} RevealOperationData instance
                     */
                    RevealOperationData.create = function create(properties) {
                        return new RevealOperationData(properties);
                    };
    
                    /**
                     * Encodes the specified RevealOperationData message. Does not implicitly {@link TW.Tezos.Proto.RevealOperationData.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IRevealOperationData} message RevealOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RevealOperationData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a RevealOperationData message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.RevealOperationData} RevealOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RevealOperationData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.RevealOperationData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.publicKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a RevealOperationData message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RevealOperationData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                                return "publicKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a RevealOperationData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.RevealOperationData} RevealOperationData
                     */
                    RevealOperationData.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.RevealOperationData)
                            return object;
                        var message = new $root.TW.Tezos.Proto.RevealOperationData();
                        if (object.publicKey != null)
                            if (typeof object.publicKey === "string")
                                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                            else if (object.publicKey.length)
                                message.publicKey = object.publicKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a RevealOperationData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {TW.Tezos.Proto.RevealOperationData} message RevealOperationData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RevealOperationData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.publicKey = "";
                            else {
                                object.publicKey = [];
                                if (options.bytes !== Array)
                                    object.publicKey = $util.newBuffer(object.publicKey);
                            }
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                        return object;
                    };
    
                    /**
                     * Converts this RevealOperationData to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RevealOperationData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return RevealOperationData;
                })();
    
                Proto.DelegationOperationData = (function() {
    
                    /**
                     * Properties of a DelegationOperationData.
                     * @memberof TW.Tezos.Proto
                     * @interface IDelegationOperationData
                     * @property {string|null} [delegate] DelegationOperationData delegate
                     */
    
                    /**
                     * Constructs a new DelegationOperationData.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a DelegationOperationData.
                     * @implements IDelegationOperationData
                     * @constructor
                     * @param {TW.Tezos.Proto.IDelegationOperationData=} [properties] Properties to set
                     */
                    function DelegationOperationData(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DelegationOperationData delegate.
                     * @member {string} delegate
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @instance
                     */
                    DelegationOperationData.prototype.delegate = "";
    
                    /**
                     * Creates a new DelegationOperationData instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IDelegationOperationData=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.DelegationOperationData} DelegationOperationData instance
                     */
                    DelegationOperationData.create = function create(properties) {
                        return new DelegationOperationData(properties);
                    };
    
                    /**
                     * Encodes the specified DelegationOperationData message. Does not implicitly {@link TW.Tezos.Proto.DelegationOperationData.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IDelegationOperationData} message DelegationOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DelegationOperationData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegate != null && Object.hasOwnProperty.call(message, "delegate"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegate);
                        return writer;
                    };
    
                    /**
                     * Decodes a DelegationOperationData message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.DelegationOperationData} DelegationOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DelegationOperationData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.DelegationOperationData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegate = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a DelegationOperationData message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DelegationOperationData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegate != null && message.hasOwnProperty("delegate"))
                            if (!$util.isString(message.delegate))
                                return "delegate: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DelegationOperationData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.DelegationOperationData} DelegationOperationData
                     */
                    DelegationOperationData.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.DelegationOperationData)
                            return object;
                        var message = new $root.TW.Tezos.Proto.DelegationOperationData();
                        if (object.delegate != null)
                            message.delegate = String(object.delegate);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DelegationOperationData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.DelegationOperationData} message DelegationOperationData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DelegationOperationData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.delegate = "";
                        if (message.delegate != null && message.hasOwnProperty("delegate"))
                            object.delegate = message.delegate;
                        return object;
                    };
    
                    /**
                     * Converts this DelegationOperationData to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DelegationOperationData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DelegationOperationData;
                })();
    
                return Proto;
            })();
    
            return Tezos;
        })();
    
        TW.Theta = (function() {
    
            /**
             * Namespace Theta.
             * @memberof TW
             * @namespace
             */
            var Theta = {};
    
            Theta.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Theta
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Theta.Proto
                     * @interface ISigningInput
                     * @property {string|null} [chainId] Chain ID string, mainnet, testnet and privatenet
                     * @property {string|null} [toAddress] Recipient address
                     * @property {Uint8Array|null} [thetaAmount] Theta token amount to send in wei (256-bit number)
                     * @property {Uint8Array|null} [tfuelAmount] TFuel token amount to send in wei (256-bit number)
                     * @property {Long|null} [sequence] Sequence number of the transaction for the sender address
                     * @property {Uint8Array|null} [fee] Fee amount in TFuel wei for the transaction (256-bit number)
                     * @property {Uint8Array|null} [privateKey] Private key
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Theta.Proto
                     * @classdesc Input data necessary to create a signed transaction
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Theta.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Chain ID string, mainnet, testnet and privatenet
                     * @member {string} chainId
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * Recipient address
                     * @member {string} toAddress
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * Theta token amount to send in wei (256-bit number)
                     * @member {Uint8Array} thetaAmount
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.thetaAmount = $util.newBuffer([]);
    
                    /**
                     * TFuel token amount to send in wei (256-bit number)
                     * @member {Uint8Array} tfuelAmount
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.tfuelAmount = $util.newBuffer([]);
    
                    /**
                     * Sequence number of the transaction for the sender address
                     * @member {Long} sequence
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Fee amount in TFuel wei for the transaction (256-bit number)
                     * @member {Uint8Array} fee
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.newBuffer([]);
    
                    /**
                     * Private key
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {TW.Theta.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Theta.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Theta.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {TW.Theta.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.chainId);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.thetaAmount != null && Object.hasOwnProperty.call(message, "thetaAmount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.thetaAmount);
                        if (message.tfuelAmount != null && Object.hasOwnProperty.call(message, "tfuelAmount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tfuelAmount);
                        if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.sequence);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.fee);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Theta.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Theta.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.thetaAmount = reader.bytes();
                                break;
                            case 4:
                                message.tfuelAmount = reader.bytes();
                                break;
                            case 5:
                                message.sequence = reader.uint64();
                                break;
                            case 6:
                                message.fee = reader.bytes();
                                break;
                            case 7:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.thetaAmount != null && message.hasOwnProperty("thetaAmount"))
                            if (!(message.thetaAmount && typeof message.thetaAmount.length === "number" || $util.isString(message.thetaAmount)))
                                return "thetaAmount: buffer expected";
                        if (message.tfuelAmount != null && message.hasOwnProperty("tfuelAmount"))
                            if (!(message.tfuelAmount && typeof message.tfuelAmount.length === "number" || $util.isString(message.tfuelAmount)))
                                return "tfuelAmount: buffer expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!(message.fee && typeof message.fee.length === "number" || $util.isString(message.fee)))
                                return "fee: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Theta.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Theta.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Theta.Proto.SigningInput();
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.thetaAmount != null)
                            if (typeof object.thetaAmount === "string")
                                $util.base64.decode(object.thetaAmount, message.thetaAmount = $util.newBuffer($util.base64.length(object.thetaAmount)), 0);
                            else if (object.thetaAmount.length)
                                message.thetaAmount = object.thetaAmount;
                        if (object.tfuelAmount != null)
                            if (typeof object.tfuelAmount === "string")
                                $util.base64.decode(object.tfuelAmount, message.tfuelAmount = $util.newBuffer($util.base64.length(object.tfuelAmount)), 0);
                            else if (object.tfuelAmount.length)
                                message.tfuelAmount = object.tfuelAmount;
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if (typeof object.fee === "string")
                                $util.base64.decode(object.fee, message.fee = $util.newBuffer($util.base64.length(object.fee)), 0);
                            else if (object.fee.length)
                                message.fee = object.fee;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {TW.Theta.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.chainId = "";
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.thetaAmount = "";
                            else {
                                object.thetaAmount = [];
                                if (options.bytes !== Array)
                                    object.thetaAmount = $util.newBuffer(object.thetaAmount);
                            }
                            if (options.bytes === String)
                                object.tfuelAmount = "";
                            else {
                                object.tfuelAmount = [];
                                if (options.bytes !== Array)
                                    object.tfuelAmount = $util.newBuffer(object.tfuelAmount);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.fee = "";
                            else {
                                object.fee = [];
                                if (options.bytes !== Array)
                                    object.fee = $util.newBuffer(object.fee);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.thetaAmount != null && message.hasOwnProperty("thetaAmount"))
                            object.thetaAmount = options.bytes === String ? $util.base64.encode(message.thetaAmount, 0, message.thetaAmount.length) : options.bytes === Array ? Array.prototype.slice.call(message.thetaAmount) : message.thetaAmount;
                        if (message.tfuelAmount != null && message.hasOwnProperty("tfuelAmount"))
                            object.tfuelAmount = options.bytes === String ? $util.base64.encode(message.tfuelAmount, 0, message.tfuelAmount.length) : options.bytes === Array ? Array.prototype.slice.call(message.tfuelAmount) : message.tfuelAmount;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = options.bytes === String ? $util.base64.encode(message.fee, 0, message.fee.length) : options.bytes === Array ? Array.prototype.slice.call(message.fee) : message.fee;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Theta.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] Signed and encoded transaction bytes
                     * @property {Uint8Array|null} [signature] Signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Theta.Proto
                     * @classdesc Transaction signing output
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Theta.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signed and encoded transaction bytes
                     * @member {Uint8Array} encoded
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Signature
                     * @member {Uint8Array} signature
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {TW.Theta.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Theta.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Theta.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {TW.Theta.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Theta.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Theta.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Theta.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Theta.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Theta.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {TW.Theta.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Theta;
        })();
    
        TW.THORChainSwap = (function() {
    
            /**
             * Namespace THORChainSwap.
             * @memberof TW
             * @namespace
             */
            var THORChainSwap = {};
    
            THORChainSwap.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.THORChainSwap
                 * @namespace
                 */
                var Proto = {};
    
                /**
                 * Chain enum.
                 * @name TW.THORChainSwap.Proto.Chain
                 * @enum {number}
                 * @property {number} THOR=0 THOR value
                 * @property {number} BTC=1 BTC value
                 * @property {number} ETH=2 ETH value
                 * @property {number} BNB=3 BNB value
                 */
                Proto.Chain = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "THOR"] = 0;
                    values[valuesById[1] = "BTC"] = 1;
                    values[valuesById[2] = "ETH"] = 2;
                    values[valuesById[3] = "BNB"] = 3;
                    return values;
                })();
    
                /**
                 * ErrorCode enum.
                 * @name TW.THORChainSwap.Proto.ErrorCode
                 * @enum {number}
                 * @property {number} OK=0 OK value
                 * @property {number} Error_general=1 Error_general value
                 * @property {number} Error_Input_proto_deserialization=2 Error_Input_proto_deserialization value
                 * @property {number} Error_Unsupported_from_chain=13 Error_Unsupported_from_chain value
                 * @property {number} Error_Unsupported_to_chain=14 Error_Unsupported_to_chain value
                 * @property {number} Error_Invalid_from_address=15 Error_Invalid_from_address value
                 * @property {number} Error_Invalid_to_address=16 Error_Invalid_to_address value
                 * @property {number} Error_Invalid_vault_address=21 Error_Invalid_vault_address value
                 * @property {number} Error_Invalid_router_address=22 Error_Invalid_router_address value
                 */
                Proto.ErrorCode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "OK"] = 0;
                    values[valuesById[1] = "Error_general"] = 1;
                    values[valuesById[2] = "Error_Input_proto_deserialization"] = 2;
                    values[valuesById[13] = "Error_Unsupported_from_chain"] = 13;
                    values[valuesById[14] = "Error_Unsupported_to_chain"] = 14;
                    values[valuesById[15] = "Error_Invalid_from_address"] = 15;
                    values[valuesById[16] = "Error_Invalid_to_address"] = 16;
                    values[valuesById[21] = "Error_Invalid_vault_address"] = 21;
                    values[valuesById[22] = "Error_Invalid_router_address"] = 22;
                    return values;
                })();
    
                Proto.Error = (function() {
    
                    /**
                     * Properties of an Error.
                     * @memberof TW.THORChainSwap.Proto
                     * @interface IError
                     * @property {TW.THORChainSwap.Proto.ErrorCode|null} [code] Error code
                     * @property {string|null} [message] Error message
                     */
    
                    /**
                     * Constructs a new Error.
                     * @memberof TW.THORChainSwap.Proto
                     * @classdesc Represents an Error.
                     * @implements IError
                     * @constructor
                     * @param {TW.THORChainSwap.Proto.IError=} [properties] Properties to set
                     */
                    function Error(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Error code.
                     * @member {TW.THORChainSwap.Proto.ErrorCode} code
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @instance
                     */
                    Error.prototype.code = 0;
    
                    /**
                     * Error message.
                     * @member {string} message
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @instance
                     */
                    Error.prototype.message = "";
    
                    /**
                     * Creates a new Error instance using the specified properties.
                     * @function create
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @static
                     * @param {TW.THORChainSwap.Proto.IError=} [properties] Properties to set
                     * @returns {TW.THORChainSwap.Proto.Error} Error instance
                     */
                    Error.create = function create(properties) {
                        return new Error(properties);
                    };
    
                    /**
                     * Encodes the specified Error message. Does not implicitly {@link TW.THORChainSwap.Proto.Error.verify|verify} messages.
                     * @function encode
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @static
                     * @param {TW.THORChainSwap.Proto.IError} message Error message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Error.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                        return writer;
                    };
    
                    /**
                     * Decodes an Error message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.THORChainSwap.Proto.Error} Error
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Error.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.THORChainSwap.Proto.Error();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.code = reader.int32();
                                break;
                            case 2:
                                message.message = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Error message.
                     * @function verify
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Error.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.code != null && message.hasOwnProperty("code"))
                            switch (message.code) {
                            default:
                                return "code: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 13:
                            case 14:
                            case 15:
                            case 16:
                            case 21:
                            case 22:
                                break;
                            }
                        if (message.message != null && message.hasOwnProperty("message"))
                            if (!$util.isString(message.message))
                                return "message: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Error message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.THORChainSwap.Proto.Error} Error
                     */
                    Error.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.THORChainSwap.Proto.Error)
                            return object;
                        var message = new $root.TW.THORChainSwap.Proto.Error();
                        switch (object.code) {
                        case "OK":
                        case 0:
                            message.code = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.code = 1;
                            break;
                        case "Error_Input_proto_deserialization":
                        case 2:
                            message.code = 2;
                            break;
                        case "Error_Unsupported_from_chain":
                        case 13:
                            message.code = 13;
                            break;
                        case "Error_Unsupported_to_chain":
                        case 14:
                            message.code = 14;
                            break;
                        case "Error_Invalid_from_address":
                        case 15:
                            message.code = 15;
                            break;
                        case "Error_Invalid_to_address":
                        case 16:
                            message.code = 16;
                            break;
                        case "Error_Invalid_vault_address":
                        case 21:
                            message.code = 21;
                            break;
                        case "Error_Invalid_router_address":
                        case 22:
                            message.code = 22;
                            break;
                        }
                        if (object.message != null)
                            message.message = String(object.message);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Error message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @static
                     * @param {TW.THORChainSwap.Proto.Error} message Error
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Error.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.code = options.enums === String ? "OK" : 0;
                            object.message = "";
                        }
                        if (message.code != null && message.hasOwnProperty("code"))
                            object.code = options.enums === String ? $root.TW.THORChainSwap.Proto.ErrorCode[message.code] : message.code;
                        if (message.message != null && message.hasOwnProperty("message"))
                            object.message = message.message;
                        return object;
                    };
    
                    /**
                     * Converts this Error to JSON.
                     * @function toJSON
                     * @memberof TW.THORChainSwap.Proto.Error
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Error.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Error;
                })();
    
                Proto.Asset = (function() {
    
                    /**
                     * Properties of an Asset.
                     * @memberof TW.THORChainSwap.Proto
                     * @interface IAsset
                     * @property {TW.THORChainSwap.Proto.Chain|null} [chain] Asset chain
                     * @property {string|null} [symbol] Asset symbol
                     * @property {string|null} [tokenId] Asset tokenId
                     */
    
                    /**
                     * Constructs a new Asset.
                     * @memberof TW.THORChainSwap.Proto
                     * @classdesc Represents an Asset.
                     * @implements IAsset
                     * @constructor
                     * @param {TW.THORChainSwap.Proto.IAsset=} [properties] Properties to set
                     */
                    function Asset(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Asset chain.
                     * @member {TW.THORChainSwap.Proto.Chain} chain
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.chain = 0;
    
                    /**
                     * Asset symbol.
                     * @member {string} symbol
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.symbol = "";
    
                    /**
                     * Asset tokenId.
                     * @member {string} tokenId
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.tokenId = "";
    
                    /**
                     * Creates a new Asset instance using the specified properties.
                     * @function create
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @static
                     * @param {TW.THORChainSwap.Proto.IAsset=} [properties] Properties to set
                     * @returns {TW.THORChainSwap.Proto.Asset} Asset instance
                     */
                    Asset.create = function create(properties) {
                        return new Asset(properties);
                    };
    
                    /**
                     * Encodes the specified Asset message. Does not implicitly {@link TW.THORChainSwap.Proto.Asset.verify|verify} messages.
                     * @function encode
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @static
                     * @param {TW.THORChainSwap.Proto.IAsset} message Asset message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Asset.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chain != null && Object.hasOwnProperty.call(message, "chain"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.chain);
                        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tokenId);
                        return writer;
                    };
    
                    /**
                     * Decodes an Asset message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.THORChainSwap.Proto.Asset} Asset
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Asset.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.THORChainSwap.Proto.Asset();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chain = reader.int32();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.tokenId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an Asset message.
                     * @function verify
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Asset.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chain != null && message.hasOwnProperty("chain"))
                            switch (message.chain) {
                            default:
                                return "chain: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                            if (!$util.isString(message.tokenId))
                                return "tokenId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.THORChainSwap.Proto.Asset} Asset
                     */
                    Asset.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.THORChainSwap.Proto.Asset)
                            return object;
                        var message = new $root.TW.THORChainSwap.Proto.Asset();
                        switch (object.chain) {
                        case "THOR":
                        case 0:
                            message.chain = 0;
                            break;
                        case "BTC":
                        case 1:
                            message.chain = 1;
                            break;
                        case "ETH":
                        case 2:
                            message.chain = 2;
                            break;
                        case "BNB":
                        case 3:
                            message.chain = 3;
                            break;
                        }
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.tokenId != null)
                            message.tokenId = String(object.tokenId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Asset message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @static
                     * @param {TW.THORChainSwap.Proto.Asset} message Asset
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Asset.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.chain = options.enums === String ? "THOR" : 0;
                            object.symbol = "";
                            object.tokenId = "";
                        }
                        if (message.chain != null && message.hasOwnProperty("chain"))
                            object.chain = options.enums === String ? $root.TW.THORChainSwap.Proto.Chain[message.chain] : message.chain;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                            object.tokenId = message.tokenId;
                        return object;
                    };
    
                    /**
                     * Converts this Asset to JSON.
                     * @function toJSON
                     * @memberof TW.THORChainSwap.Proto.Asset
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Asset.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Asset;
                })();
    
                Proto.SwapInput = (function() {
    
                    /**
                     * Properties of a SwapInput.
                     * @memberof TW.THORChainSwap.Proto
                     * @interface ISwapInput
                     * @property {TW.THORChainSwap.Proto.Chain|null} [fromChain] SwapInput fromChain
                     * @property {string|null} [fromAddress] SwapInput fromAddress
                     * @property {TW.THORChainSwap.Proto.IAsset|null} [toAsset] SwapInput toAsset
                     * @property {string|null} [toAddress] SwapInput toAddress
                     * @property {string|null} [vaultAddress] SwapInput vaultAddress
                     * @property {string|null} [routerAddress] SwapInput routerAddress
                     * @property {string|null} [fromAmount] SwapInput fromAmount
                     * @property {string|null} [toAmountLimit] SwapInput toAmountLimit
                     */
    
                    /**
                     * Constructs a new SwapInput.
                     * @memberof TW.THORChainSwap.Proto
                     * @classdesc Represents a SwapInput.
                     * @implements ISwapInput
                     * @constructor
                     * @param {TW.THORChainSwap.Proto.ISwapInput=} [properties] Properties to set
                     */
                    function SwapInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SwapInput fromChain.
                     * @member {TW.THORChainSwap.Proto.Chain} fromChain
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.fromChain = 0;
    
                    /**
                     * SwapInput fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.fromAddress = "";
    
                    /**
                     * SwapInput toAsset.
                     * @member {TW.THORChainSwap.Proto.IAsset|null|undefined} toAsset
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.toAsset = null;
    
                    /**
                     * SwapInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.toAddress = "";
    
                    /**
                     * SwapInput vaultAddress.
                     * @member {string} vaultAddress
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.vaultAddress = "";
    
                    /**
                     * SwapInput routerAddress.
                     * @member {string} routerAddress
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.routerAddress = "";
    
                    /**
                     * SwapInput fromAmount.
                     * @member {string} fromAmount
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.fromAmount = "";
    
                    /**
                     * SwapInput toAmountLimit.
                     * @member {string} toAmountLimit
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     */
                    SwapInput.prototype.toAmountLimit = "";
    
                    /**
                     * Creates a new SwapInput instance using the specified properties.
                     * @function create
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @static
                     * @param {TW.THORChainSwap.Proto.ISwapInput=} [properties] Properties to set
                     * @returns {TW.THORChainSwap.Proto.SwapInput} SwapInput instance
                     */
                    SwapInput.create = function create(properties) {
                        return new SwapInput(properties);
                    };
    
                    /**
                     * Encodes the specified SwapInput message. Does not implicitly {@link TW.THORChainSwap.Proto.SwapInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @static
                     * @param {TW.THORChainSwap.Proto.ISwapInput} message SwapInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SwapInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromChain != null && Object.hasOwnProperty.call(message, "fromChain"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fromChain);
                        if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.fromAddress);
                        if (message.toAsset != null && Object.hasOwnProperty.call(message, "toAsset"))
                            $root.TW.THORChainSwap.Proto.Asset.encode(message.toAsset, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.vaultAddress != null && Object.hasOwnProperty.call(message, "vaultAddress"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.vaultAddress);
                        if (message.routerAddress != null && Object.hasOwnProperty.call(message, "routerAddress"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.routerAddress);
                        if (message.fromAmount != null && Object.hasOwnProperty.call(message, "fromAmount"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.fromAmount);
                        if (message.toAmountLimit != null && Object.hasOwnProperty.call(message, "toAmountLimit"))
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.toAmountLimit);
                        return writer;
                    };
    
                    /**
                     * Decodes a SwapInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.THORChainSwap.Proto.SwapInput} SwapInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SwapInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.THORChainSwap.Proto.SwapInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromChain = reader.int32();
                                break;
                            case 2:
                                message.fromAddress = reader.string();
                                break;
                            case 3:
                                message.toAsset = $root.TW.THORChainSwap.Proto.Asset.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.vaultAddress = reader.string();
                                break;
                            case 6:
                                message.routerAddress = reader.string();
                                break;
                            case 7:
                                message.fromAmount = reader.string();
                                break;
                            case 8:
                                message.toAmountLimit = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SwapInput message.
                     * @function verify
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SwapInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromChain != null && message.hasOwnProperty("fromChain"))
                            switch (message.fromChain) {
                            default:
                                return "fromChain: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAsset != null && message.hasOwnProperty("toAsset")) {
                            var error = $root.TW.THORChainSwap.Proto.Asset.verify(message.toAsset);
                            if (error)
                                return "toAsset." + error;
                        }
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.vaultAddress != null && message.hasOwnProperty("vaultAddress"))
                            if (!$util.isString(message.vaultAddress))
                                return "vaultAddress: string expected";
                        if (message.routerAddress != null && message.hasOwnProperty("routerAddress"))
                            if (!$util.isString(message.routerAddress))
                                return "routerAddress: string expected";
                        if (message.fromAmount != null && message.hasOwnProperty("fromAmount"))
                            if (!$util.isString(message.fromAmount))
                                return "fromAmount: string expected";
                        if (message.toAmountLimit != null && message.hasOwnProperty("toAmountLimit"))
                            if (!$util.isString(message.toAmountLimit))
                                return "toAmountLimit: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SwapInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.THORChainSwap.Proto.SwapInput} SwapInput
                     */
                    SwapInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.THORChainSwap.Proto.SwapInput)
                            return object;
                        var message = new $root.TW.THORChainSwap.Proto.SwapInput();
                        switch (object.fromChain) {
                        case "THOR":
                        case 0:
                            message.fromChain = 0;
                            break;
                        case "BTC":
                        case 1:
                            message.fromChain = 1;
                            break;
                        case "ETH":
                        case 2:
                            message.fromChain = 2;
                            break;
                        case "BNB":
                        case 3:
                            message.fromChain = 3;
                            break;
                        }
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAsset != null) {
                            if (typeof object.toAsset !== "object")
                                throw TypeError(".TW.THORChainSwap.Proto.SwapInput.toAsset: object expected");
                            message.toAsset = $root.TW.THORChainSwap.Proto.Asset.fromObject(object.toAsset);
                        }
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.vaultAddress != null)
                            message.vaultAddress = String(object.vaultAddress);
                        if (object.routerAddress != null)
                            message.routerAddress = String(object.routerAddress);
                        if (object.fromAmount != null)
                            message.fromAmount = String(object.fromAmount);
                        if (object.toAmountLimit != null)
                            message.toAmountLimit = String(object.toAmountLimit);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SwapInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @static
                     * @param {TW.THORChainSwap.Proto.SwapInput} message SwapInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SwapInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromChain = options.enums === String ? "THOR" : 0;
                            object.fromAddress = "";
                            object.toAsset = null;
                            object.toAddress = "";
                            object.vaultAddress = "";
                            object.routerAddress = "";
                            object.fromAmount = "";
                            object.toAmountLimit = "";
                        }
                        if (message.fromChain != null && message.hasOwnProperty("fromChain"))
                            object.fromChain = options.enums === String ? $root.TW.THORChainSwap.Proto.Chain[message.fromChain] : message.fromChain;
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAsset != null && message.hasOwnProperty("toAsset"))
                            object.toAsset = $root.TW.THORChainSwap.Proto.Asset.toObject(message.toAsset, options);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.vaultAddress != null && message.hasOwnProperty("vaultAddress"))
                            object.vaultAddress = message.vaultAddress;
                        if (message.routerAddress != null && message.hasOwnProperty("routerAddress"))
                            object.routerAddress = message.routerAddress;
                        if (message.fromAmount != null && message.hasOwnProperty("fromAmount"))
                            object.fromAmount = message.fromAmount;
                        if (message.toAmountLimit != null && message.hasOwnProperty("toAmountLimit"))
                            object.toAmountLimit = message.toAmountLimit;
                        return object;
                    };
    
                    /**
                     * Converts this SwapInput to JSON.
                     * @function toJSON
                     * @memberof TW.THORChainSwap.Proto.SwapInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SwapInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SwapInput;
                })();
    
                Proto.SwapOutput = (function() {
    
                    /**
                     * Properties of a SwapOutput.
                     * @memberof TW.THORChainSwap.Proto
                     * @interface ISwapOutput
                     * @property {TW.THORChainSwap.Proto.Chain|null} [fromChain] SwapOutput fromChain
                     * @property {TW.THORChainSwap.Proto.Chain|null} [toChain] SwapOutput toChain
                     * @property {TW.THORChainSwap.Proto.IError|null} [error] SwapOutput error
                     * @property {TW.Bitcoin.Proto.ISigningInput|null} [bitcoin] SwapOutput bitcoin
                     * @property {TW.Ethereum.Proto.ISigningInput|null} [ethereum] SwapOutput ethereum
                     * @property {TW.Binance.Proto.ISigningInput|null} [binance] SwapOutput binance
                     */
    
                    /**
                     * Constructs a new SwapOutput.
                     * @memberof TW.THORChainSwap.Proto
                     * @classdesc Represents a SwapOutput.
                     * @implements ISwapOutput
                     * @constructor
                     * @param {TW.THORChainSwap.Proto.ISwapOutput=} [properties] Properties to set
                     */
                    function SwapOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SwapOutput fromChain.
                     * @member {TW.THORChainSwap.Proto.Chain} fromChain
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     */
                    SwapOutput.prototype.fromChain = 0;
    
                    /**
                     * SwapOutput toChain.
                     * @member {TW.THORChainSwap.Proto.Chain} toChain
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     */
                    SwapOutput.prototype.toChain = 0;
    
                    /**
                     * SwapOutput error.
                     * @member {TW.THORChainSwap.Proto.IError|null|undefined} error
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     */
                    SwapOutput.prototype.error = null;
    
                    /**
                     * SwapOutput bitcoin.
                     * @member {TW.Bitcoin.Proto.ISigningInput|null|undefined} bitcoin
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     */
                    SwapOutput.prototype.bitcoin = null;
    
                    /**
                     * SwapOutput ethereum.
                     * @member {TW.Ethereum.Proto.ISigningInput|null|undefined} ethereum
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     */
                    SwapOutput.prototype.ethereum = null;
    
                    /**
                     * SwapOutput binance.
                     * @member {TW.Binance.Proto.ISigningInput|null|undefined} binance
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     */
                    SwapOutput.prototype.binance = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SwapOutput signingInputOneof.
                     * @member {"bitcoin"|"ethereum"|"binance"|undefined} signingInputOneof
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     */
                    Object.defineProperty(SwapOutput.prototype, "signingInputOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["bitcoin", "ethereum", "binance"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SwapOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @static
                     * @param {TW.THORChainSwap.Proto.ISwapOutput=} [properties] Properties to set
                     * @returns {TW.THORChainSwap.Proto.SwapOutput} SwapOutput instance
                     */
                    SwapOutput.create = function create(properties) {
                        return new SwapOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SwapOutput message. Does not implicitly {@link TW.THORChainSwap.Proto.SwapOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @static
                     * @param {TW.THORChainSwap.Proto.ISwapOutput} message SwapOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SwapOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromChain != null && Object.hasOwnProperty.call(message, "fromChain"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fromChain);
                        if (message.toChain != null && Object.hasOwnProperty.call(message, "toChain"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.toChain);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            $root.TW.THORChainSwap.Proto.Error.encode(message.error, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.bitcoin != null && Object.hasOwnProperty.call(message, "bitcoin"))
                            $root.TW.Bitcoin.Proto.SigningInput.encode(message.bitcoin, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.ethereum != null && Object.hasOwnProperty.call(message, "ethereum"))
                            $root.TW.Ethereum.Proto.SigningInput.encode(message.ethereum, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.binance != null && Object.hasOwnProperty.call(message, "binance"))
                            $root.TW.Binance.Proto.SigningInput.encode(message.binance, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SwapOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.THORChainSwap.Proto.SwapOutput} SwapOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SwapOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.THORChainSwap.Proto.SwapOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromChain = reader.int32();
                                break;
                            case 2:
                                message.toChain = reader.int32();
                                break;
                            case 3:
                                message.error = $root.TW.THORChainSwap.Proto.Error.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.bitcoin = $root.TW.Bitcoin.Proto.SigningInput.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.ethereum = $root.TW.Ethereum.Proto.SigningInput.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.binance = $root.TW.Binance.Proto.SigningInput.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SwapOutput message.
                     * @function verify
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SwapOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.fromChain != null && message.hasOwnProperty("fromChain"))
                            switch (message.fromChain) {
                            default:
                                return "fromChain: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.toChain != null && message.hasOwnProperty("toChain"))
                            switch (message.toChain) {
                            default:
                                return "toChain: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.TW.THORChainSwap.Proto.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.bitcoin != null && message.hasOwnProperty("bitcoin")) {
                            properties.signingInputOneof = 1;
                            {
                                var error = $root.TW.Bitcoin.Proto.SigningInput.verify(message.bitcoin);
                                if (error)
                                    return "bitcoin." + error;
                            }
                        }
                        if (message.ethereum != null && message.hasOwnProperty("ethereum")) {
                            if (properties.signingInputOneof === 1)
                                return "signingInputOneof: multiple values";
                            properties.signingInputOneof = 1;
                            {
                                var error = $root.TW.Ethereum.Proto.SigningInput.verify(message.ethereum);
                                if (error)
                                    return "ethereum." + error;
                            }
                        }
                        if (message.binance != null && message.hasOwnProperty("binance")) {
                            if (properties.signingInputOneof === 1)
                                return "signingInputOneof: multiple values";
                            properties.signingInputOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.SigningInput.verify(message.binance);
                                if (error)
                                    return "binance." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SwapOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.THORChainSwap.Proto.SwapOutput} SwapOutput
                     */
                    SwapOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.THORChainSwap.Proto.SwapOutput)
                            return object;
                        var message = new $root.TW.THORChainSwap.Proto.SwapOutput();
                        switch (object.fromChain) {
                        case "THOR":
                        case 0:
                            message.fromChain = 0;
                            break;
                        case "BTC":
                        case 1:
                            message.fromChain = 1;
                            break;
                        case "ETH":
                        case 2:
                            message.fromChain = 2;
                            break;
                        case "BNB":
                        case 3:
                            message.fromChain = 3;
                            break;
                        }
                        switch (object.toChain) {
                        case "THOR":
                        case 0:
                            message.toChain = 0;
                            break;
                        case "BTC":
                        case 1:
                            message.toChain = 1;
                            break;
                        case "ETH":
                        case 2:
                            message.toChain = 2;
                            break;
                        case "BNB":
                        case 3:
                            message.toChain = 3;
                            break;
                        }
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".TW.THORChainSwap.Proto.SwapOutput.error: object expected");
                            message.error = $root.TW.THORChainSwap.Proto.Error.fromObject(object.error);
                        }
                        if (object.bitcoin != null) {
                            if (typeof object.bitcoin !== "object")
                                throw TypeError(".TW.THORChainSwap.Proto.SwapOutput.bitcoin: object expected");
                            message.bitcoin = $root.TW.Bitcoin.Proto.SigningInput.fromObject(object.bitcoin);
                        }
                        if (object.ethereum != null) {
                            if (typeof object.ethereum !== "object")
                                throw TypeError(".TW.THORChainSwap.Proto.SwapOutput.ethereum: object expected");
                            message.ethereum = $root.TW.Ethereum.Proto.SigningInput.fromObject(object.ethereum);
                        }
                        if (object.binance != null) {
                            if (typeof object.binance !== "object")
                                throw TypeError(".TW.THORChainSwap.Proto.SwapOutput.binance: object expected");
                            message.binance = $root.TW.Binance.Proto.SigningInput.fromObject(object.binance);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SwapOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @static
                     * @param {TW.THORChainSwap.Proto.SwapOutput} message SwapOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SwapOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromChain = options.enums === String ? "THOR" : 0;
                            object.toChain = options.enums === String ? "THOR" : 0;
                            object.error = null;
                        }
                        if (message.fromChain != null && message.hasOwnProperty("fromChain"))
                            object.fromChain = options.enums === String ? $root.TW.THORChainSwap.Proto.Chain[message.fromChain] : message.fromChain;
                        if (message.toChain != null && message.hasOwnProperty("toChain"))
                            object.toChain = options.enums === String ? $root.TW.THORChainSwap.Proto.Chain[message.toChain] : message.toChain;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.TW.THORChainSwap.Proto.Error.toObject(message.error, options);
                        if (message.bitcoin != null && message.hasOwnProperty("bitcoin")) {
                            object.bitcoin = $root.TW.Bitcoin.Proto.SigningInput.toObject(message.bitcoin, options);
                            if (options.oneofs)
                                object.signingInputOneof = "bitcoin";
                        }
                        if (message.ethereum != null && message.hasOwnProperty("ethereum")) {
                            object.ethereum = $root.TW.Ethereum.Proto.SigningInput.toObject(message.ethereum, options);
                            if (options.oneofs)
                                object.signingInputOneof = "ethereum";
                        }
                        if (message.binance != null && message.hasOwnProperty("binance")) {
                            object.binance = $root.TW.Binance.Proto.SigningInput.toObject(message.binance, options);
                            if (options.oneofs)
                                object.signingInputOneof = "binance";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SwapOutput to JSON.
                     * @function toJSON
                     * @memberof TW.THORChainSwap.Proto.SwapOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SwapOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SwapOutput;
                })();
    
                return Proto;
            })();
    
            return THORChainSwap;
        })();
    
        TW.TxCompiler = (function() {
    
            /**
             * Namespace TxCompiler.
             * @memberof TW
             * @namespace
             */
            var TxCompiler = {};
    
            TxCompiler.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.TxCompiler
                 * @namespace
                 */
                var Proto = {};
    
                Proto.PreSigningOutput = (function() {
    
                    /**
                     * Properties of a PreSigningOutput.
                     * @memberof TW.TxCompiler.Proto
                     * @interface IPreSigningOutput
                     * @property {Uint8Array|null} [dataHash] Pre-image data hash that will be used for signing
                     * @property {Uint8Array|null} [data] Pre-image data
                     * @property {TW.Common.Proto.SigningError|null} [error] error code, 0 is ok, other codes will be treated as errors
                     * @property {string|null} [errorMessage] error code description
                     */
    
                    /**
                     * Constructs a new PreSigningOutput.
                     * @memberof TW.TxCompiler.Proto
                     * @classdesc Transaction pre-signing output
                     * @implements IPreSigningOutput
                     * @constructor
                     * @param {TW.TxCompiler.Proto.IPreSigningOutput=} [properties] Properties to set
                     */
                    function PreSigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Pre-image data hash that will be used for signing
                     * @member {Uint8Array} dataHash
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @instance
                     */
                    PreSigningOutput.prototype.dataHash = $util.newBuffer([]);
    
                    /**
                     * Pre-image data
                     * @member {Uint8Array} data
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @instance
                     */
                    PreSigningOutput.prototype.data = $util.newBuffer([]);
    
                    /**
                     * error code, 0 is ok, other codes will be treated as errors
                     * @member {TW.Common.Proto.SigningError} error
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @instance
                     */
                    PreSigningOutput.prototype.error = 0;
    
                    /**
                     * error code description
                     * @member {string} errorMessage
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @instance
                     */
                    PreSigningOutput.prototype.errorMessage = "";
    
                    /**
                     * Creates a new PreSigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @static
                     * @param {TW.TxCompiler.Proto.IPreSigningOutput=} [properties] Properties to set
                     * @returns {TW.TxCompiler.Proto.PreSigningOutput} PreSigningOutput instance
                     */
                    PreSigningOutput.create = function create(properties) {
                        return new PreSigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified PreSigningOutput message. Does not implicitly {@link TW.TxCompiler.Proto.PreSigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @static
                     * @param {TW.TxCompiler.Proto.IPreSigningOutput} message PreSigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PreSigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.dataHash != null && Object.hasOwnProperty.call(message, "dataHash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.dataHash);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.error);
                        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.errorMessage);
                        return writer;
                    };
    
                    /**
                     * Decodes a PreSigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.TxCompiler.Proto.PreSigningOutput} PreSigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PreSigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.TxCompiler.Proto.PreSigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.dataHash = reader.bytes();
                                break;
                            case 2:
                                message.data = reader.bytes();
                                break;
                            case 3:
                                message.error = reader.int32();
                                break;
                            case 4:
                                message.errorMessage = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a PreSigningOutput message.
                     * @function verify
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PreSigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                            if (!(message.dataHash && typeof message.dataHash.length === "number" || $util.isString(message.dataHash)))
                                return "dataHash: buffer expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        if (message.error != null && message.hasOwnProperty("error"))
                            switch (message.error) {
                            default:
                                return "error: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                                break;
                            }
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            if (!$util.isString(message.errorMessage))
                                return "errorMessage: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a PreSigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.TxCompiler.Proto.PreSigningOutput} PreSigningOutput
                     */
                    PreSigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.TxCompiler.Proto.PreSigningOutput)
                            return object;
                        var message = new $root.TW.TxCompiler.Proto.PreSigningOutput();
                        if (object.dataHash != null)
                            if (typeof object.dataHash === "string")
                                $util.base64.decode(object.dataHash, message.dataHash = $util.newBuffer($util.base64.length(object.dataHash)), 0);
                            else if (object.dataHash.length)
                                message.dataHash = object.dataHash;
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        switch (object.error) {
                        case "OK":
                        case 0:
                            message.error = 0;
                            break;
                        case "Error_general":
                        case 1:
                            message.error = 1;
                            break;
                        case "Error_internal":
                        case 2:
                            message.error = 2;
                            break;
                        case "Error_low_balance":
                        case 3:
                            message.error = 3;
                            break;
                        case "Error_zero_amount_requested":
                        case 4:
                            message.error = 4;
                            break;
                        case "Error_missing_private_key":
                        case 5:
                            message.error = 5;
                            break;
                        case "Error_invalid_private_key":
                        case 15:
                            message.error = 15;
                            break;
                        case "Error_invalid_address":
                        case 16:
                            message.error = 16;
                            break;
                        case "Error_invalid_utxo":
                        case 17:
                            message.error = 17;
                            break;
                        case "Error_invalid_utxo_amount":
                        case 18:
                            message.error = 18;
                            break;
                        case "Error_wrong_fee":
                        case 6:
                            message.error = 6;
                            break;
                        case "Error_signing":
                        case 7:
                            message.error = 7;
                            break;
                        case "Error_tx_too_big":
                        case 8:
                            message.error = 8;
                            break;
                        case "Error_missing_input_utxos":
                        case 9:
                            message.error = 9;
                            break;
                        case "Error_not_enough_utxos":
                        case 10:
                            message.error = 10;
                            break;
                        case "Error_script_redeem":
                        case 11:
                            message.error = 11;
                            break;
                        case "Error_script_output":
                        case 12:
                            message.error = 12;
                            break;
                        case "Error_script_witness_program":
                        case 13:
                            message.error = 13;
                            break;
                        case "Error_invalid_memo":
                        case 14:
                            message.error = 14;
                            break;
                        case "Error_input_parse":
                        case 19:
                            message.error = 19;
                            break;
                        case "Error_no_support_n2n":
                        case 20:
                            message.error = 20;
                            break;
                        case "Error_signatures_count":
                        case 21:
                            message.error = 21;
                            break;
                        case "Error_invalid_params":
                        case 22:
                            message.error = 22;
                            break;
                        case "Error_invalid_requested_token_amount":
                        case 23:
                            message.error = 23;
                            break;
                        }
                        if (object.errorMessage != null)
                            message.errorMessage = String(object.errorMessage);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a PreSigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @static
                     * @param {TW.TxCompiler.Proto.PreSigningOutput} message PreSigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PreSigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.dataHash = "";
                            else {
                                object.dataHash = [];
                                if (options.bytes !== Array)
                                    object.dataHash = $util.newBuffer(object.dataHash);
                            }
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                            object.error = options.enums === String ? "OK" : 0;
                            object.errorMessage = "";
                        }
                        if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                            object.dataHash = options.bytes === String ? $util.base64.encode(message.dataHash, 0, message.dataHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.dataHash) : message.dataHash;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = options.enums === String ? $root.TW.Common.Proto.SigningError[message.error] : message.error;
                        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                            object.errorMessage = message.errorMessage;
                        return object;
                    };
    
                    /**
                     * Converts this PreSigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.TxCompiler.Proto.PreSigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PreSigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PreSigningOutput;
                })();
    
                return Proto;
            })();
    
            return TxCompiler;
        })();
    
        TW.Tron = (function() {
    
            /**
             * Namespace Tron.
             * @memberof TW
             * @namespace
             */
            var Tron = {};
    
            Tron.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Tron
                 * @namespace
                 */
                var Proto = {};
    
                Proto.TransferContract = (function() {
    
                    /**
                     * Properties of a TransferContract.
                     * @memberof TW.Tron.Proto
                     * @interface ITransferContract
                     * @property {string|null} [ownerAddress] TransferContract ownerAddress
                     * @property {string|null} [toAddress] TransferContract toAddress
                     * @property {Long|null} [amount] TransferContract amount
                     */
    
                    /**
                     * Constructs a new TransferContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a TransferContract.
                     * @implements ITransferContract
                     * @constructor
                     * @param {TW.Tron.Proto.ITransferContract=} [properties] Properties to set
                     */
                    function TransferContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     */
                    TransferContract.prototype.ownerAddress = "";
    
                    /**
                     * TransferContract toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     */
                    TransferContract.prototype.toAddress = "";
    
                    /**
                     * TransferContract amount.
                     * @member {Long} amount
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     */
                    TransferContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TransferContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.TransferContract} TransferContract instance
                     */
                    TransferContract.create = function create(properties) {
                        return new TransferContract(properties);
                    };
    
                    /**
                     * Encodes the specified TransferContract message. Does not implicitly {@link TW.Tron.Proto.TransferContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferContract} message TransferContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransferContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.TransferContract} TransferContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.TransferContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransferContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.TransferContract} TransferContract
                     */
                    TransferContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.TransferContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.TransferContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {TW.Tron.Proto.TransferContract} message TransferContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.ownerAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TransferContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferContract;
                })();
    
                Proto.TransferAssetContract = (function() {
    
                    /**
                     * Properties of a TransferAssetContract.
                     * @memberof TW.Tron.Proto
                     * @interface ITransferAssetContract
                     * @property {string|null} [assetName] TransferAssetContract assetName
                     * @property {string|null} [ownerAddress] TransferAssetContract ownerAddress
                     * @property {string|null} [toAddress] TransferAssetContract toAddress
                     * @property {Long|null} [amount] TransferAssetContract amount
                     */
    
                    /**
                     * Constructs a new TransferAssetContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a TransferAssetContract.
                     * @implements ITransferAssetContract
                     * @constructor
                     * @param {TW.Tron.Proto.ITransferAssetContract=} [properties] Properties to set
                     */
                    function TransferAssetContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferAssetContract assetName.
                     * @member {string} assetName
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.assetName = "";
    
                    /**
                     * TransferAssetContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.ownerAddress = "";
    
                    /**
                     * TransferAssetContract toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.toAddress = "";
    
                    /**
                     * TransferAssetContract amount.
                     * @member {Long} amount
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TransferAssetContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferAssetContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.TransferAssetContract} TransferAssetContract instance
                     */
                    TransferAssetContract.create = function create(properties) {
                        return new TransferAssetContract(properties);
                    };
    
                    /**
                     * Encodes the specified TransferAssetContract message. Does not implicitly {@link TW.Tron.Proto.TransferAssetContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferAssetContract} message TransferAssetContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferAssetContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.assetName != null && Object.hasOwnProperty.call(message, "assetName"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.assetName);
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ownerAddress);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransferAssetContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.TransferAssetContract} TransferAssetContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferAssetContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.TransferAssetContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.assetName = reader.string();
                                break;
                            case 2:
                                message.ownerAddress = reader.string();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransferAssetContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferAssetContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.assetName != null && message.hasOwnProperty("assetName"))
                            if (!$util.isString(message.assetName))
                                return "assetName: string expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferAssetContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.TransferAssetContract} TransferAssetContract
                     */
                    TransferAssetContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.TransferAssetContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.TransferAssetContract();
                        if (object.assetName != null)
                            message.assetName = String(object.assetName);
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferAssetContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {TW.Tron.Proto.TransferAssetContract} message TransferAssetContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferAssetContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.assetName = "";
                            object.ownerAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.assetName != null && message.hasOwnProperty("assetName"))
                            object.assetName = message.assetName;
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TransferAssetContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferAssetContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferAssetContract;
                })();
    
                Proto.TransferTRC20Contract = (function() {
    
                    /**
                     * Properties of a TransferTRC20Contract.
                     * @memberof TW.Tron.Proto
                     * @interface ITransferTRC20Contract
                     * @property {string|null} [contractAddress] TransferTRC20Contract contractAddress
                     * @property {string|null} [ownerAddress] TransferTRC20Contract ownerAddress
                     * @property {string|null} [toAddress] TransferTRC20Contract toAddress
                     * @property {Uint8Array|null} [amount] TransferTRC20Contract amount
                     */
    
                    /**
                     * Constructs a new TransferTRC20Contract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a TransferTRC20Contract.
                     * @implements ITransferTRC20Contract
                     * @constructor
                     * @param {TW.Tron.Proto.ITransferTRC20Contract=} [properties] Properties to set
                     */
                    function TransferTRC20Contract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferTRC20Contract contractAddress.
                     * @member {string} contractAddress
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @instance
                     */
                    TransferTRC20Contract.prototype.contractAddress = "";
    
                    /**
                     * TransferTRC20Contract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @instance
                     */
                    TransferTRC20Contract.prototype.ownerAddress = "";
    
                    /**
                     * TransferTRC20Contract toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @instance
                     */
                    TransferTRC20Contract.prototype.toAddress = "";
    
                    /**
                     * TransferTRC20Contract amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @instance
                     */
                    TransferTRC20Contract.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransferTRC20Contract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @static
                     * @param {TW.Tron.Proto.ITransferTRC20Contract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.TransferTRC20Contract} TransferTRC20Contract instance
                     */
                    TransferTRC20Contract.create = function create(properties) {
                        return new TransferTRC20Contract(properties);
                    };
    
                    /**
                     * Encodes the specified TransferTRC20Contract message. Does not implicitly {@link TW.Tron.Proto.TransferTRC20Contract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @static
                     * @param {TW.Tron.Proto.ITransferTRC20Contract} message TransferTRC20Contract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferTRC20Contract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contractAddress);
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ownerAddress);
                        if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.amount);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransferTRC20Contract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.TransferTRC20Contract} TransferTRC20Contract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferTRC20Contract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.TransferTRC20Contract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contractAddress = reader.string();
                                break;
                            case 2:
                                message.ownerAddress = reader.string();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransferTRC20Contract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferTRC20Contract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                            if (!$util.isString(message.contractAddress))
                                return "contractAddress: string expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferTRC20Contract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.TransferTRC20Contract} TransferTRC20Contract
                     */
                    TransferTRC20Contract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.TransferTRC20Contract)
                            return object;
                        var message = new $root.TW.Tron.Proto.TransferTRC20Contract();
                        if (object.contractAddress != null)
                            message.contractAddress = String(object.contractAddress);
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferTRC20Contract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @static
                     * @param {TW.Tron.Proto.TransferTRC20Contract} message TransferTRC20Contract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferTRC20Contract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contractAddress = "";
                            object.ownerAddress = "";
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                        }
                        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                            object.contractAddress = message.contractAddress;
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TransferTRC20Contract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.TransferTRC20Contract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferTRC20Contract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferTRC20Contract;
                })();
    
                Proto.FreezeBalanceContract = (function() {
    
                    /**
                     * Properties of a FreezeBalanceContract.
                     * @memberof TW.Tron.Proto
                     * @interface IFreezeBalanceContract
                     * @property {string|null} [ownerAddress] FreezeBalanceContract ownerAddress
                     * @property {Long|null} [frozenBalance] FreezeBalanceContract frozenBalance
                     * @property {Long|null} [frozenDuration] FreezeBalanceContract frozenDuration
                     * @property {string|null} [resource] FreezeBalanceContract resource
                     * @property {string|null} [receiverAddress] FreezeBalanceContract receiverAddress
                     */
    
                    /**
                     * Constructs a new FreezeBalanceContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a FreezeBalanceContract.
                     * @implements IFreezeBalanceContract
                     * @constructor
                     * @param {TW.Tron.Proto.IFreezeBalanceContract=} [properties] Properties to set
                     */
                    function FreezeBalanceContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * FreezeBalanceContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @instance
                     */
                    FreezeBalanceContract.prototype.ownerAddress = "";
    
                    /**
                     * FreezeBalanceContract frozenBalance.
                     * @member {Long} frozenBalance
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @instance
                     */
                    FreezeBalanceContract.prototype.frozenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * FreezeBalanceContract frozenDuration.
                     * @member {Long} frozenDuration
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @instance
                     */
                    FreezeBalanceContract.prototype.frozenDuration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * FreezeBalanceContract resource.
                     * @member {string} resource
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @instance
                     */
                    FreezeBalanceContract.prototype.resource = "";
    
                    /**
                     * FreezeBalanceContract receiverAddress.
                     * @member {string} receiverAddress
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @instance
                     */
                    FreezeBalanceContract.prototype.receiverAddress = "";
    
                    /**
                     * Creates a new FreezeBalanceContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.IFreezeBalanceContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.FreezeBalanceContract} FreezeBalanceContract instance
                     */
                    FreezeBalanceContract.create = function create(properties) {
                        return new FreezeBalanceContract(properties);
                    };
    
                    /**
                     * Encodes the specified FreezeBalanceContract message. Does not implicitly {@link TW.Tron.Proto.FreezeBalanceContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.IFreezeBalanceContract} message FreezeBalanceContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FreezeBalanceContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        if (message.frozenBalance != null && Object.hasOwnProperty.call(message, "frozenBalance"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.frozenBalance);
                        if (message.frozenDuration != null && Object.hasOwnProperty.call(message, "frozenDuration"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.frozenDuration);
                        if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.resource);
                        if (message.receiverAddress != null && Object.hasOwnProperty.call(message, "receiverAddress"))
                            writer.uint32(/* id 15, wireType 2 =*/122).string(message.receiverAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes a FreezeBalanceContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.FreezeBalanceContract} FreezeBalanceContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FreezeBalanceContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.FreezeBalanceContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            case 2:
                                message.frozenBalance = reader.int64();
                                break;
                            case 3:
                                message.frozenDuration = reader.int64();
                                break;
                            case 10:
                                message.resource = reader.string();
                                break;
                            case 15:
                                message.receiverAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a FreezeBalanceContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FreezeBalanceContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                            if (!$util.isInteger(message.frozenBalance) && !(message.frozenBalance && $util.isInteger(message.frozenBalance.low) && $util.isInteger(message.frozenBalance.high)))
                                return "frozenBalance: integer|Long expected";
                        if (message.frozenDuration != null && message.hasOwnProperty("frozenDuration"))
                            if (!$util.isInteger(message.frozenDuration) && !(message.frozenDuration && $util.isInteger(message.frozenDuration.low) && $util.isInteger(message.frozenDuration.high)))
                                return "frozenDuration: integer|Long expected";
                        if (message.resource != null && message.hasOwnProperty("resource"))
                            if (!$util.isString(message.resource))
                                return "resource: string expected";
                        if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                            if (!$util.isString(message.receiverAddress))
                                return "receiverAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a FreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.FreezeBalanceContract} FreezeBalanceContract
                     */
                    FreezeBalanceContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.FreezeBalanceContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.FreezeBalanceContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.frozenBalance != null)
                            if ($util.Long)
                                (message.frozenBalance = $util.Long.fromValue(object.frozenBalance)).unsigned = false;
                            else if (typeof object.frozenBalance === "string")
                                message.frozenBalance = parseInt(object.frozenBalance, 10);
                            else if (typeof object.frozenBalance === "number")
                                message.frozenBalance = object.frozenBalance;
                            else if (typeof object.frozenBalance === "object")
                                message.frozenBalance = new $util.LongBits(object.frozenBalance.low >>> 0, object.frozenBalance.high >>> 0).toNumber();
                        if (object.frozenDuration != null)
                            if ($util.Long)
                                (message.frozenDuration = $util.Long.fromValue(object.frozenDuration)).unsigned = false;
                            else if (typeof object.frozenDuration === "string")
                                message.frozenDuration = parseInt(object.frozenDuration, 10);
                            else if (typeof object.frozenDuration === "number")
                                message.frozenDuration = object.frozenDuration;
                            else if (typeof object.frozenDuration === "object")
                                message.frozenDuration = new $util.LongBits(object.frozenDuration.low >>> 0, object.frozenDuration.high >>> 0).toNumber();
                        if (object.resource != null)
                            message.resource = String(object.resource);
                        if (object.receiverAddress != null)
                            message.receiverAddress = String(object.receiverAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a FreezeBalanceContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.FreezeBalanceContract} message FreezeBalanceContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FreezeBalanceContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.ownerAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.frozenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.frozenBalance = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.frozenDuration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.frozenDuration = options.longs === String ? "0" : 0;
                            object.resource = "";
                            object.receiverAddress = "";
                        }
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                            if (typeof message.frozenBalance === "number")
                                object.frozenBalance = options.longs === String ? String(message.frozenBalance) : message.frozenBalance;
                            else
                                object.frozenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalance) : options.longs === Number ? new $util.LongBits(message.frozenBalance.low >>> 0, message.frozenBalance.high >>> 0).toNumber() : message.frozenBalance;
                        if (message.frozenDuration != null && message.hasOwnProperty("frozenDuration"))
                            if (typeof message.frozenDuration === "number")
                                object.frozenDuration = options.longs === String ? String(message.frozenDuration) : message.frozenDuration;
                            else
                                object.frozenDuration = options.longs === String ? $util.Long.prototype.toString.call(message.frozenDuration) : options.longs === Number ? new $util.LongBits(message.frozenDuration.low >>> 0, message.frozenDuration.high >>> 0).toNumber() : message.frozenDuration;
                        if (message.resource != null && message.hasOwnProperty("resource"))
                            object.resource = message.resource;
                        if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                            object.receiverAddress = message.receiverAddress;
                        return object;
                    };
    
                    /**
                     * Converts this FreezeBalanceContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.FreezeBalanceContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FreezeBalanceContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return FreezeBalanceContract;
                })();
    
                Proto.UnfreezeBalanceContract = (function() {
    
                    /**
                     * Properties of an UnfreezeBalanceContract.
                     * @memberof TW.Tron.Proto
                     * @interface IUnfreezeBalanceContract
                     * @property {string|null} [ownerAddress] UnfreezeBalanceContract ownerAddress
                     * @property {string|null} [resource] UnfreezeBalanceContract resource
                     * @property {string|null} [receiverAddress] UnfreezeBalanceContract receiverAddress
                     */
    
                    /**
                     * Constructs a new UnfreezeBalanceContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents an UnfreezeBalanceContract.
                     * @implements IUnfreezeBalanceContract
                     * @constructor
                     * @param {TW.Tron.Proto.IUnfreezeBalanceContract=} [properties] Properties to set
                     */
                    function UnfreezeBalanceContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * UnfreezeBalanceContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @instance
                     */
                    UnfreezeBalanceContract.prototype.ownerAddress = "";
    
                    /**
                     * UnfreezeBalanceContract resource.
                     * @member {string} resource
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @instance
                     */
                    UnfreezeBalanceContract.prototype.resource = "";
    
                    /**
                     * UnfreezeBalanceContract receiverAddress.
                     * @member {string} receiverAddress
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @instance
                     */
                    UnfreezeBalanceContract.prototype.receiverAddress = "";
    
                    /**
                     * Creates a new UnfreezeBalanceContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.IUnfreezeBalanceContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.UnfreezeBalanceContract} UnfreezeBalanceContract instance
                     */
                    UnfreezeBalanceContract.create = function create(properties) {
                        return new UnfreezeBalanceContract(properties);
                    };
    
                    /**
                     * Encodes the specified UnfreezeBalanceContract message. Does not implicitly {@link TW.Tron.Proto.UnfreezeBalanceContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.IUnfreezeBalanceContract} message UnfreezeBalanceContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UnfreezeBalanceContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.resource);
                        if (message.receiverAddress != null && Object.hasOwnProperty.call(message, "receiverAddress"))
                            writer.uint32(/* id 15, wireType 2 =*/122).string(message.receiverAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes an UnfreezeBalanceContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.UnfreezeBalanceContract} UnfreezeBalanceContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UnfreezeBalanceContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.UnfreezeBalanceContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            case 10:
                                message.resource = reader.string();
                                break;
                            case 15:
                                message.receiverAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an UnfreezeBalanceContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UnfreezeBalanceContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.resource != null && message.hasOwnProperty("resource"))
                            if (!$util.isString(message.resource))
                                return "resource: string expected";
                        if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                            if (!$util.isString(message.receiverAddress))
                                return "receiverAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an UnfreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.UnfreezeBalanceContract} UnfreezeBalanceContract
                     */
                    UnfreezeBalanceContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.UnfreezeBalanceContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.UnfreezeBalanceContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.resource != null)
                            message.resource = String(object.resource);
                        if (object.receiverAddress != null)
                            message.receiverAddress = String(object.receiverAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an UnfreezeBalanceContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.UnfreezeBalanceContract} message UnfreezeBalanceContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UnfreezeBalanceContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.ownerAddress = "";
                            object.resource = "";
                            object.receiverAddress = "";
                        }
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.resource != null && message.hasOwnProperty("resource"))
                            object.resource = message.resource;
                        if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                            object.receiverAddress = message.receiverAddress;
                        return object;
                    };
    
                    /**
                     * Converts this UnfreezeBalanceContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.UnfreezeBalanceContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UnfreezeBalanceContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return UnfreezeBalanceContract;
                })();
    
                Proto.UnfreezeAssetContract = (function() {
    
                    /**
                     * Properties of an UnfreezeAssetContract.
                     * @memberof TW.Tron.Proto
                     * @interface IUnfreezeAssetContract
                     * @property {string|null} [ownerAddress] UnfreezeAssetContract ownerAddress
                     */
    
                    /**
                     * Constructs a new UnfreezeAssetContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents an UnfreezeAssetContract.
                     * @implements IUnfreezeAssetContract
                     * @constructor
                     * @param {TW.Tron.Proto.IUnfreezeAssetContract=} [properties] Properties to set
                     */
                    function UnfreezeAssetContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * UnfreezeAssetContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @instance
                     */
                    UnfreezeAssetContract.prototype.ownerAddress = "";
    
                    /**
                     * Creates a new UnfreezeAssetContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @static
                     * @param {TW.Tron.Proto.IUnfreezeAssetContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.UnfreezeAssetContract} UnfreezeAssetContract instance
                     */
                    UnfreezeAssetContract.create = function create(properties) {
                        return new UnfreezeAssetContract(properties);
                    };
    
                    /**
                     * Encodes the specified UnfreezeAssetContract message. Does not implicitly {@link TW.Tron.Proto.UnfreezeAssetContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @static
                     * @param {TW.Tron.Proto.IUnfreezeAssetContract} message UnfreezeAssetContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UnfreezeAssetContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes an UnfreezeAssetContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.UnfreezeAssetContract} UnfreezeAssetContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UnfreezeAssetContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.UnfreezeAssetContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies an UnfreezeAssetContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UnfreezeAssetContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an UnfreezeAssetContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.UnfreezeAssetContract} UnfreezeAssetContract
                     */
                    UnfreezeAssetContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.UnfreezeAssetContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.UnfreezeAssetContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an UnfreezeAssetContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @static
                     * @param {TW.Tron.Proto.UnfreezeAssetContract} message UnfreezeAssetContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UnfreezeAssetContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.ownerAddress = "";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        return object;
                    };
    
                    /**
                     * Converts this UnfreezeAssetContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.UnfreezeAssetContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UnfreezeAssetContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return UnfreezeAssetContract;
                })();
    
                Proto.VoteAssetContract = (function() {
    
                    /**
                     * Properties of a VoteAssetContract.
                     * @memberof TW.Tron.Proto
                     * @interface IVoteAssetContract
                     * @property {string|null} [ownerAddress] VoteAssetContract ownerAddress
                     * @property {Array.<string>|null} [voteAddress] VoteAssetContract voteAddress
                     * @property {boolean|null} [support] VoteAssetContract support
                     * @property {number|null} [count] VoteAssetContract count
                     */
    
                    /**
                     * Constructs a new VoteAssetContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a VoteAssetContract.
                     * @implements IVoteAssetContract
                     * @constructor
                     * @param {TW.Tron.Proto.IVoteAssetContract=} [properties] Properties to set
                     */
                    function VoteAssetContract(properties) {
                        this.voteAddress = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * VoteAssetContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @instance
                     */
                    VoteAssetContract.prototype.ownerAddress = "";
    
                    /**
                     * VoteAssetContract voteAddress.
                     * @member {Array.<string>} voteAddress
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @instance
                     */
                    VoteAssetContract.prototype.voteAddress = $util.emptyArray;
    
                    /**
                     * VoteAssetContract support.
                     * @member {boolean} support
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @instance
                     */
                    VoteAssetContract.prototype.support = false;
    
                    /**
                     * VoteAssetContract count.
                     * @member {number} count
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @instance
                     */
                    VoteAssetContract.prototype.count = 0;
    
                    /**
                     * Creates a new VoteAssetContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @static
                     * @param {TW.Tron.Proto.IVoteAssetContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.VoteAssetContract} VoteAssetContract instance
                     */
                    VoteAssetContract.create = function create(properties) {
                        return new VoteAssetContract(properties);
                    };
    
                    /**
                     * Encodes the specified VoteAssetContract message. Does not implicitly {@link TW.Tron.Proto.VoteAssetContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @static
                     * @param {TW.Tron.Proto.IVoteAssetContract} message VoteAssetContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    VoteAssetContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        if (message.voteAddress != null && message.voteAddress.length)
                            for (var i = 0; i < message.voteAddress.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.voteAddress[i]);
                        if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.support);
                        if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.count);
                        return writer;
                    };
    
                    /**
                     * Decodes a VoteAssetContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.VoteAssetContract} VoteAssetContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    VoteAssetContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.VoteAssetContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            case 2:
                                if (!(message.voteAddress && message.voteAddress.length))
                                    message.voteAddress = [];
                                message.voteAddress.push(reader.string());
                                break;
                            case 3:
                                message.support = reader.bool();
                                break;
                            case 5:
                                message.count = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a VoteAssetContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    VoteAssetContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.voteAddress != null && message.hasOwnProperty("voteAddress")) {
                            if (!Array.isArray(message.voteAddress))
                                return "voteAddress: array expected";
                            for (var i = 0; i < message.voteAddress.length; ++i)
                                if (!$util.isString(message.voteAddress[i]))
                                    return "voteAddress: string[] expected";
                        }
                        if (message.support != null && message.hasOwnProperty("support"))
                            if (typeof message.support !== "boolean")
                                return "support: boolean expected";
                        if (message.count != null && message.hasOwnProperty("count"))
                            if (!$util.isInteger(message.count))
                                return "count: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a VoteAssetContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.VoteAssetContract} VoteAssetContract
                     */
                    VoteAssetContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.VoteAssetContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.VoteAssetContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.voteAddress) {
                            if (!Array.isArray(object.voteAddress))
                                throw TypeError(".TW.Tron.Proto.VoteAssetContract.voteAddress: array expected");
                            message.voteAddress = [];
                            for (var i = 0; i < object.voteAddress.length; ++i)
                                message.voteAddress[i] = String(object.voteAddress[i]);
                        }
                        if (object.support != null)
                            message.support = Boolean(object.support);
                        if (object.count != null)
                            message.count = object.count | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a VoteAssetContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @static
                     * @param {TW.Tron.Proto.VoteAssetContract} message VoteAssetContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    VoteAssetContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.voteAddress = [];
                        if (options.defaults) {
                            object.ownerAddress = "";
                            object.support = false;
                            object.count = 0;
                        }
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.voteAddress && message.voteAddress.length) {
                            object.voteAddress = [];
                            for (var j = 0; j < message.voteAddress.length; ++j)
                                object.voteAddress[j] = message.voteAddress[j];
                        }
                        if (message.support != null && message.hasOwnProperty("support"))
                            object.support = message.support;
                        if (message.count != null && message.hasOwnProperty("count"))
                            object.count = message.count;
                        return object;
                    };
    
                    /**
                     * Converts this VoteAssetContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.VoteAssetContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    VoteAssetContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return VoteAssetContract;
                })();
    
                Proto.VoteWitnessContract = (function() {
    
                    /**
                     * Properties of a VoteWitnessContract.
                     * @memberof TW.Tron.Proto
                     * @interface IVoteWitnessContract
                     * @property {string|null} [ownerAddress] VoteWitnessContract ownerAddress
                     * @property {Array.<TW.Tron.Proto.VoteWitnessContract.IVote>|null} [votes] VoteWitnessContract votes
                     * @property {boolean|null} [support] VoteWitnessContract support
                     */
    
                    /**
                     * Constructs a new VoteWitnessContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a VoteWitnessContract.
                     * @implements IVoteWitnessContract
                     * @constructor
                     * @param {TW.Tron.Proto.IVoteWitnessContract=} [properties] Properties to set
                     */
                    function VoteWitnessContract(properties) {
                        this.votes = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * VoteWitnessContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @instance
                     */
                    VoteWitnessContract.prototype.ownerAddress = "";
    
                    /**
                     * VoteWitnessContract votes.
                     * @member {Array.<TW.Tron.Proto.VoteWitnessContract.IVote>} votes
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @instance
                     */
                    VoteWitnessContract.prototype.votes = $util.emptyArray;
    
                    /**
                     * VoteWitnessContract support.
                     * @member {boolean} support
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @instance
                     */
                    VoteWitnessContract.prototype.support = false;
    
                    /**
                     * Creates a new VoteWitnessContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @static
                     * @param {TW.Tron.Proto.IVoteWitnessContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.VoteWitnessContract} VoteWitnessContract instance
                     */
                    VoteWitnessContract.create = function create(properties) {
                        return new VoteWitnessContract(properties);
                    };
    
                    /**
                     * Encodes the specified VoteWitnessContract message. Does not implicitly {@link TW.Tron.Proto.VoteWitnessContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @static
                     * @param {TW.Tron.Proto.IVoteWitnessContract} message VoteWitnessContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    VoteWitnessContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        if (message.votes != null && message.votes.length)
                            for (var i = 0; i < message.votes.length; ++i)
                                $root.TW.Tron.Proto.VoteWitnessContract.Vote.encode(message.votes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.support);
                        return writer;
                    };
    
                    /**
                     * Decodes a VoteWitnessContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.VoteWitnessContract} VoteWitnessContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    VoteWitnessContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.VoteWitnessContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            case 2:
                                if (!(message.votes && message.votes.length))
                                    message.votes = [];
                                message.votes.push($root.TW.Tron.Proto.VoteWitnessContract.Vote.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.support = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a VoteWitnessContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    VoteWitnessContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.votes != null && message.hasOwnProperty("votes")) {
                            if (!Array.isArray(message.votes))
                                return "votes: array expected";
                            for (var i = 0; i < message.votes.length; ++i) {
                                var error = $root.TW.Tron.Proto.VoteWitnessContract.Vote.verify(message.votes[i]);
                                if (error)
                                    return "votes." + error;
                            }
                        }
                        if (message.support != null && message.hasOwnProperty("support"))
                            if (typeof message.support !== "boolean")
                                return "support: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a VoteWitnessContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.VoteWitnessContract} VoteWitnessContract
                     */
                    VoteWitnessContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.VoteWitnessContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.VoteWitnessContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.votes) {
                            if (!Array.isArray(object.votes))
                                throw TypeError(".TW.Tron.Proto.VoteWitnessContract.votes: array expected");
                            message.votes = [];
                            for (var i = 0; i < object.votes.length; ++i) {
                                if (typeof object.votes[i] !== "object")
                                    throw TypeError(".TW.Tron.Proto.VoteWitnessContract.votes: object expected");
                                message.votes[i] = $root.TW.Tron.Proto.VoteWitnessContract.Vote.fromObject(object.votes[i]);
                            }
                        }
                        if (object.support != null)
                            message.support = Boolean(object.support);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a VoteWitnessContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @static
                     * @param {TW.Tron.Proto.VoteWitnessContract} message VoteWitnessContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    VoteWitnessContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.votes = [];
                        if (options.defaults) {
                            object.ownerAddress = "";
                            object.support = false;
                        }
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.votes && message.votes.length) {
                            object.votes = [];
                            for (var j = 0; j < message.votes.length; ++j)
                                object.votes[j] = $root.TW.Tron.Proto.VoteWitnessContract.Vote.toObject(message.votes[j], options);
                        }
                        if (message.support != null && message.hasOwnProperty("support"))
                            object.support = message.support;
                        return object;
                    };
    
                    /**
                     * Converts this VoteWitnessContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.VoteWitnessContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    VoteWitnessContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    VoteWitnessContract.Vote = (function() {
    
                        /**
                         * Properties of a Vote.
                         * @memberof TW.Tron.Proto.VoteWitnessContract
                         * @interface IVote
                         * @property {string|null} [voteAddress] Vote voteAddress
                         * @property {Long|null} [voteCount] Vote voteCount
                         */
    
                        /**
                         * Constructs a new Vote.
                         * @memberof TW.Tron.Proto.VoteWitnessContract
                         * @classdesc Represents a Vote.
                         * @implements IVote
                         * @constructor
                         * @param {TW.Tron.Proto.VoteWitnessContract.IVote=} [properties] Properties to set
                         */
                        function Vote(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Vote voteAddress.
                         * @member {string} voteAddress
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @instance
                         */
                        Vote.prototype.voteAddress = "";
    
                        /**
                         * Vote voteCount.
                         * @member {Long} voteCount
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @instance
                         */
                        Vote.prototype.voteCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                        /**
                         * Creates a new Vote instance using the specified properties.
                         * @function create
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @static
                         * @param {TW.Tron.Proto.VoteWitnessContract.IVote=} [properties] Properties to set
                         * @returns {TW.Tron.Proto.VoteWitnessContract.Vote} Vote instance
                         */
                        Vote.create = function create(properties) {
                            return new Vote(properties);
                        };
    
                        /**
                         * Encodes the specified Vote message. Does not implicitly {@link TW.Tron.Proto.VoteWitnessContract.Vote.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @static
                         * @param {TW.Tron.Proto.VoteWitnessContract.IVote} message Vote message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Vote.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.voteAddress != null && Object.hasOwnProperty.call(message, "voteAddress"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.voteAddress);
                            if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.voteCount);
                            return writer;
                        };
    
                        /**
                         * Decodes a Vote message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Tron.Proto.VoteWitnessContract.Vote} Vote
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Vote.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.VoteWitnessContract.Vote();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.voteAddress = reader.string();
                                    break;
                                case 2:
                                    message.voteCount = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Vote message.
                         * @function verify
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Vote.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                                if (!$util.isString(message.voteAddress))
                                    return "voteAddress: string expected";
                            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                                if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                                    return "voteCount: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a Vote message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Tron.Proto.VoteWitnessContract.Vote} Vote
                         */
                        Vote.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Tron.Proto.VoteWitnessContract.Vote)
                                return object;
                            var message = new $root.TW.Tron.Proto.VoteWitnessContract.Vote();
                            if (object.voteAddress != null)
                                message.voteAddress = String(object.voteAddress);
                            if (object.voteCount != null)
                                if ($util.Long)
                                    (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                                else if (typeof object.voteCount === "string")
                                    message.voteCount = parseInt(object.voteCount, 10);
                                else if (typeof object.voteCount === "number")
                                    message.voteCount = object.voteCount;
                                else if (typeof object.voteCount === "object")
                                    message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Vote message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @static
                         * @param {TW.Tron.Proto.VoteWitnessContract.Vote} message Vote
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Vote.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.voteAddress = "";
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, false);
                                    object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.voteCount = options.longs === String ? "0" : 0;
                            }
                            if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                                object.voteAddress = message.voteAddress;
                            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                                if (typeof message.voteCount === "number")
                                    object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                                else
                                    object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
                            return object;
                        };
    
                        /**
                         * Converts this Vote to JSON.
                         * @function toJSON
                         * @memberof TW.Tron.Proto.VoteWitnessContract.Vote
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Vote.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Vote;
                    })();
    
                    return VoteWitnessContract;
                })();
    
                Proto.WithdrawBalanceContract = (function() {
    
                    /**
                     * Properties of a WithdrawBalanceContract.
                     * @memberof TW.Tron.Proto
                     * @interface IWithdrawBalanceContract
                     * @property {string|null} [ownerAddress] WithdrawBalanceContract ownerAddress
                     */
    
                    /**
                     * Constructs a new WithdrawBalanceContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a WithdrawBalanceContract.
                     * @implements IWithdrawBalanceContract
                     * @constructor
                     * @param {TW.Tron.Proto.IWithdrawBalanceContract=} [properties] Properties to set
                     */
                    function WithdrawBalanceContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * WithdrawBalanceContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @instance
                     */
                    WithdrawBalanceContract.prototype.ownerAddress = "";
    
                    /**
                     * Creates a new WithdrawBalanceContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.IWithdrawBalanceContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.WithdrawBalanceContract} WithdrawBalanceContract instance
                     */
                    WithdrawBalanceContract.create = function create(properties) {
                        return new WithdrawBalanceContract(properties);
                    };
    
                    /**
                     * Encodes the specified WithdrawBalanceContract message. Does not implicitly {@link TW.Tron.Proto.WithdrawBalanceContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.IWithdrawBalanceContract} message WithdrawBalanceContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    WithdrawBalanceContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        return writer;
                    };
    
                    /**
                     * Decodes a WithdrawBalanceContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.WithdrawBalanceContract} WithdrawBalanceContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    WithdrawBalanceContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.WithdrawBalanceContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a WithdrawBalanceContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    WithdrawBalanceContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a WithdrawBalanceContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.WithdrawBalanceContract} WithdrawBalanceContract
                     */
                    WithdrawBalanceContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.WithdrawBalanceContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.WithdrawBalanceContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a WithdrawBalanceContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @static
                     * @param {TW.Tron.Proto.WithdrawBalanceContract} message WithdrawBalanceContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    WithdrawBalanceContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.ownerAddress = "";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        return object;
                    };
    
                    /**
                     * Converts this WithdrawBalanceContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.WithdrawBalanceContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    WithdrawBalanceContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return WithdrawBalanceContract;
                })();
    
                Proto.TriggerSmartContract = (function() {
    
                    /**
                     * Properties of a TriggerSmartContract.
                     * @memberof TW.Tron.Proto
                     * @interface ITriggerSmartContract
                     * @property {string|null} [ownerAddress] TriggerSmartContract ownerAddress
                     * @property {string|null} [contractAddress] TriggerSmartContract contractAddress
                     * @property {Long|null} [callValue] TriggerSmartContract callValue
                     * @property {Uint8Array|null} [data] TriggerSmartContract data
                     * @property {Long|null} [callTokenValue] TriggerSmartContract callTokenValue
                     * @property {Long|null} [tokenId] TriggerSmartContract tokenId
                     */
    
                    /**
                     * Constructs a new TriggerSmartContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a TriggerSmartContract.
                     * @implements ITriggerSmartContract
                     * @constructor
                     * @param {TW.Tron.Proto.ITriggerSmartContract=} [properties] Properties to set
                     */
                    function TriggerSmartContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TriggerSmartContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @instance
                     */
                    TriggerSmartContract.prototype.ownerAddress = "";
    
                    /**
                     * TriggerSmartContract contractAddress.
                     * @member {string} contractAddress
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @instance
                     */
                    TriggerSmartContract.prototype.contractAddress = "";
    
                    /**
                     * TriggerSmartContract callValue.
                     * @member {Long} callValue
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @instance
                     */
                    TriggerSmartContract.prototype.callValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TriggerSmartContract data.
                     * @member {Uint8Array} data
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @instance
                     */
                    TriggerSmartContract.prototype.data = $util.newBuffer([]);
    
                    /**
                     * TriggerSmartContract callTokenValue.
                     * @member {Long} callTokenValue
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @instance
                     */
                    TriggerSmartContract.prototype.callTokenValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TriggerSmartContract tokenId.
                     * @member {Long} tokenId
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @instance
                     */
                    TriggerSmartContract.prototype.tokenId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TriggerSmartContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @static
                     * @param {TW.Tron.Proto.ITriggerSmartContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.TriggerSmartContract} TriggerSmartContract instance
                     */
                    TriggerSmartContract.create = function create(properties) {
                        return new TriggerSmartContract(properties);
                    };
    
                    /**
                     * Encodes the specified TriggerSmartContract message. Does not implicitly {@link TW.Tron.Proto.TriggerSmartContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @static
                     * @param {TW.Tron.Proto.ITriggerSmartContract} message TriggerSmartContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TriggerSmartContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractAddress);
                        if (message.callValue != null && Object.hasOwnProperty.call(message, "callValue"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.callValue);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
                        if (message.callTokenValue != null && Object.hasOwnProperty.call(message, "callTokenValue"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.callTokenValue);
                        if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.tokenId);
                        return writer;
                    };
    
                    /**
                     * Decodes a TriggerSmartContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.TriggerSmartContract} TriggerSmartContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TriggerSmartContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.TriggerSmartContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            case 2:
                                message.contractAddress = reader.string();
                                break;
                            case 3:
                                message.callValue = reader.int64();
                                break;
                            case 4:
                                message.data = reader.bytes();
                                break;
                            case 5:
                                message.callTokenValue = reader.int64();
                                break;
                            case 6:
                                message.tokenId = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TriggerSmartContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TriggerSmartContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                            if (!$util.isString(message.contractAddress))
                                return "contractAddress: string expected";
                        if (message.callValue != null && message.hasOwnProperty("callValue"))
                            if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                                return "callValue: integer|Long expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                            if (!$util.isInteger(message.callTokenValue) && !(message.callTokenValue && $util.isInteger(message.callTokenValue.low) && $util.isInteger(message.callTokenValue.high)))
                                return "callTokenValue: integer|Long expected";
                        if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                            if (!$util.isInteger(message.tokenId) && !(message.tokenId && $util.isInteger(message.tokenId.low) && $util.isInteger(message.tokenId.high)))
                                return "tokenId: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TriggerSmartContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.TriggerSmartContract} TriggerSmartContract
                     */
                    TriggerSmartContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.TriggerSmartContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.TriggerSmartContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.contractAddress != null)
                            message.contractAddress = String(object.contractAddress);
                        if (object.callValue != null)
                            if ($util.Long)
                                (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                            else if (typeof object.callValue === "string")
                                message.callValue = parseInt(object.callValue, 10);
                            else if (typeof object.callValue === "number")
                                message.callValue = object.callValue;
                            else if (typeof object.callValue === "object")
                                message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        if (object.callTokenValue != null)
                            if ($util.Long)
                                (message.callTokenValue = $util.Long.fromValue(object.callTokenValue)).unsigned = false;
                            else if (typeof object.callTokenValue === "string")
                                message.callTokenValue = parseInt(object.callTokenValue, 10);
                            else if (typeof object.callTokenValue === "number")
                                message.callTokenValue = object.callTokenValue;
                            else if (typeof object.callTokenValue === "object")
                                message.callTokenValue = new $util.LongBits(object.callTokenValue.low >>> 0, object.callTokenValue.high >>> 0).toNumber();
                        if (object.tokenId != null)
                            if ($util.Long)
                                (message.tokenId = $util.Long.fromValue(object.tokenId)).unsigned = false;
                            else if (typeof object.tokenId === "string")
                                message.tokenId = parseInt(object.tokenId, 10);
                            else if (typeof object.tokenId === "number")
                                message.tokenId = object.tokenId;
                            else if (typeof object.tokenId === "object")
                                message.tokenId = new $util.LongBits(object.tokenId.low >>> 0, object.tokenId.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TriggerSmartContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @static
                     * @param {TW.Tron.Proto.TriggerSmartContract} message TriggerSmartContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TriggerSmartContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.ownerAddress = "";
                            object.contractAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.callValue = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.callTokenValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.callTokenValue = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.tokenId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.tokenId = options.longs === String ? "0" : 0;
                        }
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                            object.contractAddress = message.contractAddress;
                        if (message.callValue != null && message.hasOwnProperty("callValue"))
                            if (typeof message.callValue === "number")
                                object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                            else
                                object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                            if (typeof message.callTokenValue === "number")
                                object.callTokenValue = options.longs === String ? String(message.callTokenValue) : message.callTokenValue;
                            else
                                object.callTokenValue = options.longs === String ? $util.Long.prototype.toString.call(message.callTokenValue) : options.longs === Number ? new $util.LongBits(message.callTokenValue.low >>> 0, message.callTokenValue.high >>> 0).toNumber() : message.callTokenValue;
                        if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                            if (typeof message.tokenId === "number")
                                object.tokenId = options.longs === String ? String(message.tokenId) : message.tokenId;
                            else
                                object.tokenId = options.longs === String ? $util.Long.prototype.toString.call(message.tokenId) : options.longs === Number ? new $util.LongBits(message.tokenId.low >>> 0, message.tokenId.high >>> 0).toNumber() : message.tokenId;
                        return object;
                    };
    
                    /**
                     * Converts this TriggerSmartContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.TriggerSmartContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TriggerSmartContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TriggerSmartContract;
                })();
    
                Proto.BlockHeader = (function() {
    
                    /**
                     * Properties of a BlockHeader.
                     * @memberof TW.Tron.Proto
                     * @interface IBlockHeader
                     * @property {Long|null} [timestamp] BlockHeader timestamp
                     * @property {Uint8Array|null} [txTrieRoot] BlockHeader txTrieRoot
                     * @property {Uint8Array|null} [parentHash] BlockHeader parentHash
                     * @property {Long|null} [number] BlockHeader number
                     * @property {Uint8Array|null} [witnessAddress] BlockHeader witnessAddress
                     * @property {number|null} [version] BlockHeader version
                     */
    
                    /**
                     * Constructs a new BlockHeader.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a BlockHeader.
                     * @implements IBlockHeader
                     * @constructor
                     * @param {TW.Tron.Proto.IBlockHeader=} [properties] Properties to set
                     */
                    function BlockHeader(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * BlockHeader timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * BlockHeader txTrieRoot.
                     * @member {Uint8Array} txTrieRoot
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.txTrieRoot = $util.newBuffer([]);
    
                    /**
                     * BlockHeader parentHash.
                     * @member {Uint8Array} parentHash
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.parentHash = $util.newBuffer([]);
    
                    /**
                     * BlockHeader number.
                     * @member {Long} number
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * BlockHeader witnessAddress.
                     * @member {Uint8Array} witnessAddress
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.witnessAddress = $util.newBuffer([]);
    
                    /**
                     * BlockHeader version.
                     * @member {number} version
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.version = 0;
    
                    /**
                     * Creates a new BlockHeader instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {TW.Tron.Proto.IBlockHeader=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.BlockHeader} BlockHeader instance
                     */
                    BlockHeader.create = function create(properties) {
                        return new BlockHeader(properties);
                    };
    
                    /**
                     * Encodes the specified BlockHeader message. Does not implicitly {@link TW.Tron.Proto.BlockHeader.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {TW.Tron.Proto.IBlockHeader} message BlockHeader message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BlockHeader.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                        if (message.txTrieRoot != null && Object.hasOwnProperty.call(message, "txTrieRoot"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.txTrieRoot);
                        if (message.parentHash != null && Object.hasOwnProperty.call(message, "parentHash"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.parentHash);
                        if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.number);
                        if (message.witnessAddress != null && Object.hasOwnProperty.call(message, "witnessAddress"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.witnessAddress);
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.version);
                        return writer;
                    };
    
                    /**
                     * Decodes a BlockHeader message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.BlockHeader} BlockHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BlockHeader.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.BlockHeader();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestamp = reader.int64();
                                break;
                            case 2:
                                message.txTrieRoot = reader.bytes();
                                break;
                            case 3:
                                message.parentHash = reader.bytes();
                                break;
                            case 7:
                                message.number = reader.int64();
                                break;
                            case 9:
                                message.witnessAddress = reader.bytes();
                                break;
                            case 10:
                                message.version = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a BlockHeader message.
                     * @function verify
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BlockHeader.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                            if (!(message.txTrieRoot && typeof message.txTrieRoot.length === "number" || $util.isString(message.txTrieRoot)))
                                return "txTrieRoot: buffer expected";
                        if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                            if (!(message.parentHash && typeof message.parentHash.length === "number" || $util.isString(message.parentHash)))
                                return "parentHash: buffer expected";
                        if (message.number != null && message.hasOwnProperty("number"))
                            if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                                return "number: integer|Long expected";
                        if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                            if (!(message.witnessAddress && typeof message.witnessAddress.length === "number" || $util.isString(message.witnessAddress)))
                                return "witnessAddress: buffer expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a BlockHeader message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.BlockHeader} BlockHeader
                     */
                    BlockHeader.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.BlockHeader)
                            return object;
                        var message = new $root.TW.Tron.Proto.BlockHeader();
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.txTrieRoot != null)
                            if (typeof object.txTrieRoot === "string")
                                $util.base64.decode(object.txTrieRoot, message.txTrieRoot = $util.newBuffer($util.base64.length(object.txTrieRoot)), 0);
                            else if (object.txTrieRoot.length)
                                message.txTrieRoot = object.txTrieRoot;
                        if (object.parentHash != null)
                            if (typeof object.parentHash === "string")
                                $util.base64.decode(object.parentHash, message.parentHash = $util.newBuffer($util.base64.length(object.parentHash)), 0);
                            else if (object.parentHash.length)
                                message.parentHash = object.parentHash;
                        if (object.number != null)
                            if ($util.Long)
                                (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                            else if (typeof object.number === "string")
                                message.number = parseInt(object.number, 10);
                            else if (typeof object.number === "number")
                                message.number = object.number;
                            else if (typeof object.number === "object")
                                message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                        if (object.witnessAddress != null)
                            if (typeof object.witnessAddress === "string")
                                $util.base64.decode(object.witnessAddress, message.witnessAddress = $util.newBuffer($util.base64.length(object.witnessAddress)), 0);
                            else if (object.witnessAddress.length)
                                message.witnessAddress = object.witnessAddress;
                        if (object.version != null)
                            message.version = object.version | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a BlockHeader message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {TW.Tron.Proto.BlockHeader} message BlockHeader
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BlockHeader.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.txTrieRoot = "";
                            else {
                                object.txTrieRoot = [];
                                if (options.bytes !== Array)
                                    object.txTrieRoot = $util.newBuffer(object.txTrieRoot);
                            }
                            if (options.bytes === String)
                                object.parentHash = "";
                            else {
                                object.parentHash = [];
                                if (options.bytes !== Array)
                                    object.parentHash = $util.newBuffer(object.parentHash);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.number = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.witnessAddress = "";
                            else {
                                object.witnessAddress = [];
                                if (options.bytes !== Array)
                                    object.witnessAddress = $util.newBuffer(object.witnessAddress);
                            }
                            object.version = 0;
                        }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                            object.txTrieRoot = options.bytes === String ? $util.base64.encode(message.txTrieRoot, 0, message.txTrieRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.txTrieRoot) : message.txTrieRoot;
                        if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                            object.parentHash = options.bytes === String ? $util.base64.encode(message.parentHash, 0, message.parentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentHash) : message.parentHash;
                        if (message.number != null && message.hasOwnProperty("number"))
                            if (typeof message.number === "number")
                                object.number = options.longs === String ? String(message.number) : message.number;
                            else
                                object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                        if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                            object.witnessAddress = options.bytes === String ? $util.base64.encode(message.witnessAddress, 0, message.witnessAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.witnessAddress) : message.witnessAddress;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        return object;
                    };
    
                    /**
                     * Converts this BlockHeader to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BlockHeader.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return BlockHeader;
                })();
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Tron.Proto
                     * @interface ITransaction
                     * @property {Long|null} [timestamp] Transaction timestamp
                     * @property {Long|null} [expiration] Transaction expiration
                     * @property {TW.Tron.Proto.IBlockHeader|null} [blockHeader] Transaction blockHeader
                     * @property {Long|null} [feeLimit] Transaction feeLimit
                     * @property {TW.Tron.Proto.ITransferContract|null} [transfer] Transaction transfer
                     * @property {TW.Tron.Proto.ITransferAssetContract|null} [transferAsset] Transaction transferAsset
                     * @property {TW.Tron.Proto.IFreezeBalanceContract|null} [freezeBalance] Transaction freezeBalance
                     * @property {TW.Tron.Proto.IUnfreezeBalanceContract|null} [unfreezeBalance] Transaction unfreezeBalance
                     * @property {TW.Tron.Proto.IUnfreezeAssetContract|null} [unfreezeAsset] Transaction unfreezeAsset
                     * @property {TW.Tron.Proto.IWithdrawBalanceContract|null} [withdrawBalance] Transaction withdrawBalance
                     * @property {TW.Tron.Proto.IVoteAssetContract|null} [voteAsset] Transaction voteAsset
                     * @property {TW.Tron.Proto.IVoteWitnessContract|null} [voteWitness] Transaction voteWitness
                     * @property {TW.Tron.Proto.ITriggerSmartContract|null} [triggerSmartContract] Transaction triggerSmartContract
                     * @property {TW.Tron.Proto.ITransferTRC20Contract|null} [transferTrc20Contract] Transaction transferTrc20Contract
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Tron.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction expiration.
                     * @member {Long} expiration
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction blockHeader.
                     * @member {TW.Tron.Proto.IBlockHeader|null|undefined} blockHeader
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.blockHeader = null;
    
                    /**
                     * Transaction feeLimit.
                     * @member {Long} feeLimit
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.feeLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction transfer.
                     * @member {TW.Tron.Proto.ITransferContract|null|undefined} transfer
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.transfer = null;
    
                    /**
                     * Transaction transferAsset.
                     * @member {TW.Tron.Proto.ITransferAssetContract|null|undefined} transferAsset
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.transferAsset = null;
    
                    /**
                     * Transaction freezeBalance.
                     * @member {TW.Tron.Proto.IFreezeBalanceContract|null|undefined} freezeBalance
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.freezeBalance = null;
    
                    /**
                     * Transaction unfreezeBalance.
                     * @member {TW.Tron.Proto.IUnfreezeBalanceContract|null|undefined} unfreezeBalance
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.unfreezeBalance = null;
    
                    /**
                     * Transaction unfreezeAsset.
                     * @member {TW.Tron.Proto.IUnfreezeAssetContract|null|undefined} unfreezeAsset
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.unfreezeAsset = null;
    
                    /**
                     * Transaction withdrawBalance.
                     * @member {TW.Tron.Proto.IWithdrawBalanceContract|null|undefined} withdrawBalance
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.withdrawBalance = null;
    
                    /**
                     * Transaction voteAsset.
                     * @member {TW.Tron.Proto.IVoteAssetContract|null|undefined} voteAsset
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.voteAsset = null;
    
                    /**
                     * Transaction voteWitness.
                     * @member {TW.Tron.Proto.IVoteWitnessContract|null|undefined} voteWitness
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.voteWitness = null;
    
                    /**
                     * Transaction triggerSmartContract.
                     * @member {TW.Tron.Proto.ITriggerSmartContract|null|undefined} triggerSmartContract
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.triggerSmartContract = null;
    
                    /**
                     * Transaction transferTrc20Contract.
                     * @member {TW.Tron.Proto.ITransferTRC20Contract|null|undefined} transferTrc20Contract
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.transferTrc20Contract = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Transaction contractOneof.
                     * @member {"transfer"|"transferAsset"|"freezeBalance"|"unfreezeBalance"|"unfreezeAsset"|"withdrawBalance"|"voteAsset"|"voteWitness"|"triggerSmartContract"|"transferTrc20Contract"|undefined} contractOneof
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Object.defineProperty(Transaction.prototype, "contractOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "transferAsset", "freezeBalance", "unfreezeBalance", "unfreezeAsset", "withdrawBalance", "voteAsset", "voteWitness", "triggerSmartContract", "transferTrc20Contract"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {TW.Tron.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Tron.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {TW.Tron.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                        if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
                        if (message.blockHeader != null && Object.hasOwnProperty.call(message, "blockHeader"))
                            $root.TW.Tron.Proto.BlockHeader.encode(message.blockHeader, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.feeLimit != null && Object.hasOwnProperty.call(message, "feeLimit"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.feeLimit);
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.Tron.Proto.TransferContract.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.transferAsset != null && Object.hasOwnProperty.call(message, "transferAsset"))
                            $root.TW.Tron.Proto.TransferAssetContract.encode(message.transferAsset, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.freezeBalance != null && Object.hasOwnProperty.call(message, "freezeBalance"))
                            $root.TW.Tron.Proto.FreezeBalanceContract.encode(message.freezeBalance, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.unfreezeBalance != null && Object.hasOwnProperty.call(message, "unfreezeBalance"))
                            $root.TW.Tron.Proto.UnfreezeBalanceContract.encode(message.unfreezeBalance, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                        if (message.unfreezeAsset != null && Object.hasOwnProperty.call(message, "unfreezeAsset"))
                            $root.TW.Tron.Proto.UnfreezeAssetContract.encode(message.unfreezeAsset, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                        if (message.withdrawBalance != null && Object.hasOwnProperty.call(message, "withdrawBalance"))
                            $root.TW.Tron.Proto.WithdrawBalanceContract.encode(message.withdrawBalance, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                        if (message.voteAsset != null && Object.hasOwnProperty.call(message, "voteAsset"))
                            $root.TW.Tron.Proto.VoteAssetContract.encode(message.voteAsset, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                        if (message.voteWitness != null && Object.hasOwnProperty.call(message, "voteWitness"))
                            $root.TW.Tron.Proto.VoteWitnessContract.encode(message.voteWitness, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                        if (message.triggerSmartContract != null && Object.hasOwnProperty.call(message, "triggerSmartContract"))
                            $root.TW.Tron.Proto.TriggerSmartContract.encode(message.triggerSmartContract, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                        if (message.transferTrc20Contract != null && Object.hasOwnProperty.call(message, "transferTrc20Contract"))
                            $root.TW.Tron.Proto.TransferTRC20Contract.encode(message.transferTrc20Contract, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestamp = reader.int64();
                                break;
                            case 2:
                                message.expiration = reader.int64();
                                break;
                            case 3:
                                message.blockHeader = $root.TW.Tron.Proto.BlockHeader.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.feeLimit = reader.int64();
                                break;
                            case 10:
                                message.transfer = $root.TW.Tron.Proto.TransferContract.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.transferAsset = $root.TW.Tron.Proto.TransferAssetContract.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.freezeBalance = $root.TW.Tron.Proto.FreezeBalanceContract.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.unfreezeBalance = $root.TW.Tron.Proto.UnfreezeBalanceContract.decode(reader, reader.uint32());
                                break;
                            case 14:
                                message.unfreezeAsset = $root.TW.Tron.Proto.UnfreezeAssetContract.decode(reader, reader.uint32());
                                break;
                            case 15:
                                message.withdrawBalance = $root.TW.Tron.Proto.WithdrawBalanceContract.decode(reader, reader.uint32());
                                break;
                            case 16:
                                message.voteAsset = $root.TW.Tron.Proto.VoteAssetContract.decode(reader, reader.uint32());
                                break;
                            case 17:
                                message.voteWitness = $root.TW.Tron.Proto.VoteWitnessContract.decode(reader, reader.uint32());
                                break;
                            case 18:
                                message.triggerSmartContract = $root.TW.Tron.Proto.TriggerSmartContract.decode(reader, reader.uint32());
                                break;
                            case 19:
                                message.transferTrc20Contract = $root.TW.Tron.Proto.TransferTRC20Contract.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                                return "expiration: integer|Long expected";
                        if (message.blockHeader != null && message.hasOwnProperty("blockHeader")) {
                            var error = $root.TW.Tron.Proto.BlockHeader.verify(message.blockHeader);
                            if (error)
                                return "blockHeader." + error;
                        }
                        if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                            if (!$util.isInteger(message.feeLimit) && !(message.feeLimit && $util.isInteger(message.feeLimit.low) && $util.isInteger(message.feeLimit.high)))
                                return "feeLimit: integer|Long expected";
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.TransferContract.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.transferAsset != null && message.hasOwnProperty("transferAsset")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.TransferAssetContract.verify(message.transferAsset);
                                if (error)
                                    return "transferAsset." + error;
                            }
                        }
                        if (message.freezeBalance != null && message.hasOwnProperty("freezeBalance")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.FreezeBalanceContract.verify(message.freezeBalance);
                                if (error)
                                    return "freezeBalance." + error;
                            }
                        }
                        if (message.unfreezeBalance != null && message.hasOwnProperty("unfreezeBalance")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.UnfreezeBalanceContract.verify(message.unfreezeBalance);
                                if (error)
                                    return "unfreezeBalance." + error;
                            }
                        }
                        if (message.unfreezeAsset != null && message.hasOwnProperty("unfreezeAsset")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.UnfreezeAssetContract.verify(message.unfreezeAsset);
                                if (error)
                                    return "unfreezeAsset." + error;
                            }
                        }
                        if (message.withdrawBalance != null && message.hasOwnProperty("withdrawBalance")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.WithdrawBalanceContract.verify(message.withdrawBalance);
                                if (error)
                                    return "withdrawBalance." + error;
                            }
                        }
                        if (message.voteAsset != null && message.hasOwnProperty("voteAsset")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.VoteAssetContract.verify(message.voteAsset);
                                if (error)
                                    return "voteAsset." + error;
                            }
                        }
                        if (message.voteWitness != null && message.hasOwnProperty("voteWitness")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.VoteWitnessContract.verify(message.voteWitness);
                                if (error)
                                    return "voteWitness." + error;
                            }
                        }
                        if (message.triggerSmartContract != null && message.hasOwnProperty("triggerSmartContract")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.TriggerSmartContract.verify(message.triggerSmartContract);
                                if (error)
                                    return "triggerSmartContract." + error;
                            }
                        }
                        if (message.transferTrc20Contract != null && message.hasOwnProperty("transferTrc20Contract")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.TransferTRC20Contract.verify(message.transferTrc20Contract);
                                if (error)
                                    return "transferTrc20Contract." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Tron.Proto.Transaction();
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.expiration != null)
                            if ($util.Long)
                                (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                            else if (typeof object.expiration === "string")
                                message.expiration = parseInt(object.expiration, 10);
                            else if (typeof object.expiration === "number")
                                message.expiration = object.expiration;
                            else if (typeof object.expiration === "object")
                                message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                        if (object.blockHeader != null) {
                            if (typeof object.blockHeader !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.blockHeader: object expected");
                            message.blockHeader = $root.TW.Tron.Proto.BlockHeader.fromObject(object.blockHeader);
                        }
                        if (object.feeLimit != null)
                            if ($util.Long)
                                (message.feeLimit = $util.Long.fromValue(object.feeLimit)).unsigned = false;
                            else if (typeof object.feeLimit === "string")
                                message.feeLimit = parseInt(object.feeLimit, 10);
                            else if (typeof object.feeLimit === "number")
                                message.feeLimit = object.feeLimit;
                            else if (typeof object.feeLimit === "object")
                                message.feeLimit = new $util.LongBits(object.feeLimit.low >>> 0, object.feeLimit.high >>> 0).toNumber();
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.transfer: object expected");
                            message.transfer = $root.TW.Tron.Proto.TransferContract.fromObject(object.transfer);
                        }
                        if (object.transferAsset != null) {
                            if (typeof object.transferAsset !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.transferAsset: object expected");
                            message.transferAsset = $root.TW.Tron.Proto.TransferAssetContract.fromObject(object.transferAsset);
                        }
                        if (object.freezeBalance != null) {
                            if (typeof object.freezeBalance !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.freezeBalance: object expected");
                            message.freezeBalance = $root.TW.Tron.Proto.FreezeBalanceContract.fromObject(object.freezeBalance);
                        }
                        if (object.unfreezeBalance != null) {
                            if (typeof object.unfreezeBalance !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.unfreezeBalance: object expected");
                            message.unfreezeBalance = $root.TW.Tron.Proto.UnfreezeBalanceContract.fromObject(object.unfreezeBalance);
                        }
                        if (object.unfreezeAsset != null) {
                            if (typeof object.unfreezeAsset !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.unfreezeAsset: object expected");
                            message.unfreezeAsset = $root.TW.Tron.Proto.UnfreezeAssetContract.fromObject(object.unfreezeAsset);
                        }
                        if (object.withdrawBalance != null) {
                            if (typeof object.withdrawBalance !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.withdrawBalance: object expected");
                            message.withdrawBalance = $root.TW.Tron.Proto.WithdrawBalanceContract.fromObject(object.withdrawBalance);
                        }
                        if (object.voteAsset != null) {
                            if (typeof object.voteAsset !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.voteAsset: object expected");
                            message.voteAsset = $root.TW.Tron.Proto.VoteAssetContract.fromObject(object.voteAsset);
                        }
                        if (object.voteWitness != null) {
                            if (typeof object.voteWitness !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.voteWitness: object expected");
                            message.voteWitness = $root.TW.Tron.Proto.VoteWitnessContract.fromObject(object.voteWitness);
                        }
                        if (object.triggerSmartContract != null) {
                            if (typeof object.triggerSmartContract !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.triggerSmartContract: object expected");
                            message.triggerSmartContract = $root.TW.Tron.Proto.TriggerSmartContract.fromObject(object.triggerSmartContract);
                        }
                        if (object.transferTrc20Contract != null) {
                            if (typeof object.transferTrc20Contract !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.transferTrc20Contract: object expected");
                            message.transferTrc20Contract = $root.TW.Tron.Proto.TransferTRC20Contract.fromObject(object.transferTrc20Contract);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {TW.Tron.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.expiration = options.longs === String ? "0" : 0;
                            object.blockHeader = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.feeLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.feeLimit = options.longs === String ? "0" : 0;
                        }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (typeof message.expiration === "number")
                                object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                            else
                                object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                        if (message.blockHeader != null && message.hasOwnProperty("blockHeader"))
                            object.blockHeader = $root.TW.Tron.Proto.BlockHeader.toObject(message.blockHeader, options);
                        if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                            if (typeof message.feeLimit === "number")
                                object.feeLimit = options.longs === String ? String(message.feeLimit) : message.feeLimit;
                            else
                                object.feeLimit = options.longs === String ? $util.Long.prototype.toString.call(message.feeLimit) : options.longs === Number ? new $util.LongBits(message.feeLimit.low >>> 0, message.feeLimit.high >>> 0).toNumber() : message.feeLimit;
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.Tron.Proto.TransferContract.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.contractOneof = "transfer";
                        }
                        if (message.transferAsset != null && message.hasOwnProperty("transferAsset")) {
                            object.transferAsset = $root.TW.Tron.Proto.TransferAssetContract.toObject(message.transferAsset, options);
                            if (options.oneofs)
                                object.contractOneof = "transferAsset";
                        }
                        if (message.freezeBalance != null && message.hasOwnProperty("freezeBalance")) {
                            object.freezeBalance = $root.TW.Tron.Proto.FreezeBalanceContract.toObject(message.freezeBalance, options);
                            if (options.oneofs)
                                object.contractOneof = "freezeBalance";
                        }
                        if (message.unfreezeBalance != null && message.hasOwnProperty("unfreezeBalance")) {
                            object.unfreezeBalance = $root.TW.Tron.Proto.UnfreezeBalanceContract.toObject(message.unfreezeBalance, options);
                            if (options.oneofs)
                                object.contractOneof = "unfreezeBalance";
                        }
                        if (message.unfreezeAsset != null && message.hasOwnProperty("unfreezeAsset")) {
                            object.unfreezeAsset = $root.TW.Tron.Proto.UnfreezeAssetContract.toObject(message.unfreezeAsset, options);
                            if (options.oneofs)
                                object.contractOneof = "unfreezeAsset";
                        }
                        if (message.withdrawBalance != null && message.hasOwnProperty("withdrawBalance")) {
                            object.withdrawBalance = $root.TW.Tron.Proto.WithdrawBalanceContract.toObject(message.withdrawBalance, options);
                            if (options.oneofs)
                                object.contractOneof = "withdrawBalance";
                        }
                        if (message.voteAsset != null && message.hasOwnProperty("voteAsset")) {
                            object.voteAsset = $root.TW.Tron.Proto.VoteAssetContract.toObject(message.voteAsset, options);
                            if (options.oneofs)
                                object.contractOneof = "voteAsset";
                        }
                        if (message.voteWitness != null && message.hasOwnProperty("voteWitness")) {
                            object.voteWitness = $root.TW.Tron.Proto.VoteWitnessContract.toObject(message.voteWitness, options);
                            if (options.oneofs)
                                object.contractOneof = "voteWitness";
                        }
                        if (message.triggerSmartContract != null && message.hasOwnProperty("triggerSmartContract")) {
                            object.triggerSmartContract = $root.TW.Tron.Proto.TriggerSmartContract.toObject(message.triggerSmartContract, options);
                            if (options.oneofs)
                                object.contractOneof = "triggerSmartContract";
                        }
                        if (message.transferTrc20Contract != null && message.hasOwnProperty("transferTrc20Contract")) {
                            object.transferTrc20Contract = $root.TW.Tron.Proto.TransferTRC20Contract.toObject(message.transferTrc20Contract, options);
                            if (options.oneofs)
                                object.contractOneof = "transferTrc20Contract";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Tron.Proto
                     * @interface ISigningInput
                     * @property {TW.Tron.Proto.ITransaction|null} [transaction] SigningInput transaction
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Tron.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput transaction.
                     * @member {TW.Tron.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Tron.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transaction = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Tron.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {TW.Tron.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Tron.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {TW.Tron.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                            $root.TW.Tron.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.TW.Tron.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Tron.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Tron.Proto.SigningInput();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Tron.Proto.SigningInput.transaction: object expected");
                            message.transaction = $root.TW.Tron.Proto.Transaction.fromObject(object.transaction);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {TW.Tron.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Tron.Proto.Transaction.toObject(message.transaction, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Tron.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [id] SigningOutput id
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {Uint8Array|null} [refBlockBytes] SigningOutput refBlockBytes
                     * @property {Uint8Array|null} [refBlockHash] SigningOutput refBlockHash
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Tron.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput id.
                     * @member {Uint8Array} id
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.id = $util.newBuffer([]);
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput refBlockBytes.
                     * @member {Uint8Array} refBlockBytes
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.refBlockBytes = $util.newBuffer([]);
    
                    /**
                     * SigningOutput refBlockHash.
                     * @member {Uint8Array} refBlockHash
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.refBlockHash = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {TW.Tron.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Tron.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {TW.Tron.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        if (message.refBlockBytes != null && Object.hasOwnProperty.call(message, "refBlockBytes"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.refBlockBytes);
                        if (message.refBlockHash != null && Object.hasOwnProperty.call(message, "refBlockHash"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.refBlockHash);
                        if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            case 3:
                                message.refBlockBytes = reader.bytes();
                                break;
                            case 4:
                                message.refBlockHash = reader.bytes();
                                break;
                            case 5:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                                return "id: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                            if (!(message.refBlockBytes && typeof message.refBlockBytes.length === "number" || $util.isString(message.refBlockBytes)))
                                return "refBlockBytes: buffer expected";
                        if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                            if (!(message.refBlockHash && typeof message.refBlockHash.length === "number" || $util.isString(message.refBlockHash)))
                                return "refBlockHash: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Tron.Proto.SigningOutput();
                        if (object.id != null)
                            if (typeof object.id === "string")
                                $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                            else if (object.id.length)
                                message.id = object.id;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.refBlockBytes != null)
                            if (typeof object.refBlockBytes === "string")
                                $util.base64.decode(object.refBlockBytes, message.refBlockBytes = $util.newBuffer($util.base64.length(object.refBlockBytes)), 0);
                            else if (object.refBlockBytes.length)
                                message.refBlockBytes = object.refBlockBytes;
                        if (object.refBlockHash != null)
                            if (typeof object.refBlockHash === "string")
                                $util.base64.decode(object.refBlockHash, message.refBlockHash = $util.newBuffer($util.base64.length(object.refBlockHash)), 0);
                            else if (object.refBlockHash.length)
                                message.refBlockHash = object.refBlockHash;
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {TW.Tron.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.id = "";
                            else {
                                object.id = [];
                                if (options.bytes !== Array)
                                    object.id = $util.newBuffer(object.id);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            if (options.bytes === String)
                                object.refBlockBytes = "";
                            else {
                                object.refBlockBytes = [];
                                if (options.bytes !== Array)
                                    object.refBlockBytes = $util.newBuffer(object.refBlockBytes);
                            }
                            if (options.bytes === String)
                                object.refBlockHash = "";
                            else {
                                object.refBlockHash = [];
                                if (options.bytes !== Array)
                                    object.refBlockHash = $util.newBuffer(object.refBlockHash);
                            }
                            object.json = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                            object.refBlockBytes = options.bytes === String ? $util.base64.encode(message.refBlockBytes, 0, message.refBlockBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockBytes) : message.refBlockBytes;
                        if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                            object.refBlockHash = options.bytes === String ? $util.base64.encode(message.refBlockHash, 0, message.refBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockHash) : message.refBlockHash;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Tron;
        })();
    
        TW.VeChain = (function() {
    
            /**
             * Namespace VeChain.
             * @memberof TW
             * @namespace
             */
            var VeChain = {};
    
            VeChain.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.VeChain
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Clause = (function() {
    
                    /**
                     * Properties of a Clause.
                     * @memberof TW.VeChain.Proto
                     * @interface IClause
                     * @property {string|null} [to] Recipient address.
                     * @property {Uint8Array|null} [value] Transaction amount.
                     * @property {Uint8Array|null} [data] Payload data.
                     */
    
                    /**
                     * Constructs a new Clause.
                     * @memberof TW.VeChain.Proto
                     * @classdesc Represents a Clause.
                     * @implements IClause
                     * @constructor
                     * @param {TW.VeChain.Proto.IClause=} [properties] Properties to set
                     */
                    function Clause(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Recipient address.
                     * @member {string} to
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     */
                    Clause.prototype.to = "";
    
                    /**
                     * Transaction amount.
                     * @member {Uint8Array} value
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     */
                    Clause.prototype.value = $util.newBuffer([]);
    
                    /**
                     * Payload data.
                     * @member {Uint8Array} data
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     */
                    Clause.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new Clause instance using the specified properties.
                     * @function create
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {TW.VeChain.Proto.IClause=} [properties] Properties to set
                     * @returns {TW.VeChain.Proto.Clause} Clause instance
                     */
                    Clause.create = function create(properties) {
                        return new Clause(properties);
                    };
    
                    /**
                     * Encodes the specified Clause message. Does not implicitly {@link TW.VeChain.Proto.Clause.verify|verify} messages.
                     * @function encode
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {TW.VeChain.Proto.IClause} message Clause message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Clause.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.to);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Decodes a Clause message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.VeChain.Proto.Clause} Clause
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Clause.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.VeChain.Proto.Clause();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.to = reader.string();
                                break;
                            case 2:
                                message.value = reader.bytes();
                                break;
                            case 3:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Clause message.
                     * @function verify
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Clause.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Clause message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.VeChain.Proto.Clause} Clause
                     */
                    Clause.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.VeChain.Proto.Clause)
                            return object;
                        var message = new $root.TW.VeChain.Proto.Clause();
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Clause message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {TW.VeChain.Proto.Clause} message Clause
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Clause.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.to = "";
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this Clause to JSON.
                     * @function toJSON
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Clause.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Clause;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.VeChain.Proto
                     * @interface ISigningInput
                     * @property {number|null} [chainTag] Last byte of the genesis block ID which is used to identify a blockchain to prevent the cross-chain replay attack.
                     * @property {Long|null} [blockRef] Reference to a specific block.
                     * @property {number|null} [expiration] How long, in terms of the number of blocks, the transaction will be allowed to be mined in VeChainThor.
                     * @property {Array.<TW.VeChain.Proto.IClause>|null} [clauses] by the transaction sender.
                     * @property {number|null} [gasPriceCoef] Coefficient used to calculate the gas price for the transaction.
                     * @property {Long|null} [gas] Maximum amount of gas allowed to pay for the transaction.
                     * @property {Uint8Array|null} [dependsOn] ID of the transaction on which the current transaction depends.
                     * @property {Long|null} [nonce] Number set by user.
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.VeChain.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.VeChain.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.clauses = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Last byte of the genesis block ID which is used to identify a blockchain to prevent the cross-chain replay attack.
                     * @member {number} chainTag
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainTag = 0;
    
                    /**
                     * Reference to a specific block.
                     * @member {Long} blockRef
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.blockRef = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * How long, in terms of the number of blocks, the transaction will be allowed to be mined in VeChainThor.
                     * @member {number} expiration
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.expiration = 0;
    
                    /**
                     * by the transaction sender.
                     * @member {Array.<TW.VeChain.Proto.IClause>} clauses
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.clauses = $util.emptyArray;
    
                    /**
                     * Coefficient used to calculate the gas price for the transaction.
                     * @member {number} gasPriceCoef
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPriceCoef = 0;
    
                    /**
                     * Maximum amount of gas allowed to pay for the transaction.
                     * @member {Long} gas
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ID of the transaction on which the current transaction depends.
                     * @member {Uint8Array} dependsOn
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.dependsOn = $util.newBuffer([]);
    
                    /**
                     * Number set by user.
                     * @member {Long} nonce
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.VeChain.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.VeChain.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainTag != null && Object.hasOwnProperty.call(message, "chainTag"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chainTag);
                        if (message.blockRef != null && Object.hasOwnProperty.call(message, "blockRef"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.blockRef);
                        if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expiration);
                        if (message.clauses != null && message.clauses.length)
                            for (var i = 0; i < message.clauses.length; ++i)
                                $root.TW.VeChain.Proto.Clause.encode(message.clauses[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.gasPriceCoef != null && Object.hasOwnProperty.call(message, "gasPriceCoef"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.gasPriceCoef);
                        if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.gas);
                        if (message.dependsOn != null && Object.hasOwnProperty.call(message, "dependsOn"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.dependsOn);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.nonce);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.VeChain.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.VeChain.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainTag = reader.uint32();
                                break;
                            case 2:
                                message.blockRef = reader.uint64();
                                break;
                            case 3:
                                message.expiration = reader.uint32();
                                break;
                            case 4:
                                if (!(message.clauses && message.clauses.length))
                                    message.clauses = [];
                                message.clauses.push($root.TW.VeChain.Proto.Clause.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.gasPriceCoef = reader.uint32();
                                break;
                            case 6:
                                message.gas = reader.uint64();
                                break;
                            case 7:
                                message.dependsOn = reader.bytes();
                                break;
                            case 8:
                                message.nonce = reader.uint64();
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainTag != null && message.hasOwnProperty("chainTag"))
                            if (!$util.isInteger(message.chainTag))
                                return "chainTag: integer expected";
                        if (message.blockRef != null && message.hasOwnProperty("blockRef"))
                            if (!$util.isInteger(message.blockRef) && !(message.blockRef && $util.isInteger(message.blockRef.low) && $util.isInteger(message.blockRef.high)))
                                return "blockRef: integer|Long expected";
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (!$util.isInteger(message.expiration))
                                return "expiration: integer expected";
                        if (message.clauses != null && message.hasOwnProperty("clauses")) {
                            if (!Array.isArray(message.clauses))
                                return "clauses: array expected";
                            for (var i = 0; i < message.clauses.length; ++i) {
                                var error = $root.TW.VeChain.Proto.Clause.verify(message.clauses[i]);
                                if (error)
                                    return "clauses." + error;
                            }
                        }
                        if (message.gasPriceCoef != null && message.hasOwnProperty("gasPriceCoef"))
                            if (!$util.isInteger(message.gasPriceCoef))
                                return "gasPriceCoef: integer expected";
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
                                return "gas: integer|Long expected";
                        if (message.dependsOn != null && message.hasOwnProperty("dependsOn"))
                            if (!(message.dependsOn && typeof message.dependsOn.length === "number" || $util.isString(message.dependsOn)))
                                return "dependsOn: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.VeChain.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.VeChain.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.VeChain.Proto.SigningInput();
                        if (object.chainTag != null)
                            message.chainTag = object.chainTag >>> 0;
                        if (object.blockRef != null)
                            if ($util.Long)
                                (message.blockRef = $util.Long.fromValue(object.blockRef)).unsigned = true;
                            else if (typeof object.blockRef === "string")
                                message.blockRef = parseInt(object.blockRef, 10);
                            else if (typeof object.blockRef === "number")
                                message.blockRef = object.blockRef;
                            else if (typeof object.blockRef === "object")
                                message.blockRef = new $util.LongBits(object.blockRef.low >>> 0, object.blockRef.high >>> 0).toNumber(true);
                        if (object.expiration != null)
                            message.expiration = object.expiration >>> 0;
                        if (object.clauses) {
                            if (!Array.isArray(object.clauses))
                                throw TypeError(".TW.VeChain.Proto.SigningInput.clauses: array expected");
                            message.clauses = [];
                            for (var i = 0; i < object.clauses.length; ++i) {
                                if (typeof object.clauses[i] !== "object")
                                    throw TypeError(".TW.VeChain.Proto.SigningInput.clauses: object expected");
                                message.clauses[i] = $root.TW.VeChain.Proto.Clause.fromObject(object.clauses[i]);
                            }
                        }
                        if (object.gasPriceCoef != null)
                            message.gasPriceCoef = object.gasPriceCoef >>> 0;
                        if (object.gas != null)
                            if ($util.Long)
                                (message.gas = $util.Long.fromValue(object.gas)).unsigned = true;
                            else if (typeof object.gas === "string")
                                message.gas = parseInt(object.gas, 10);
                            else if (typeof object.gas === "number")
                                message.gas = object.gas;
                            else if (typeof object.gas === "object")
                                message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber(true);
                        if (object.dependsOn != null)
                            if (typeof object.dependsOn === "string")
                                $util.base64.decode(object.dependsOn, message.dependsOn = $util.newBuffer($util.base64.length(object.dependsOn)), 0);
                            else if (object.dependsOn.length)
                                message.dependsOn = object.dependsOn;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {TW.VeChain.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.clauses = [];
                        if (options.defaults) {
                            object.chainTag = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.blockRef = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.blockRef = options.longs === String ? "0" : 0;
                            object.expiration = 0;
                            object.gasPriceCoef = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gas = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.dependsOn = "";
                            else {
                                object.dependsOn = [];
                                if (options.bytes !== Array)
                                    object.dependsOn = $util.newBuffer(object.dependsOn);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainTag != null && message.hasOwnProperty("chainTag"))
                            object.chainTag = message.chainTag;
                        if (message.blockRef != null && message.hasOwnProperty("blockRef"))
                            if (typeof message.blockRef === "number")
                                object.blockRef = options.longs === String ? String(message.blockRef) : message.blockRef;
                            else
                                object.blockRef = options.longs === String ? $util.Long.prototype.toString.call(message.blockRef) : options.longs === Number ? new $util.LongBits(message.blockRef.low >>> 0, message.blockRef.high >>> 0).toNumber(true) : message.blockRef;
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            object.expiration = message.expiration;
                        if (message.clauses && message.clauses.length) {
                            object.clauses = [];
                            for (var j = 0; j < message.clauses.length; ++j)
                                object.clauses[j] = $root.TW.VeChain.Proto.Clause.toObject(message.clauses[j], options);
                        }
                        if (message.gasPriceCoef != null && message.hasOwnProperty("gasPriceCoef"))
                            object.gasPriceCoef = message.gasPriceCoef;
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (typeof message.gas === "number")
                                object.gas = options.longs === String ? String(message.gas) : message.gas;
                            else
                                object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber(true) : message.gas;
                        if (message.dependsOn != null && message.hasOwnProperty("dependsOn"))
                            object.dependsOn = options.bytes === String ? $util.base64.encode(message.dependsOn, 0, message.dependsOn.length) : options.bytes === Array ? Array.prototype.slice.call(message.dependsOn) : message.dependsOn;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.VeChain.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.VeChain.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.VeChain.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.VeChain.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.VeChain.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && Object.hasOwnProperty.call(message, "encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.VeChain.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.VeChain.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.VeChain.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.VeChain.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.VeChain.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {TW.VeChain.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return VeChain;
        })();
    
        TW.Waves = (function() {
    
            /**
             * Namespace Waves.
             * @memberof TW
             * @namespace
             */
            var Waves = {};
    
            Waves.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Waves
                 * @namespace
                 */
                var Proto = {};
    
                Proto.TransferMessage = (function() {
    
                    /**
                     * Properties of a TransferMessage.
                     * @memberof TW.Waves.Proto
                     * @interface ITransferMessage
                     * @property {Long|null} [amount] TransferMessage amount
                     * @property {string|null} [asset] TransferMessage asset
                     * @property {Long|null} [fee] TransferMessage fee
                     * @property {string|null} [feeAsset] TransferMessage feeAsset
                     * @property {string|null} [to] TransferMessage to
                     * @property {Uint8Array|null} [attachment] TransferMessage attachment
                     */
    
                    /**
                     * Constructs a new TransferMessage.
                     * @memberof TW.Waves.Proto
                     * @classdesc Represents a TransferMessage.
                     * @implements ITransferMessage
                     * @constructor
                     * @param {TW.Waves.Proto.ITransferMessage=} [properties] Properties to set
                     */
                    function TransferMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferMessage amount.
                     * @member {Long} amount
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransferMessage asset.
                     * @member {string} asset
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.asset = "";
    
                    /**
                     * TransferMessage fee.
                     * @member {Long} fee
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransferMessage feeAsset.
                     * @member {string} feeAsset
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.feeAsset = "";
    
                    /**
                     * TransferMessage to.
                     * @member {string} to
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.to = "";
    
                    /**
                     * TransferMessage attachment.
                     * @member {Uint8Array} attachment
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @instance
                     */
                    TransferMessage.prototype.attachment = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransferMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @static
                     * @param {TW.Waves.Proto.ITransferMessage=} [properties] Properties to set
                     * @returns {TW.Waves.Proto.TransferMessage} TransferMessage instance
                     */
                    TransferMessage.create = function create(properties) {
                        return new TransferMessage(properties);
                    };
    
                    /**
                     * Encodes the specified TransferMessage message. Does not implicitly {@link TW.Waves.Proto.TransferMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @static
                     * @param {TW.Waves.Proto.ITransferMessage} message TransferMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.asset);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.feeAsset != null && Object.hasOwnProperty.call(message, "feeAsset"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.feeAsset);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.to);
                        if (message.attachment != null && Object.hasOwnProperty.call(message, "attachment"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.attachment);
                        return writer;
                    };
    
                    /**
                     * Decodes a TransferMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Waves.Proto.TransferMessage} TransferMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Waves.Proto.TransferMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.asset = reader.string();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.feeAsset = reader.string();
                                break;
                            case 5:
                                message.to = reader.string();
                                break;
                            case 6:
                                message.attachment = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a TransferMessage message.
                     * @function verify
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            if (!$util.isString(message.asset))
                                return "asset: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.feeAsset != null && message.hasOwnProperty("feeAsset"))
                            if (!$util.isString(message.feeAsset))
                                return "feeAsset: string expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.attachment != null && message.hasOwnProperty("attachment"))
                            if (!(message.attachment && typeof message.attachment.length === "number" || $util.isString(message.attachment)))
                                return "attachment: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Waves.Proto.TransferMessage} TransferMessage
                     */
                    TransferMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Waves.Proto.TransferMessage)
                            return object;
                        var message = new $root.TW.Waves.Proto.TransferMessage();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.asset != null)
                            message.asset = String(object.asset);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.feeAsset != null)
                            message.feeAsset = String(object.feeAsset);
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.attachment != null)
                            if (typeof object.attachment === "string")
                                $util.base64.decode(object.attachment, message.attachment = $util.newBuffer($util.base64.length(object.attachment)), 0);
                            else if (object.attachment.length)
                                message.attachment = object.attachment;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @static
                     * @param {TW.Waves.Proto.TransferMessage} message TransferMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.asset = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.feeAsset = "";
                            object.to = "";
                            if (options.bytes === String)
                                object.attachment = "";
                            else {
                                object.attachment = [];
                                if (options.bytes !== Array)
                                    object.attachment = $util.newBuffer(object.attachment);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            object.asset = message.asset;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.feeAsset != null && message.hasOwnProperty("feeAsset"))
                            object.feeAsset = message.feeAsset;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.attachment != null && message.hasOwnProperty("attachment"))
                            object.attachment = options.bytes === String ? $util.base64.encode(message.attachment, 0, message.attachment.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachment) : message.attachment;
                        return object;
                    };
    
                    /**
                     * Converts this TransferMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Waves.Proto.TransferMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferMessage;
                })();
    
                Proto.LeaseMessage = (function() {
    
                    /**
                     * Properties of a LeaseMessage.
                     * @memberof TW.Waves.Proto
                     * @interface ILeaseMessage
                     * @property {Long|null} [amount] LeaseMessage amount
                     * @property {string|null} [to] LeaseMessage to
                     * @property {Long|null} [fee] LeaseMessage fee
                     */
    
                    /**
                     * Constructs a new LeaseMessage.
                     * @memberof TW.Waves.Proto
                     * @classdesc Represents a LeaseMessage.
                     * @implements ILeaseMessage
                     * @constructor
                     * @param {TW.Waves.Proto.ILeaseMessage=} [properties] Properties to set
                     */
                    function LeaseMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * LeaseMessage amount.
                     * @member {Long} amount
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @instance
                     */
                    LeaseMessage.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * LeaseMessage to.
                     * @member {string} to
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @instance
                     */
                    LeaseMessage.prototype.to = "";
    
                    /**
                     * LeaseMessage fee.
                     * @member {Long} fee
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @instance
                     */
                    LeaseMessage.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new LeaseMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @static
                     * @param {TW.Waves.Proto.ILeaseMessage=} [properties] Properties to set
                     * @returns {TW.Waves.Proto.LeaseMessage} LeaseMessage instance
                     */
                    LeaseMessage.create = function create(properties) {
                        return new LeaseMessage(properties);
                    };
    
                    /**
                     * Encodes the specified LeaseMessage message. Does not implicitly {@link TW.Waves.Proto.LeaseMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @static
                     * @param {TW.Waves.Proto.ILeaseMessage} message LeaseMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LeaseMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.to);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        return writer;
                    };
    
                    /**
                     * Decodes a LeaseMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Waves.Proto.LeaseMessage} LeaseMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LeaseMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Waves.Proto.LeaseMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.to = reader.string();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a LeaseMessage message.
                     * @function verify
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LeaseMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a LeaseMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Waves.Proto.LeaseMessage} LeaseMessage
                     */
                    LeaseMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Waves.Proto.LeaseMessage)
                            return object;
                        var message = new $root.TW.Waves.Proto.LeaseMessage();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a LeaseMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @static
                     * @param {TW.Waves.Proto.LeaseMessage} message LeaseMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LeaseMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.to = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        return object;
                    };
    
                    /**
                     * Converts this LeaseMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Waves.Proto.LeaseMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LeaseMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return LeaseMessage;
                })();
    
                Proto.CancelLeaseMessage = (function() {
    
                    /**
                     * Properties of a CancelLeaseMessage.
                     * @memberof TW.Waves.Proto
                     * @interface ICancelLeaseMessage
                     * @property {string|null} [leaseId] CancelLeaseMessage leaseId
                     * @property {Long|null} [fee] CancelLeaseMessage fee
                     */
    
                    /**
                     * Constructs a new CancelLeaseMessage.
                     * @memberof TW.Waves.Proto
                     * @classdesc Represents a CancelLeaseMessage.
                     * @implements ICancelLeaseMessage
                     * @constructor
                     * @param {TW.Waves.Proto.ICancelLeaseMessage=} [properties] Properties to set
                     */
                    function CancelLeaseMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CancelLeaseMessage leaseId.
                     * @member {string} leaseId
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @instance
                     */
                    CancelLeaseMessage.prototype.leaseId = "";
    
                    /**
                     * CancelLeaseMessage fee.
                     * @member {Long} fee
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @instance
                     */
                    CancelLeaseMessage.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new CancelLeaseMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @static
                     * @param {TW.Waves.Proto.ICancelLeaseMessage=} [properties] Properties to set
                     * @returns {TW.Waves.Proto.CancelLeaseMessage} CancelLeaseMessage instance
                     */
                    CancelLeaseMessage.create = function create(properties) {
                        return new CancelLeaseMessage(properties);
                    };
    
                    /**
                     * Encodes the specified CancelLeaseMessage message. Does not implicitly {@link TW.Waves.Proto.CancelLeaseMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @static
                     * @param {TW.Waves.Proto.ICancelLeaseMessage} message CancelLeaseMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CancelLeaseMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.leaseId != null && Object.hasOwnProperty.call(message, "leaseId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.leaseId);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fee);
                        return writer;
                    };
    
                    /**
                     * Decodes a CancelLeaseMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Waves.Proto.CancelLeaseMessage} CancelLeaseMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CancelLeaseMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Waves.Proto.CancelLeaseMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.leaseId = reader.string();
                                break;
                            case 2:
                                message.fee = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a CancelLeaseMessage message.
                     * @function verify
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CancelLeaseMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.leaseId != null && message.hasOwnProperty("leaseId"))
                            if (!$util.isString(message.leaseId))
                                return "leaseId: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a CancelLeaseMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Waves.Proto.CancelLeaseMessage} CancelLeaseMessage
                     */
                    CancelLeaseMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Waves.Proto.CancelLeaseMessage)
                            return object;
                        var message = new $root.TW.Waves.Proto.CancelLeaseMessage();
                        if (object.leaseId != null)
                            message.leaseId = String(object.leaseId);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CancelLeaseMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @static
                     * @param {TW.Waves.Proto.CancelLeaseMessage} message CancelLeaseMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CancelLeaseMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.leaseId = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                        }
                        if (message.leaseId != null && message.hasOwnProperty("leaseId"))
                            object.leaseId = message.leaseId;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        return object;
                    };
    
                    /**
                     * Converts this CancelLeaseMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Waves.Proto.CancelLeaseMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CancelLeaseMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CancelLeaseMessage;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Waves.Proto
                     * @interface ISigningInput
                     * @property {Long|null} [timestamp] SigningInput timestamp
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Waves.Proto.ITransferMessage|null} [transferMessage] SigningInput transferMessage
                     * @property {TW.Waves.Proto.ILeaseMessage|null} [leaseMessage] SigningInput leaseMessage
                     * @property {TW.Waves.Proto.ICancelLeaseMessage|null} [cancelLeaseMessage] SigningInput cancelLeaseMessage
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Waves.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Waves.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput transferMessage.
                     * @member {TW.Waves.Proto.ITransferMessage|null|undefined} transferMessage
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transferMessage = null;
    
                    /**
                     * SigningInput leaseMessage.
                     * @member {TW.Waves.Proto.ILeaseMessage|null|undefined} leaseMessage
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.leaseMessage = null;
    
                    /**
                     * SigningInput cancelLeaseMessage.
                     * @member {TW.Waves.Proto.ICancelLeaseMessage|null|undefined} cancelLeaseMessage
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.cancelLeaseMessage = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput messageOneof.
                     * @member {"transferMessage"|"leaseMessage"|"cancelLeaseMessage"|undefined} messageOneof
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transferMessage", "leaseMessage", "cancelLeaseMessage"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {TW.Waves.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Waves.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Waves.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {TW.Waves.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                        if (message.transferMessage != null && Object.hasOwnProperty.call(message, "transferMessage"))
                            $root.TW.Waves.Proto.TransferMessage.encode(message.transferMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.leaseMessage != null && Object.hasOwnProperty.call(message, "leaseMessage"))
                            $root.TW.Waves.Proto.LeaseMessage.encode(message.leaseMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.cancelLeaseMessage != null && Object.hasOwnProperty.call(message, "cancelLeaseMessage"))
                            $root.TW.Waves.Proto.CancelLeaseMessage.encode(message.cancelLeaseMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Waves.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Waves.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestamp = reader.int64();
                                break;
                            case 2:
                                message.privateKey = reader.bytes();
                                break;
                            case 3:
                                message.transferMessage = $root.TW.Waves.Proto.TransferMessage.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.leaseMessage = $root.TW.Waves.Proto.LeaseMessage.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.cancelLeaseMessage = $root.TW.Waves.Proto.CancelLeaseMessage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.transferMessage != null && message.hasOwnProperty("transferMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Waves.Proto.TransferMessage.verify(message.transferMessage);
                                if (error)
                                    return "transferMessage." + error;
                            }
                        }
                        if (message.leaseMessage != null && message.hasOwnProperty("leaseMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Waves.Proto.LeaseMessage.verify(message.leaseMessage);
                                if (error)
                                    return "leaseMessage." + error;
                            }
                        }
                        if (message.cancelLeaseMessage != null && message.hasOwnProperty("cancelLeaseMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Waves.Proto.CancelLeaseMessage.verify(message.cancelLeaseMessage);
                                if (error)
                                    return "cancelLeaseMessage." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Waves.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Waves.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Waves.Proto.SigningInput();
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.transferMessage != null) {
                            if (typeof object.transferMessage !== "object")
                                throw TypeError(".TW.Waves.Proto.SigningInput.transferMessage: object expected");
                            message.transferMessage = $root.TW.Waves.Proto.TransferMessage.fromObject(object.transferMessage);
                        }
                        if (object.leaseMessage != null) {
                            if (typeof object.leaseMessage !== "object")
                                throw TypeError(".TW.Waves.Proto.SigningInput.leaseMessage: object expected");
                            message.leaseMessage = $root.TW.Waves.Proto.LeaseMessage.fromObject(object.leaseMessage);
                        }
                        if (object.cancelLeaseMessage != null) {
                            if (typeof object.cancelLeaseMessage !== "object")
                                throw TypeError(".TW.Waves.Proto.SigningInput.cancelLeaseMessage: object expected");
                            message.cancelLeaseMessage = $root.TW.Waves.Proto.CancelLeaseMessage.fromObject(object.cancelLeaseMessage);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {TW.Waves.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.transferMessage != null && message.hasOwnProperty("transferMessage")) {
                            object.transferMessage = $root.TW.Waves.Proto.TransferMessage.toObject(message.transferMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "transferMessage";
                        }
                        if (message.leaseMessage != null && message.hasOwnProperty("leaseMessage")) {
                            object.leaseMessage = $root.TW.Waves.Proto.LeaseMessage.toObject(message.leaseMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "leaseMessage";
                        }
                        if (message.cancelLeaseMessage != null && message.hasOwnProperty("cancelLeaseMessage")) {
                            object.cancelLeaseMessage = $root.TW.Waves.Proto.CancelLeaseMessage.toObject(message.cancelLeaseMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "cancelLeaseMessage";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Waves.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Waves.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Waves.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {TW.Waves.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Waves.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Waves.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {TW.Waves.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Waves.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Waves.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Waves.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Waves.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Waves.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {TW.Waves.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.json = "";
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Waves;
        })();
    
        TW.Zilliqa = (function() {
    
            /**
             * Namespace Zilliqa.
             * @memberof TW
             * @namespace
             */
            var Zilliqa = {};
    
            Zilliqa.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Zilliqa
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Zilliqa.Proto
                     * @interface ITransaction
                     * @property {TW.Zilliqa.Proto.Transaction.ITransfer|null} [transfer] Transaction transfer
                     * @property {TW.Zilliqa.Proto.Transaction.IRaw|null} [rawTransaction] Transaction rawTransaction
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Zilliqa.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Zilliqa.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction transfer.
                     * @member {TW.Zilliqa.Proto.Transaction.ITransfer|null|undefined} transfer
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.transfer = null;
    
                    /**
                     * Transaction rawTransaction.
                     * @member {TW.Zilliqa.Proto.Transaction.IRaw|null|undefined} rawTransaction
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.rawTransaction = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Transaction messageOneof.
                     * @member {"transfer"|"rawTransaction"|undefined} messageOneof
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @instance
                     */
                    Object.defineProperty(Transaction.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "rawTransaction"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @static
                     * @param {TW.Zilliqa.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Zilliqa.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Zilliqa.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @static
                     * @param {TW.Zilliqa.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                            $root.TW.Zilliqa.Proto.Transaction.Transfer.encode(message.transfer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.rawTransaction != null && Object.hasOwnProperty.call(message, "rawTransaction"))
                            $root.TW.Zilliqa.Proto.Transaction.Raw.encode(message.rawTransaction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Zilliqa.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Zilliqa.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transfer = $root.TW.Zilliqa.Proto.Transaction.Transfer.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.rawTransaction = $root.TW.Zilliqa.Proto.Transaction.Raw.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Zilliqa.Proto.Transaction.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.rawTransaction != null && message.hasOwnProperty("rawTransaction")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Zilliqa.Proto.Transaction.Raw.verify(message.rawTransaction);
                                if (error)
                                    return "rawTransaction." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Zilliqa.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Zilliqa.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Zilliqa.Proto.Transaction();
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.Zilliqa.Proto.Transaction.transfer: object expected");
                            message.transfer = $root.TW.Zilliqa.Proto.Transaction.Transfer.fromObject(object.transfer);
                        }
                        if (object.rawTransaction != null) {
                            if (typeof object.rawTransaction !== "object")
                                throw TypeError(".TW.Zilliqa.Proto.Transaction.rawTransaction: object expected");
                            message.rawTransaction = $root.TW.Zilliqa.Proto.Transaction.Raw.fromObject(object.rawTransaction);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @static
                     * @param {TW.Zilliqa.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.Zilliqa.Proto.Transaction.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.messageOneof = "transfer";
                        }
                        if (message.rawTransaction != null && message.hasOwnProperty("rawTransaction")) {
                            object.rawTransaction = $root.TW.Zilliqa.Proto.Transaction.Raw.toObject(message.rawTransaction, options);
                            if (options.oneofs)
                                object.messageOneof = "rawTransaction";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Zilliqa.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Transaction.Transfer = (function() {
    
                        /**
                         * Properties of a Transfer.
                         * @memberof TW.Zilliqa.Proto.Transaction
                         * @interface ITransfer
                         * @property {Uint8Array|null} [amount] Transfer amount
                         */
    
                        /**
                         * Constructs a new Transfer.
                         * @memberof TW.Zilliqa.Proto.Transaction
                         * @classdesc Represents a Transfer.
                         * @implements ITransfer
                         * @constructor
                         * @param {TW.Zilliqa.Proto.Transaction.ITransfer=} [properties] Properties to set
                         */
                        function Transfer(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Transfer amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @instance
                         */
                        Transfer.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * Creates a new Transfer instance using the specified properties.
                         * @function create
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @static
                         * @param {TW.Zilliqa.Proto.Transaction.ITransfer=} [properties] Properties to set
                         * @returns {TW.Zilliqa.Proto.Transaction.Transfer} Transfer instance
                         */
                        Transfer.create = function create(properties) {
                            return new Transfer(properties);
                        };
    
                        /**
                         * Encodes the specified Transfer message. Does not implicitly {@link TW.Zilliqa.Proto.Transaction.Transfer.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @static
                         * @param {TW.Zilliqa.Proto.Transaction.ITransfer} message Transfer message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Transfer.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.amount);
                            return writer;
                        };
    
                        /**
                         * Decodes a Transfer message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Zilliqa.Proto.Transaction.Transfer} Transfer
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Transfer.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Zilliqa.Proto.Transaction.Transfer();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.amount = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Transfer message.
                         * @function verify
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Transfer.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Zilliqa.Proto.Transaction.Transfer} Transfer
                         */
                        Transfer.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Zilliqa.Proto.Transaction.Transfer)
                                return object;
                            var message = new $root.TW.Zilliqa.Proto.Transaction.Transfer();
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @static
                         * @param {TW.Zilliqa.Proto.Transaction.Transfer} message Transfer
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Transfer.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            return object;
                        };
    
                        /**
                         * Converts this Transfer to JSON.
                         * @function toJSON
                         * @memberof TW.Zilliqa.Proto.Transaction.Transfer
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Transfer.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Transfer;
                    })();
    
                    Transaction.Raw = (function() {
    
                        /**
                         * Properties of a Raw.
                         * @memberof TW.Zilliqa.Proto.Transaction
                         * @interface IRaw
                         * @property {Uint8Array|null} [amount] Raw amount
                         * @property {Uint8Array|null} [code] Raw code
                         * @property {Uint8Array|null} [data] Raw data
                         */
    
                        /**
                         * Constructs a new Raw.
                         * @memberof TW.Zilliqa.Proto.Transaction
                         * @classdesc Represents a Raw.
                         * @implements IRaw
                         * @constructor
                         * @param {TW.Zilliqa.Proto.Transaction.IRaw=} [properties] Properties to set
                         */
                        function Raw(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Raw amount.
                         * @member {Uint8Array} amount
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @instance
                         */
                        Raw.prototype.amount = $util.newBuffer([]);
    
                        /**
                         * Raw code.
                         * @member {Uint8Array} code
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @instance
                         */
                        Raw.prototype.code = $util.newBuffer([]);
    
                        /**
                         * Raw data.
                         * @member {Uint8Array} data
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @instance
                         */
                        Raw.prototype.data = $util.newBuffer([]);
    
                        /**
                         * Creates a new Raw instance using the specified properties.
                         * @function create
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @static
                         * @param {TW.Zilliqa.Proto.Transaction.IRaw=} [properties] Properties to set
                         * @returns {TW.Zilliqa.Proto.Transaction.Raw} Raw instance
                         */
                        Raw.create = function create(properties) {
                            return new Raw(properties);
                        };
    
                        /**
                         * Encodes the specified Raw message. Does not implicitly {@link TW.Zilliqa.Proto.Transaction.Raw.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @static
                         * @param {TW.Zilliqa.Proto.Transaction.IRaw} message Raw message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Raw.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.amount);
                            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.code);
                            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                            return writer;
                        };
    
                        /**
                         * Decodes a Raw message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Zilliqa.Proto.Transaction.Raw} Raw
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Raw.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Zilliqa.Proto.Transaction.Raw();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.amount = reader.bytes();
                                    break;
                                case 2:
                                    message.code = reader.bytes();
                                    break;
                                case 3:
                                    message.data = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Verifies a Raw message.
                         * @function verify
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Raw.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                    return "amount: buffer expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
                                    return "code: buffer expected";
                            if (message.data != null && message.hasOwnProperty("data"))
                                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                    return "data: buffer expected";
                            return null;
                        };
    
                        /**
                         * Creates a Raw message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Zilliqa.Proto.Transaction.Raw} Raw
                         */
                        Raw.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Zilliqa.Proto.Transaction.Raw)
                                return object;
                            var message = new $root.TW.Zilliqa.Proto.Transaction.Raw();
                            if (object.amount != null)
                                if (typeof object.amount === "string")
                                    $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                                else if (object.amount.length)
                                    message.amount = object.amount;
                            if (object.code != null)
                                if (typeof object.code === "string")
                                    $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
                                else if (object.code.length)
                                    message.code = object.code;
                            if (object.data != null)
                                if (typeof object.data === "string")
                                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                                else if (object.data.length)
                                    message.data = object.data;
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Raw message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @static
                         * @param {TW.Zilliqa.Proto.Transaction.Raw} message Raw
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Raw.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if (options.bytes === String)
                                    object.amount = "";
                                else {
                                    object.amount = [];
                                    if (options.bytes !== Array)
                                        object.amount = $util.newBuffer(object.amount);
                                }
                                if (options.bytes === String)
                                    object.code = "";
                                else {
                                    object.code = [];
                                    if (options.bytes !== Array)
                                        object.code = $util.newBuffer(object.code);
                                }
                                if (options.bytes === String)
                                    object.data = "";
                                else {
                                    object.data = [];
                                    if (options.bytes !== Array)
                                        object.data = $util.newBuffer(object.data);
                                }
                            }
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
                            if (message.data != null && message.hasOwnProperty("data"))
                                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                            return object;
                        };
    
                        /**
                         * Converts this Raw to JSON.
                         * @function toJSON
                         * @memberof TW.Zilliqa.Proto.Transaction.Raw
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Raw.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Raw;
                    })();
    
                    return Transaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Zilliqa.Proto
                     * @interface ISigningInput
                     * @property {number|null} [version] SigningInput version
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {string|null} [to] SigningInput to
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Zilliqa.Proto.ITransaction|null} [transaction] SigningInput transaction
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Zilliqa.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Zilliqa.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput version.
                     * @member {number} version
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.version = 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput to.
                     * @member {string} to
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.to = "";
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput transaction.
                     * @member {TW.Zilliqa.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transaction = null;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Zilliqa.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Zilliqa.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.to);
                        if (message.gasPrice != null && Object.hasOwnProperty.call(message, "gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.gasPrice);
                        if (message.gasLimit != null && Object.hasOwnProperty.call(message, "gasLimit"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.gasLimit);
                        if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                            $root.TW.Zilliqa.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Zilliqa.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Zilliqa.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            case 2:
                                message.nonce = reader.uint64();
                                break;
                            case 3:
                                message.to = reader.string();
                                break;
                            case 4:
                                message.gasPrice = reader.bytes();
                                break;
                            case 5:
                                message.gasLimit = reader.uint64();
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            case 7:
                                message.transaction = $root.TW.Zilliqa.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Zilliqa.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Zilliqa.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Zilliqa.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Zilliqa.Proto.SigningInput();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Zilliqa.Proto.SigningInput.transaction: object expected");
                            message.transaction = $root.TW.Zilliqa.Proto.Transaction.fromObject(object.transaction);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {TW.Zilliqa.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.version = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            object.to = "";
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.transaction = null;
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Zilliqa.Proto.Transaction.toObject(message.transaction, options);
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Zilliqa.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Zilliqa.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Zilliqa.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Zilliqa.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Zilliqa.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Zilliqa.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Zilliqa.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Zilliqa.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Zilliqa.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Zilliqa.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {TW.Zilliqa.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.json = "";
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Zilliqa;
        })();
    
        return TW;
    })();

    return $root;
});
